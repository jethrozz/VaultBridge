/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
var __publicField = (obj, key2, value2) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};

// node_modules/hogan.js/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/hogan.js/lib/compiler.js"(exports) {
    (function(Hogan4) {
      var rIsWhitespace = /\S/, rQuot = /\"/g, rNewline = /\n/g, rCr = /\r/g, rSlash = /\\/g, rLineSep = /\u2028/, rParagraphSep = /\u2029/;
      Hogan4.tags = {
        "#": 1,
        "^": 2,
        "<": 3,
        "$": 4,
        "/": 5,
        "!": 6,
        ">": 7,
        "=": 8,
        "_v": 9,
        "{": 10,
        "&": 11,
        "_t": 12
      };
      Hogan4.scan = function scan(text, delimiters) {
        var len = text.length, IN_TEXT = 0, IN_TAG_TYPE = 1, IN_TAG = 2, state = IN_TEXT, tagType = null, tag2 = null, buf = "", tokens = [], seenTag = false, i2 = 0, lineStart = 0, otag = "{{", ctag = "}}";
        function addBuf() {
          if (buf.length > 0) {
            tokens.push({ tag: "_t", text: new String(buf) });
            buf = "";
          }
        }
        function lineIsWhitespace() {
          var isAllWhitespace = true;
          for (var j = lineStart; j < tokens.length; j++) {
            isAllWhitespace = Hogan4.tags[tokens[j].tag] < Hogan4.tags["_v"] || tokens[j].tag == "_t" && tokens[j].text.match(rIsWhitespace) === null;
            if (!isAllWhitespace) {
              return false;
            }
          }
          return isAllWhitespace;
        }
        function filterLine(haveSeenTag, noNewLine) {
          addBuf();
          if (haveSeenTag && lineIsWhitespace()) {
            for (var j = lineStart, next; j < tokens.length; j++) {
              if (tokens[j].text) {
                if ((next = tokens[j + 1]) && next.tag == ">") {
                  next.indent = tokens[j].text.toString();
                }
                tokens.splice(j, 1);
              }
            }
          } else if (!noNewLine) {
            tokens.push({ tag: "\n" });
          }
          seenTag = false;
          lineStart = tokens.length;
        }
        function changeDelimiters(text2, index) {
          var close = "=" + ctag, closeIndex = text2.indexOf(close, index), delimiters2 = trim(
            text2.substring(text2.indexOf("=", index) + 1, closeIndex)
          ).split(" ");
          otag = delimiters2[0];
          ctag = delimiters2[delimiters2.length - 1];
          return closeIndex + close.length - 1;
        }
        if (delimiters) {
          delimiters = delimiters.split(" ");
          otag = delimiters[0];
          ctag = delimiters[1];
        }
        for (i2 = 0; i2 < len; i2++) {
          if (state == IN_TEXT) {
            if (tagChange(otag, text, i2)) {
              --i2;
              addBuf();
              state = IN_TAG_TYPE;
            } else {
              if (text.charAt(i2) == "\n") {
                filterLine(seenTag);
              } else {
                buf += text.charAt(i2);
              }
            }
          } else if (state == IN_TAG_TYPE) {
            i2 += otag.length - 1;
            tag2 = Hogan4.tags[text.charAt(i2 + 1)];
            tagType = tag2 ? text.charAt(i2 + 1) : "_v";
            if (tagType == "=") {
              i2 = changeDelimiters(text, i2);
              state = IN_TEXT;
            } else {
              if (tag2) {
                i2++;
              }
              state = IN_TAG;
            }
            seenTag = i2;
          } else {
            if (tagChange(ctag, text, i2)) {
              tokens.push({
                tag: tagType,
                n: trim(buf),
                otag,
                ctag,
                i: tagType == "/" ? seenTag - otag.length : i2 + ctag.length
              });
              buf = "";
              i2 += ctag.length - 1;
              state = IN_TEXT;
              if (tagType == "{") {
                if (ctag == "}}") {
                  i2++;
                } else {
                  cleanTripleStache(tokens[tokens.length - 1]);
                }
              }
            } else {
              buf += text.charAt(i2);
            }
          }
        }
        filterLine(seenTag, true);
        return tokens;
      };
      function cleanTripleStache(token) {
        if (token.n.substr(token.n.length - 1) === "}") {
          token.n = token.n.substring(0, token.n.length - 1);
        }
      }
      function trim(s) {
        if (s.trim) {
          return s.trim();
        }
        return s.replace(/^\s*|\s*$/g, "");
      }
      function tagChange(tag2, text, index) {
        if (text.charAt(index) != tag2.charAt(0)) {
          return false;
        }
        for (var i2 = 1, l = tag2.length; i2 < l; i2++) {
          if (text.charAt(index + i2) != tag2.charAt(i2)) {
            return false;
          }
        }
        return true;
      }
      var allowedInSuper = { "_t": true, "\n": true, "$": true, "/": true };
      function buildTree(tokens, kind, stack, customTags) {
        var instructions = [], opener = null, tail = null, token = null;
        tail = stack[stack.length - 1];
        while (tokens.length > 0) {
          token = tokens.shift();
          if (tail && tail.tag == "<" && !(token.tag in allowedInSuper)) {
            throw new Error("Illegal content in < super tag.");
          }
          if (Hogan4.tags[token.tag] <= Hogan4.tags["$"] || isOpener(token, customTags)) {
            stack.push(token);
            token.nodes = buildTree(tokens, token.tag, stack, customTags);
          } else if (token.tag == "/") {
            if (stack.length === 0) {
              throw new Error("Closing tag without opener: /" + token.n);
            }
            opener = stack.pop();
            if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
              throw new Error("Nesting error: " + opener.n + " vs. " + token.n);
            }
            opener.end = token.i;
            return instructions;
          } else if (token.tag == "\n") {
            token.last = tokens.length == 0 || tokens[0].tag == "\n";
          }
          instructions.push(token);
        }
        if (stack.length > 0) {
          throw new Error("missing closing tag: " + stack.pop().n);
        }
        return instructions;
      }
      function isOpener(token, tags) {
        for (var i2 = 0, l = tags.length; i2 < l; i2++) {
          if (tags[i2].o == token.n) {
            token.tag = "#";
            return true;
          }
        }
      }
      function isCloser(close, open, tags) {
        for (var i2 = 0, l = tags.length; i2 < l; i2++) {
          if (tags[i2].c == close && tags[i2].o == open) {
            return true;
          }
        }
      }
      function stringifySubstitutions(obj) {
        var items = [];
        for (var key2 in obj) {
          items.push('"' + esc(key2) + '": function(c,p,t,i) {' + obj[key2] + "}");
        }
        return "{ " + items.join(",") + " }";
      }
      function stringifyPartials(codeObj) {
        var partials = [];
        for (var key2 in codeObj.partials) {
          partials.push('"' + esc(key2) + '":{name:"' + esc(codeObj.partials[key2].name) + '", ' + stringifyPartials(codeObj.partials[key2]) + "}");
        }
        return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
      }
      Hogan4.stringify = function(codeObj, text, options) {
        return "{code: function (c,p,i) { " + Hogan4.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) + "}";
      };
      var serialNo = 0;
      Hogan4.generate = function(tree, text, options) {
        serialNo = 0;
        var context = { code: "", subs: {}, partials: {} };
        Hogan4.walk(tree, context);
        if (options.asString) {
          return this.stringify(context, text, options);
        }
        return this.makeTemplate(context, text, options);
      };
      Hogan4.wrapMain = function(code) {
        return 'var t=this;t.b(i=i||"");' + code + "return t.fl();";
      };
      Hogan4.template = Hogan4.Template;
      Hogan4.makeTemplate = function(codeObj, text, options) {
        var template = this.makePartials(codeObj);
        template.code = new Function("c", "p", "i", this.wrapMain(codeObj.code));
        return new this.template(template, text, this, options);
      };
      Hogan4.makePartials = function(codeObj) {
        var key2, template = { subs: {}, partials: codeObj.partials, name: codeObj.name };
        for (key2 in template.partials) {
          template.partials[key2] = this.makePartials(template.partials[key2]);
        }
        for (key2 in codeObj.subs) {
          template.subs[key2] = new Function("c", "p", "t", "i", codeObj.subs[key2]);
        }
        return template;
      };
      function esc(s) {
        return s.replace(rSlash, "\\\\").replace(rQuot, '\\"').replace(rNewline, "\\n").replace(rCr, "\\r").replace(rLineSep, "\\u2028").replace(rParagraphSep, "\\u2029");
      }
      function chooseMethod(s) {
        return ~s.indexOf(".") ? "d" : "f";
      }
      function createPartial(node, context) {
        var prefix = "<" + (context.prefix || "");
        var sym = prefix + node.n + serialNo++;
        context.partials[sym] = { name: node.n, partials: {} };
        context.code += 't.b(t.rp("' + esc(sym) + '",c,p,"' + (node.indent || "") + '"));';
        return sym;
      }
      Hogan4.codegen = {
        "#": function(node, context) {
          context.code += "if(t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,0,' + node.i + "," + node.end + ',"' + node.otag + " " + node.ctag + '")){t.rs(c,p,function(c,p,t){';
          Hogan4.walk(node.nodes, context);
          context.code += "});c.pop();}";
        },
        "^": function(node, context) {
          context.code += "if(!t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
          Hogan4.walk(node.nodes, context);
          context.code += "};";
        },
        ">": createPartial,
        "<": function(node, context) {
          var ctx = { partials: {}, code: "", subs: {}, inPartial: true };
          Hogan4.walk(node.nodes, ctx);
          var template = context.partials[createPartial(node, context)];
          template.subs = ctx.subs;
          template.partials = ctx.partials;
        },
        "$": function(node, context) {
          var ctx = { subs: {}, code: "", partials: context.partials, prefix: node.n };
          Hogan4.walk(node.nodes, ctx);
          context.subs[node.n] = ctx.code;
          if (!context.inPartial) {
            context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
          }
        },
        "\n": function(node, context) {
          context.code += write('"\\n"' + (node.last ? "" : " + i"));
        },
        "_v": function(node, context) {
          context.code += "t.b(t.v(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
        },
        "_t": function(node, context) {
          context.code += write('"' + esc(node.text) + '"');
        },
        "{": tripleStache,
        "&": tripleStache
      };
      function tripleStache(node, context) {
        context.code += "t.b(t.t(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
      }
      function write(s) {
        return "t.b(" + s + ");";
      }
      Hogan4.walk = function(nodelist, context) {
        var func;
        for (var i2 = 0, l = nodelist.length; i2 < l; i2++) {
          func = Hogan4.codegen[nodelist[i2].tag];
          func && func(nodelist[i2], context);
        }
        return context;
      };
      Hogan4.parse = function(tokens, text, options) {
        options = options || {};
        return buildTree(tokens, "", [], options.sectionTags || []);
      };
      Hogan4.cache = {};
      Hogan4.cacheKey = function(text, options) {
        return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join("||");
      };
      Hogan4.compile = function(text, options) {
        options = options || {};
        var key2 = Hogan4.cacheKey(text, options);
        var template = this.cache[key2];
        if (template) {
          var partials = template.partials;
          for (var name2 in partials) {
            delete partials[name2].instance;
          }
          return template;
        }
        template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
        return this.cache[key2] = template;
      };
    })(typeof exports !== "undefined" ? exports : Hogan);
  }
});

// node_modules/hogan.js/lib/template.js
var require_template = __commonJS({
  "node_modules/hogan.js/lib/template.js"(exports) {
    var Hogan4 = {};
    (function(Hogan5) {
      Hogan5.Template = function(codeObj, text, compiler, options) {
        codeObj = codeObj || {};
        this.r = codeObj.code || this.r;
        this.c = compiler;
        this.options = options || {};
        this.text = text || "";
        this.partials = codeObj.partials || {};
        this.subs = codeObj.subs || {};
        this.buf = "";
      };
      Hogan5.Template.prototype = {
        // render: replaced by generated code.
        r: function(context, partials, indent2) {
          return "";
        },
        // variable escaping
        v: hoganEscape,
        // triple stache
        t: coerceToString,
        render: function render(context, partials, indent2) {
          return this.ri([context], partials || {}, indent2);
        },
        // render internal -- a hook for overrides that catches partials too
        ri: function(context, partials, indent2) {
          return this.r(context, partials, indent2);
        },
        // ensurePartial
        ep: function(symbol, partials) {
          var partial = this.partials[symbol];
          var template = partials[partial.name];
          if (partial.instance && partial.base == template) {
            return partial.instance;
          }
          if (typeof template == "string") {
            if (!this.c) {
              throw new Error("No compiler available.");
            }
            template = this.c.compile(template, this.options);
          }
          if (!template) {
            return null;
          }
          this.partials[symbol].base = template;
          if (partial.subs) {
            if (!partials.stackText)
              partials.stackText = {};
            for (key in partial.subs) {
              if (!partials.stackText[key]) {
                partials.stackText[key] = this.activeSub !== void 0 && partials.stackText[this.activeSub] ? partials.stackText[this.activeSub] : this.text;
              }
            }
            template = createSpecializedPartial(
              template,
              partial.subs,
              partial.partials,
              this.stackSubs,
              this.stackPartials,
              partials.stackText
            );
          }
          this.partials[symbol].instance = template;
          return template;
        },
        // tries to find a partial in the current scope and render it
        rp: function(symbol, context, partials, indent2) {
          var partial = this.ep(symbol, partials);
          if (!partial) {
            return "";
          }
          return partial.ri(context, partials, indent2);
        },
        // render a section
        rs: function(context, partials, section) {
          var tail = context[context.length - 1];
          if (!isArray(tail)) {
            section(context, partials, this);
            return;
          }
          for (var i2 = 0; i2 < tail.length; i2++) {
            context.push(tail[i2]);
            section(context, partials, this);
            context.pop();
          }
        },
        // maybe start a section
        s: function(val, ctx, partials, inverted, start, end, tags) {
          var pass;
          if (isArray(val) && val.length === 0) {
            return false;
          }
          if (typeof val == "function") {
            val = this.ms(val, ctx, partials, inverted, start, end, tags);
          }
          pass = !!val;
          if (!inverted && pass && ctx) {
            ctx.push(typeof val == "object" ? val : ctx[ctx.length - 1]);
          }
          return pass;
        },
        // find values with dotted names
        d: function(key2, ctx, partials, returnFound) {
          var found, names = key2.split("."), val = this.f(names[0], ctx, partials, returnFound), doModelGet = this.options.modelGet, cx = null;
          if (key2 === "." && isArray(ctx[ctx.length - 2])) {
            val = ctx[ctx.length - 1];
          } else {
            for (var i2 = 1; i2 < names.length; i2++) {
              found = findInScope(names[i2], val, doModelGet);
              if (found !== void 0) {
                cx = val;
                val = found;
              } else {
                val = "";
              }
            }
          }
          if (returnFound && !val) {
            return false;
          }
          if (!returnFound && typeof val == "function") {
            ctx.push(cx);
            val = this.mv(val, ctx, partials);
            ctx.pop();
          }
          return val;
        },
        // find values with normal names
        f: function(key2, ctx, partials, returnFound) {
          var val = false, v = null, found = false, doModelGet = this.options.modelGet;
          for (var i2 = ctx.length - 1; i2 >= 0; i2--) {
            v = ctx[i2];
            val = findInScope(key2, v, doModelGet);
            if (val !== void 0) {
              found = true;
              break;
            }
          }
          if (!found) {
            return returnFound ? false : "";
          }
          if (!returnFound && typeof val == "function") {
            val = this.mv(val, ctx, partials);
          }
          return val;
        },
        // higher order templates
        ls: function(func, cx, partials, text, tags) {
          var oldTags = this.options.delimiters;
          this.options.delimiters = tags;
          this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
          this.options.delimiters = oldTags;
          return false;
        },
        // compile text
        ct: function(text, cx, partials) {
          if (this.options.disableLambda) {
            throw new Error("Lambda features disabled.");
          }
          return this.c.compile(text, this.options).render(cx, partials);
        },
        // template result buffering
        b: function(s) {
          this.buf += s;
        },
        fl: function() {
          var r = this.buf;
          this.buf = "";
          return r;
        },
        // method replace section
        ms: function(func, ctx, partials, inverted, start, end, tags) {
          var textSource, cx = ctx[ctx.length - 1], result = func.call(cx);
          if (typeof result == "function") {
            if (inverted) {
              return true;
            } else {
              textSource = this.activeSub && this.subsText && this.subsText[this.activeSub] ? this.subsText[this.activeSub] : this.text;
              return this.ls(result, cx, partials, textSource.substring(start, end), tags);
            }
          }
          return result;
        },
        // method replace variable
        mv: function(func, ctx, partials) {
          var cx = ctx[ctx.length - 1];
          var result = func.call(cx);
          if (typeof result == "function") {
            return this.ct(coerceToString(result.call(cx)), cx, partials);
          }
          return result;
        },
        sub: function(name2, context, partials, indent2) {
          var f = this.subs[name2];
          if (f) {
            this.activeSub = name2;
            f(context, partials, this, indent2);
            this.activeSub = false;
          }
        }
      };
      function findInScope(key2, scope, doModelGet) {
        var val;
        if (scope && typeof scope == "object") {
          if (scope[key2] !== void 0) {
            val = scope[key2];
          } else if (doModelGet && scope.get && typeof scope.get == "function") {
            val = scope.get(key2);
          }
        }
        return val;
      }
      function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
        function PartialTemplate() {
        }
        ;
        PartialTemplate.prototype = instance;
        function Substitutions() {
        }
        ;
        Substitutions.prototype = instance.subs;
        var key2;
        var partial = new PartialTemplate();
        partial.subs = new Substitutions();
        partial.subsText = {};
        partial.buf = "";
        stackSubs = stackSubs || {};
        partial.stackSubs = stackSubs;
        partial.subsText = stackText;
        for (key2 in subs) {
          if (!stackSubs[key2])
            stackSubs[key2] = subs[key2];
        }
        for (key2 in stackSubs) {
          partial.subs[key2] = stackSubs[key2];
        }
        stackPartials = stackPartials || {};
        partial.stackPartials = stackPartials;
        for (key2 in partials) {
          if (!stackPartials[key2])
            stackPartials[key2] = partials[key2];
        }
        for (key2 in stackPartials) {
          partial.partials[key2] = stackPartials[key2];
        }
        return partial;
      }
      var rAmp = /&/g, rLt = /</g, rGt = />/g, rApos = /\'/g, rQuot = /\"/g, hChars = /[&<>\"\']/;
      function coerceToString(val) {
        return String(val === null || val === void 0 ? "" : val);
      }
      function hoganEscape(str) {
        str = coerceToString(str);
        return hChars.test(str) ? str.replace(rAmp, "&amp;").replace(rLt, "&lt;").replace(rGt, "&gt;").replace(rApos, "&#39;").replace(rQuot, "&quot;") : str;
      }
      var isArray = Array.isArray || function(a3) {
        return Object.prototype.toString.call(a3) === "[object Array]";
      };
    })(typeof exports !== "undefined" ? exports : Hogan4);
  }
});

// node_modules/hogan.js/lib/hogan.js
var require_hogan = __commonJS({
  "node_modules/hogan.js/lib/hogan.js"(exports, module2) {
    var Hogan4 = require_compiler();
    Hogan4.Template = require_template().Template;
    Hogan4.template = Hogan4.Template;
    module2.exports = Hogan4;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultBridgePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
var swap8IfBE = isLE ? (n2) => n2 : (n2) => byteSwap(n2);
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex2 = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex2 += hexes[bytes[i2]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array2[ai] = n1 * 16 + n2;
  }
  return array2;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function kdfInputToBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    abytes(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    res.set(a3, pad);
    pad += a3.length;
  }
  return res;
}
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function createOptHasher(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value2, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value2 >> _32n2 & _u32_max);
  const wl = Number(value2 & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a3, b, c) {
  return a3 & b ^ ~a3 & c;
}
function Maj(a3, b, c) {
  return a3 & b ^ a3 & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA384_IV = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
var sha384 = /* @__PURE__ */ createHasher(() => new SHA384());

// node_modules/@mysten/sui/node_modules/@noble/curves/esm/utils.js
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value2) {
  if (typeof value2 !== "boolean")
    throw new Error(title + " boolean expected, got " + value2);
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n : BigInt("0x" + hex2);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e3) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e3);
    }
  } else if (isBytes(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes(a3, b) {
  if (a3.length !== b.length)
    return false;
  let diff2 = 0;
  for (let i2 = 0; i2 < a3.length; i2++)
    diff2 |= a3[i2] ^ b[i2];
  return diff2 === 0;
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
function inRange(n2, min, max2) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max2) && min <= n2 && n2 < max2;
}
function aInRange(title, n2, min, max2) {
  if (!inRange(n2, min, max2))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max2 + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n2) => (_1n << BigInt(n2)) - _1n;
function _validateObject(object2, fields, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/@mysten/sui/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _3n = /* @__PURE__ */ BigInt(3);
var _4n = /* @__PURE__ */ BigInt(4);
var _5n = /* @__PURE__ */ BigInt(5);
var _7n = /* @__PURE__ */ BigInt(7);
var _8n = /* @__PURE__ */ BigInt(8);
var _9n = /* @__PURE__ */ BigInt(9);
var _16n = /* @__PURE__ */ BigInt(16);
function mod(a3, b) {
  const result = a3 % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a3 = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a3 !== _0n2) {
    const q = b / a3;
    const r = b % a3;
    const m = x - u * q;
    const n2 = y - v * q;
    b = a3, a3 = r, x = u, y = v, u = m, v = n2;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp4, root, n2) {
  if (!Fp4.eql(Fp4.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp4, n2) {
  const p1div4 = (Fp4.ORDER + _1n2) / _4n;
  const root = Fp4.pow(n2, p1div4);
  assertIsSquare(Fp4, root, n2);
  return root;
}
function sqrt5mod8(Fp4, n2) {
  const p5div8 = (Fp4.ORDER - _5n) / _8n;
  const n22 = Fp4.mul(n2, _2n);
  const v = Fp4.pow(n22, p5div8);
  const nv = Fp4.mul(n2, v);
  const i2 = Fp4.mul(Fp4.mul(nv, _2n), v);
  const root = Fp4.mul(nv, Fp4.sub(i2, Fp4.ONE));
  assertIsSquare(Fp4, root, n2);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp4, n2) => {
    let tv1 = Fp4.pow(n2, c4);
    let tv2 = Fp4.mul(tv1, c1);
    const tv3 = Fp4.mul(tv1, c2);
    const tv4 = Fp4.mul(tv1, c3);
    const e1 = Fp4.eql(Fp4.sqr(tv2), n2);
    const e22 = Fp4.eql(Fp4.sqr(tv3), n2);
    tv1 = Fp4.cmov(tv1, tv2, e1);
    tv2 = Fp4.cmov(tv4, tv3, e22);
    const e3 = Fp4.eql(Fp4.sqr(tv2), n2);
    const root = Fp4.cmov(tv1, tv2, e3);
    assertIsSquare(Fp4, root, n2);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp4, n2) {
    if (Fp4.is0(n2))
      return n2;
    if (FpLegendre(Fp4, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp4.mul(Fp4.ONE, cc);
    let t3 = Fp4.pow(n2, Q);
    let R = Fp4.pow(n2, Q1div2);
    while (!Fp4.eql(t3, Fp4.ONE)) {
      if (Fp4.is0(t3))
        return Fp4.ZERO;
      let i2 = 1;
      let t_tmp = Fp4.sqr(t3);
      while (!Fp4.eql(t_tmp, Fp4.ONE)) {
        i2++;
        t_tmp = Fp4.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i2 - 1);
      const b = Fp4.pow(c, exponent);
      M = i2;
      c = Fp4.sqr(b);
      t3 = Fp4.mul(t3, c);
      R = Fp4.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp4, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp4.ONE;
  if (power === _1n2)
    return num;
  let p = Fp4.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp4.mul(p, d);
    d = Fp4.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp4, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp4.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp4.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp4.mul(acc, num);
  }, Fp4.ONE);
  const invertedAcc = Fp4.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp4.is0(num))
      return acc;
    inverted[i2] = Fp4.mul(acc, inverted[i2]);
    return Fp4.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp4, n2) {
  const p1mod2 = (Fp4.ORDER - _1n2) / _2n;
  const powered = Fp4.pow(n2, p1mod2);
  const yes = Fp4.eql(powered, Fp4.ONE);
  const zero = Fp4.eql(powered, Fp4.ZERO);
  const no = Fp4.eql(powered, Fp4.neg(Fp4.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modOnDecode = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE2)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE2 = _opts.isLE;
    if (typeof _opts.modOnDecode === "boolean")
      modOnDecode = _opts.modOnDecode;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    // is valid and invertible
    isValidNot0: (num) => !f.is0(num) && f.isValid(num),
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: _sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n2);
    }),
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modOnDecode)
        scalar = mod(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a3, b, c) => c ? b : a3
  });
  return Object.freeze(f);
}

// node_modules/@mysten/sui/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i2) => c.fromAffine(p.toAffine(invertedZs[i2])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i2) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i2) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n2) {
  if (n2 !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point, bits) {
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p = this.ZERO) {
    let d = elm;
    while (n2 > _0n3) {
      if (n2 & _1n3)
        p = p.add(d);
      d = d.double();
      n2 >>= _1n3;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p = point;
    let base = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p;
      points.push(base);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n2);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n2);
    return acc;
  }
  getPrecomputes(W, point, transform2) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform2 === "function")
          comp = transform2(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform2) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform2), scalar);
  }
  unsafe(point, scalar, transform2, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform2), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order);
  }
}
function _createCurveFields(type2, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type2} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp4 = createField(CURVE.p, curveOpts.Fp);
  const Fn3 = createField(CURVE.n, curveOpts.Fn);
  const _b = type2 === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp4.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp4, Fn: Fn3 };
}

// node_modules/@mysten/sui/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _8n2 = BigInt(8);
function isEdValidXY(Fp4, CURVE, x, y) {
  const x2 = Fp4.sqr(x);
  const y2 = Fp4.sqr(y);
  const left = Fp4.add(Fp4.mul(CURVE.a, x2), y2);
  const right = Fp4.add(Fp4.ONE, Fp4.mul(CURVE.d, Fp4.mul(x2, y2)));
  return Fp4.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
  const { Fp: Fp4, Fn: Fn3 } = _createCurveFields("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn3.BYTES * 8) - _1n4;
  const modP = (n2) => Fp4.create(n2);
  const uvRatio3 = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp4.sqrt(Fp4.div(u, v)) };
    } catch (e3) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp4, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n2, min, MASK);
    return n2;
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp4.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp4.mul(Z, iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    const { a: a3, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a3);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    // TODO: remove
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ(Point, points);
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn3, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point(x, y, _1n4, modP(x * y));
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a3 } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D = modP(a3 * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a: a3, d } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a3 * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n2 = scalar;
      aInRange("scalar", n2, _1n4, CURVE_ORDER);
      const { p, f } = wnaf.cached(this, n2, (p2) => normalizeZ(Point, p2));
      return normalizeZ(Point, [p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n2 = scalar;
      aInRange("scalar", n2, _0n4, CURVE_ORDER);
      if (n2 === _0n4)
        return Point.ZERO;
      if (this.is0() || n2 === _1n4)
        return this;
      return wnaf.unsafe(this, n2, (p) => normalizeZ(Point, p), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes, zip215 = false) {
      abytes(bytes);
      return Point.fromHex(bytes, zip215);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d, a: a3 } = CURVE;
      const len = Fp4.BYTES;
      hex2 = ensureBytes("pointHex", hex2, len);
      abool("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max2 = zip215 ? MASK : Fp4.ORDER;
      aInRange("pointHex.y", y, _0n4, max2);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d * y2 - a3);
      let { isValid, value: x } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = numberToBytesLE(y, Fp4.BYTES);
      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes;
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
  Point.Fp = Fp4;
  Point.Fn = Fn3;
  const wnaf = new wNAF(Point, Fn3.BYTES * 8);
  return Point;
}
var PrimeEdwardsPoint = class {
  constructor(ep) {
    this.ep = ep;
  }
  // Static methods that must be implemented by subclasses
  static fromBytes(_bytes3) {
    throw new Error("fromBytes must be implemented by subclass");
  }
  static fromHex(_hex) {
    throw new Error("fromHex must be implemented by subclass");
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  // Common implementations
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  /** @deprecated use `toBytes` */
  toRawBytes() {
    return this.toBytes();
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
};
function eddsa(Point, cHash, eddsaOpts) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE: G, Fp: Fp4, Fn: Fn3 } = Point;
  const CURVE_ORDER = Fn3.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes3 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN(a3) {
    return Fn3.create(a3);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key2) {
    const len = Fp4.BYTES;
    key2 = ensureBytes("private key", key2, len);
    const hashed = ensureBytes("hashed private key", cHash(key2), 2 * len);
    const head = adjustScalarBytes3(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = G.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, secretKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange("signature.s", s, _0n4, CURVE_ORDER);
    const L = Fp4.BYTES;
    const res = concatBytes(R, numberToBytesLE(s, L));
    return ensureBytes("result", res, L * 2);
  }
  const verifyOpts = { zip215: true };
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp4.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point.fromHex(publicKey, zip215);
      R = Point.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error2) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G.precompute(8);
  const size = Fp4.BYTES;
  const lengths = {
    secret: size,
    public: size,
    signature: 2 * size,
    seed: size
  };
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return seed;
  }
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    randomPrivateKey: randomSecretKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     *
     * There is NO `fromMontgomery`:
     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate
     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*
     *   accepts inputs on the quadratic twist, which can't be moved to ed25519
     */
    toMontgomery(publicKey) {
      const { y } = Point.fromBytes(publicKey);
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp4.div(_1n4 + y, _1n4 - y) : Fp4.div(y - _1n4, y + _1n4);
      return Fp4.toBytes(u);
    },
    toMontgomeryPriv(privateKey) {
      abytes(privateKey, size);
      const hashed = cHash(privateKey.subarray(0, size));
      return adjustScalarBytes3(hashed).subarray(0, size);
    },
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isValidSecretKey(key2) {
    try {
      return !!Fn3.fromBytes(key2, false);
    } catch (error2) {
      return false;
    }
  }
  function isValidPublicKey(key2, zip215) {
    try {
      return !!Point.fromBytes(key2, zip215);
    } catch (error2) {
      return false;
    }
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    sign,
    verify,
    utils,
    Point,
    info: { type: "edwards", lengths }
  });
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp4 = c.Fp;
  const Fn3 = Field(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp4, Fn: Fn3, uvRatio: c.uvRatio };
  const eddsaOpts = {
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa3) {
  const legacy = Object.assign({}, eddsa3, { ExtendedPoint: eddsa3.Point, CURVE: c });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point, hash, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}

// node_modules/@mysten/sui/node_modules/@noble/curves/esm/ed25519.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
var ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n3,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE.p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n3, P) * b2 % P;
  const b5 = pow2(b4, _1n5, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n3, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P = ed25519_CURVE.p;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
var Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
var ed25519Defaults = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE,
  Fp,
  hash: sha512,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))();
var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n5, number2);
var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod3 = ed25519.CURVE.Fp.create;
  const r = mod3(SQRT_M1 * r0 * r0);
  const Ns = mod3((r + _1n5) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod3((c - d * r) * mod3(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod3(s * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod3(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod3(c * (r - _1n5) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod3((s + s) * D);
  const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod3(_1n5 - s2);
  const W3 = mod3(_1n5 + s2);
  return new ed25519.Point(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
}
function ristretto255_map(bytes) {
  abytes(bytes, 64);
  const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap(r1);
  const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap(r2);
  return new _RistrettoPoint(R1.add(R2));
}
var _RistrettoPoint = class extends PrimeEdwardsPoint {
  constructor(ep) {
    super(ep);
  }
  static fromAffine(ap) {
    return new _RistrettoPoint(ed25519.Point.fromAffine(ap));
  }
  assertSame(other) {
    if (!(other instanceof _RistrettoPoint))
      throw new Error("RistrettoPoint expected");
  }
  init(ep) {
    return new _RistrettoPoint(ep);
  }
  /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
  static hashToCurve(hex2) {
    return ristretto255_map(ensureBytes("ristrettoHash", hex2, 64));
  }
  static fromBytes(bytes) {
    abytes(bytes, 32);
    const { a: a3, d } = ed25519.CURVE;
    const P = Fp.ORDER;
    const mod3 = Fp.create;
    const s = bytes255ToNumberLE(bytes);
    if (!equalBytes(numberToBytesLE(s, 32), bytes) || isNegativeLE(s, P))
      throw new Error("invalid ristretto255 encoding 1");
    const s2 = mod3(s * s);
    const u1 = mod3(_1n5 + a3 * s2);
    const u2 = mod3(_1n5 - a3 * s2);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u2 * u2);
    const v = mod3(a3 * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
    const Dx = mod3(I * u2);
    const Dy = mod3(I * Dx * v);
    let x = mod3((s + s) * Dx);
    if (isNegativeLE(x, P))
      x = mod3(-x);
    const y = mod3(u1 * Dy);
    const t3 = mod3(x * y);
    if (!isValid || isNegativeLE(t3, P) || y === _0n5)
      throw new Error("invalid ristretto255 encoding 2");
    return new _RistrettoPoint(new ed25519.Point(x, y, _1n5, t3));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex2) {
    return _RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex2, 32));
  }
  static msm(points, scalars) {
    return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { X, Y, Z, T } = this.ep;
    const P = Fp.ORDER;
    const mod3 = Fp.create;
    const u1 = mod3(mod3(Z + Y) * mod3(Z - Y));
    const u2 = mod3(X * Y);
    const u2sq = mod3(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D2 = mod3(invsqrt * u2);
    const zInv = mod3(D1 * D2 * T);
    let D;
    if (isNegativeLE(T * zInv, P)) {
      let _x = mod3(Y * SQRT_M1);
      let _y = mod3(X * SQRT_M1);
      X = _x;
      Y = _y;
      D = mod3(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(X * zInv, P))
      Y = mod3(-Y);
    let s = mod3((Z - Y) * D);
    if (isNegativeLE(s, P))
      s = mod3(-s);
    return numberToBytesLE(s, 32);
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    this.assertSame(other);
    const { X: X1, Y: Y1 } = this.ep;
    const { X: X2, Y: Y2 } = other.ep;
    const mod3 = Fp.create;
    const one = mod3(X1 * Y2) === mod3(Y1 * X2);
    const two = mod3(Y1 * Y2) === mod3(X1 * X2);
    return one || two;
  }
  is0() {
    return this.equals(_RistrettoPoint.ZERO);
  }
};
_RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
_RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
_RistrettoPoint.Fp = Fp;
_RistrettoPoint.Fn = Fn;

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a3) => a3;
  const wrap2 = (a3, b) => (c) => a3(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap2, id);
  const decode = args.map((x) => x.decode).reduce(wrap2, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i2) => [l, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
function join(separator2 = "") {
  astr("join", separator2);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator2);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator2);
    }
  };
}
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  afn(fn);
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div2 = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div2);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd = (a3, b) => b === 0 ? a3 : gcd(b, a3 % b);
var radix2carry = (
  /* @__NO_SIDE_EFFECTS__ */
  (from, to) => from + (to - gcd(from, to))
);
var powers = /* @__PURE__ */ (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix2(data, from, to, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max2 = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n2 of data) {
    anumber2(n2);
    if (n2 >= max2)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
    carry = carry << from | n2;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber2(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e3) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
  astr("base64", s);
  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet2 = isUrl ? "base64url" : "base64";
  if (s.length > 0 && !re.test(s))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
};
var base64 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64();
  },
  decode(s) {
    return decodeBase64Builtin(s, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    return decodeBase64Builtin(s, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (
  /* @__NO_SIDE_EFFECTS__ */
  (abc) => chain(radix(58), alphabet(abc), join(""))
);
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes2(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin2 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin2 ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@mysten/utils/dist/esm/b58.js
var toBase58 = (buffer) => base58.encode(buffer);
var fromBase58 = (str) => base58.decode(str);

// node_modules/@mysten/utils/dist/esm/b64.js
function fromBase64(base64String3) {
  return Uint8Array.from(atob(base64String3), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i2 = 0; i2 < bytes.length; i2 += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i2, i2 + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// node_modules/@mysten/utils/dist/esm/hex.js
function fromHex(hexStr) {
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@mysten/utils/dist/esm/chunk.js
function chunk(array2, size) {
  return Array.from({ length: Math.ceil(array2.length / size) }, (_, i2) => {
    return array2.slice(i2 * size, (i2 + 1) * size);
  });
}

// node_modules/@mysten/utils/dist/esm/dataloader.js
var DataLoader = class {
  constructor(batchLoadFn, options) {
    if (typeof batchLoadFn !== "function") {
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`
      );
    }
    this._batchLoadFn = batchLoadFn;
    this._maxBatchSize = getValidMaxBatchSize(options);
    this._batchScheduleFn = getValidBatchScheduleFn(options);
    this._cacheKeyFn = getValidCacheKeyFn(options);
    this._cacheMap = getValidCacheMap(options);
    this._batch = null;
    this.name = getValidName(options);
  }
  /**
   * Loads a key, returning a `Promise` for the value represented by that key.
   */
  load(key2) {
    if (key2 === null || key2 === void 0) {
      throw new TypeError(
        `The loader.load() function must be called with a value, but got: ${String(key2)}.`
      );
    }
    const batch = getCurrentBatch(this);
    const cacheMap2 = this._cacheMap;
    let cacheKey;
    if (cacheMap2) {
      cacheKey = this._cacheKeyFn(key2);
      const cachedPromise = cacheMap2.get(cacheKey);
      if (cachedPromise) {
        const cacheHits = batch.cacheHits || (batch.cacheHits = []);
        return new Promise((resolve) => {
          cacheHits.push(() => {
            resolve(cachedPromise);
          });
        });
      }
    }
    batch.keys.push(key2);
    const promise = new Promise((resolve, reject) => {
      batch.callbacks.push({ resolve, reject });
    });
    if (cacheMap2) {
      cacheMap2.set(cacheKey, promise);
    }
    return promise;
  }
  /**
   * Loads multiple keys, promising an array of values:
   *
   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);
   *
   * This is similar to the more verbose:
   *
   *     var [ a, b ] = await Promise.all([
   *       myLoader.load('a'),
   *       myLoader.load('b')
   *     ]);
   *
   * However it is different in the case where any load fails. Where
   * Promise.all() would reject, loadMany() always resolves, however each result
   * is either a value or an Error instance.
   *
   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);
   *     // c instanceof Error
   *
   */
  loadMany(keys) {
    if (!isArrayLike(keys)) {
      throw new TypeError(
        `The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`
      );
    }
    const loadPromises = [];
    for (let i2 = 0; i2 < keys.length; i2++) {
      loadPromises.push(this.load(keys[i2]).catch((error2) => error2));
    }
    return Promise.all(loadPromises);
  }
  /**
   * Clears the value at `key` from the cache, if it exists. Returns itself for
   * method chaining.
   */
  clear(key2) {
    const cacheMap2 = this._cacheMap;
    if (cacheMap2) {
      const cacheKey = this._cacheKeyFn(key2);
      cacheMap2.delete(cacheKey);
    }
    return this;
  }
  /**
   * Clears the entire cache. To be used when some event results in unknown
   * invalidations across this particular `DataLoader`. Returns itself for
   * method chaining.
   */
  clearAll() {
    const cacheMap2 = this._cacheMap;
    if (cacheMap2) {
      cacheMap2.clear();
    }
    return this;
  }
  /**
   * Adds the provided key and value to the cache. If the key already
   * exists, no change is made. Returns itself for method chaining.
   *
   * To prime the cache with an error at a key, provide an Error instance.
   */
  prime(key2, value2) {
    const cacheMap2 = this._cacheMap;
    if (cacheMap2) {
      const cacheKey = this._cacheKeyFn(key2);
      if (cacheMap2.get(cacheKey) === void 0) {
        let promise;
        if (value2 instanceof Error) {
          promise = Promise.reject(value2);
          promise.catch(() => {
          });
        } else {
          promise = Promise.resolve(value2);
        }
        cacheMap2.set(cacheKey, promise);
      }
    }
    return this;
  }
};
var enqueuePostPromiseJob = (
  /** @ts-ignore */
  typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
    if (!resolvedPromise) {
      resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(() => {
      process.nextTick(fn);
    });
  } : (
    // @ts-ignore
    typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    }
  )
);
var resolvedPromise;
function getCurrentBatch(loader) {
  const existingBatch = loader._batch;
  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
    return existingBatch;
  }
  const newBatch = { hasDispatched: false, keys: [], callbacks: [] };
  loader._batch = newBatch;
  loader._batchScheduleFn(() => {
    dispatchBatch(loader, newBatch);
  });
  return newBatch;
}
function dispatchBatch(loader, batch) {
  batch.hasDispatched = true;
  if (batch.keys.length === 0) {
    resolveCacheHits(batch);
    return;
  }
  let batchPromise;
  try {
    batchPromise = loader._batchLoadFn(batch.keys);
  } catch (e3) {
    return failedDispatch(
      loader,
      batch,
      new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(e3)}.`
      )
    );
  }
  if (!batchPromise || typeof batchPromise.then !== "function") {
    return failedDispatch(
      loader,
      batch,
      new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(batchPromise)}.`
      )
    );
  }
  Promise.resolve(batchPromise).then((values) => {
    if (!isArrayLike(values)) {
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(values)}.`
      );
    }
    if (values.length !== batch.keys.length) {
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(batch.keys)}

Values:
${String(values)}`
      );
    }
    resolveCacheHits(batch);
    for (let i2 = 0; i2 < batch.callbacks.length; i2++) {
      const value2 = values[i2];
      if (value2 instanceof Error) {
        batch.callbacks[i2].reject(value2);
      } else {
        batch.callbacks[i2].resolve(value2);
      }
    }
  }).catch((error2) => {
    failedDispatch(loader, batch, error2);
  });
}
function failedDispatch(loader, batch, error2) {
  resolveCacheHits(batch);
  for (let i2 = 0; i2 < batch.keys.length; i2++) {
    loader.clear(batch.keys[i2]);
    batch.callbacks[i2].reject(error2);
  }
}
function resolveCacheHits(batch) {
  if (batch.cacheHits) {
    for (let i2 = 0; i2 < batch.cacheHits.length; i2++) {
      batch.cacheHits[i2]();
    }
  }
}
function getValidMaxBatchSize(options) {
  const shouldBatch = !options || options.batch !== false;
  if (!shouldBatch) {
    return 1;
  }
  const maxBatchSize = options && options.maxBatchSize;
  if (maxBatchSize === void 0) {
    return Infinity;
  }
  if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
    throw new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);
  }
  return maxBatchSize;
}
function getValidBatchScheduleFn(options) {
  const batchScheduleFn = options && options.batchScheduleFn;
  if (batchScheduleFn === void 0) {
    return enqueuePostPromiseJob;
  }
  if (typeof batchScheduleFn !== "function") {
    throw new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);
  }
  return batchScheduleFn;
}
function getValidCacheKeyFn(options) {
  const cacheKeyFn = options && options.cacheKeyFn;
  if (cacheKeyFn === void 0) {
    return (key2) => key2;
  }
  if (typeof cacheKeyFn !== "function") {
    throw new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);
  }
  return cacheKeyFn;
}
function getValidCacheMap(options) {
  const shouldCache = !options || options.cache !== false;
  if (!shouldCache) {
    return null;
  }
  const cacheMap2 = options && options.cacheMap;
  if (cacheMap2 === void 0) {
    return /* @__PURE__ */ new Map();
  }
  if (cacheMap2 !== null) {
    const cacheFunctions = ["get", "set", "delete", "clear"];
    const missingFunctions = cacheFunctions.filter(
      (fnName) => cacheMap2 && typeof cacheMap2[fnName] !== "function"
    );
    if (missingFunctions.length !== 0) {
      throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
    }
  }
  return cacheMap2;
}
function getValidName(options) {
  if (options && options.name) {
    return options.name;
  }
  return null;
}
function isArrayLike(x) {
  return typeof x === "object" && x !== null && "length" in x && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
}

// node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num) {
  let bigNum = BigInt(num);
  const arr = [];
  let len = 0;
  if (bigNum === 0n) {
    return [0];
  }
  while (bigNum > 0) {
    arr[len] = Number(bigNum & 0x7fn);
    bigNum >>= 7n;
    if (bigNum > 0n) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0n;
  let shift = 0n;
  let len = 0;
  while (true) {
    if (len >= arr.length) {
      throw new Error("ULEB decode error: buffer overflow");
    }
    const byte = arr[len];
    len += 1;
    total += BigInt(byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7n;
  }
  if (total > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("ULEB decode error: value exceeds MAX_SAFE_INTEGER");
  }
  return {
    value: Number(total),
    length: len
  };
}

// node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    const value2 = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value2;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    const value2 = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value2;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    const value2 = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value2;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    const value1 = this.read32();
    const value2 = this.read32();
    const result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    const value1 = BigInt(this.read64());
    const value2 = BigInt(this.read64());
    const result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    const value1 = BigInt(this.read128());
    const value2 = BigInt(this.read128());
    const result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    const start = this.bytePosition + this.dataView.byteOffset;
    const value2 = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value2;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    const start = this.bytePosition + this.dataView.byteOffset;
    const buffer = new Uint8Array(this.dataView.buffer, start);
    const { value: value2, length } = ulebDecode(buffer);
    this.shift(length);
    return value2;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    const length = this.readULEB();
    const result = [];
    for (let i2 = 0; i2 < length; i2++) {
      result.push(cb(this, i2, length));
    }
    return result;
  }
};

// node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase58(data);
    case "base64":
      return toBase64(data);
    case "hex":
      return toHex(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    const char = str[i2];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(
        this.maxSize,
        Math.max(this.size + requiredSize, this.size + this.allocateSize)
      );
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value2) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value2));
    return this.shift(1);
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeBytes(bytes) {
    this.ensureSizeOrGrow(bytes.length);
    for (let i2 = 0; i2 < bytes.length; i2++) {
      this.dataView.setUint8(this.bytePosition + i2, bytes[i2]);
    }
    return this.shift(bytes.length);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value2) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value2), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value2) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value2), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value2) {
    toLittleEndian(BigInt(value2), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value2) {
    toLittleEndian(BigInt(value2), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value2) {
    toLittleEndian(BigInt(value2), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value2) {
    ulebEncode(value2).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector2, cb) {
    this.writeULEB(vector2.length);
    Array.from(vector2).forEach((el, i2) => cb(this, el, i2, vector2.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  // oxlint-disable-next-line require-yields
  *[Symbol.iterator]() {
    for (let i2 = 0; i2 < this.bytePosition; i2++) {
      yield this.dataView.getUint8(i2);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  const result = new Uint8Array(size);
  let i2 = 0;
  while (bigint2 > 0) {
    result[i2] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i2 += 1;
  }
  return result;
}

// node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class _BcsType2 {
  constructor(options) {
    __privateAdd(this, _write);
    __privateAdd(this, _serialize);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet(this, _write, options.write);
    __privateSet(this, _serialize, options.serialize ?? ((value2, options2) => {
      const writer = new BcsWriter({
        initialSize: this.serializedSize(value2) ?? void 0,
        ...options2
      });
      __privateGet(this, _write).call(this, value2, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value2, writer) {
    this.validate(value2);
    __privateGet(this, _write).call(this, value2, writer);
  }
  serialize(value2, options) {
    this.validate(value2);
    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value2, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  fromHex(hex2) {
    return this.parse(fromHex(hex2));
  }
  fromBase58(b64) {
    return this.parse(fromBase58(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase64(b64));
  }
  transform({
    name: name2,
    input,
    output,
    validate: validate2
  }) {
    return new _BcsType2({
      name: name2 ?? this.name,
      read: (reader) => output ? output(this.read(reader)) : this.read(reader),
      write: (value2, writer) => __privateGet(this, _write).call(this, input ? input(value2) : value2, writer),
      serializedSize: (value2) => this.serializedSize(input ? input(value2) : value2),
      serialize: (value2, options) => __privateGet(this, _serialize).call(this, input ? input(value2) : value2, options),
      validate: (value2) => {
        validate2?.(value2);
        this.validate(input ? input(value2) : value2);
      }
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(schema, bytes) {
    __privateAdd(this, _schema);
    __privateAdd(this, _bytes);
    __privateSet(this, _schema, schema);
    __privateSet(this, _bytes, bytes);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet(this, _bytes);
  }
  toHex() {
    return toHex(__privateGet(this, _bytes));
  }
  toBase64() {
    return toBase64(__privateGet(this, _bytes));
  }
  toBase58() {
    return toBase58(__privateGet(this, _bytes));
  }
  parse() {
    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](value2),
    validate: (value2) => {
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      options.validate?.(value2);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](BigInt(value2)),
    validate: (val) => {
      const value2 = BigInt(val);
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      options.validate?.(value2);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type2 = new BcsType({
    ...options,
    serialize,
    write: (value2, writer) => {
      for (const byte of type2.serialize(value2).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type2;
}
function stringLikeBcsType({
  toBytes: toBytes3,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex2, writer) => {
      const bytes = toBytes3(hex2);
      writer.writeULEB(bytes.length);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        writer.write8(bytes[i2]);
      }
    },
    serialize: (value2) => {
      const bytes = toBytes3(value2);
      const size = ulebEncode(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value2) => {
      if (typeof value2 !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value2}. Expected string`);
      }
      options.validate?.(value2);
    }
  });
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value2) => getType().serializedSize(value2),
    write: (value2, writer) => getType().write(value2, writer),
    serialize: (value2, options) => getType().serialize(value2, options).toBytes()
  });
}
var BcsStruct = class extends BcsType {
  constructor({ name: name2, fields, ...options }) {
    const canonicalOrder = Object.entries(fields);
    super({
      name: name2,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type2] of canonicalOrder) {
          const size = type2.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type2] of canonicalOrder) {
          result[field] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const [field, type2] of canonicalOrder) {
          type2.write(value2[field], writer);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
      }
    });
  }
};
var BcsEnum = class extends BcsType {
  constructor({ fields, ...options }) {
    const canonicalOrder = Object.entries(fields);
    super({
      read: (reader) => {
        const index = reader.readULEB();
        const enumEntry = canonicalOrder[index];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index} for enum ${options.name}`);
        }
        const [kind, type2] = enumEntry;
        return {
          [kind]: type2?.read(reader) ?? true,
          $kind: kind
        };
      },
      write: (value2, writer) => {
        const [name2, val] = Object.entries(value2).filter(
          ([name22]) => Object.hasOwn(fields, name22)
        )[0];
        for (let i2 = 0; i2 < canonicalOrder.length; i2++) {
          const [optionName, optionType] = canonicalOrder[i2];
          if (optionName === name2) {
            writer.writeULEB(i2);
            optionType?.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
        const keys = Object.keys(value2).filter(
          (k) => value2[k] !== void 0 && Object.hasOwn(fields, k)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${options.name}}`
          );
        }
        const [variant] = keys;
        if (!Object.hasOwn(fields, variant)) {
          throw new TypeError(`Invalid enum variant ${variant}`);
        }
      }
    });
  }
};
var BcsTuple = class extends BcsType {
  constructor({ fields, name: name2, ...options }) {
    super({
      name: name2 ?? `(${fields.map((t3) => t3.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i2 = 0; i2 < fields.length; i2++) {
          const size = fields[i2].serializedSize(values[i2]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const field of fields) {
          result.push(field.read(reader));
        }
        return result;
      },
      write: (value2, writer) => {
        for (let i2 = 0; i2 < fields.length; i2++) {
          fields[i2].write(value2[i2], writer);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (!Array.isArray(value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== fields.length) {
          throw new TypeError(`Expected array of length ${fields.length}, found ${value2.length}`);
        }
      }
    });
  }
};

// node_modules/@mysten/bcs/dist/esm/bcs.js
function fixedArray(size, type2, options) {
  return new BcsType({
    read: (reader) => {
      const result = new Array(size);
      for (let i2 = 0; i2 < size; i2++) {
        result[i2] = type2.read(reader);
      }
      return result;
    },
    write: (value2, writer) => {
      for (const item of value2) {
        type2.write(item, writer);
      }
    },
    ...options,
    name: options?.name ?? `${type2.name}[${size}]`,
    validate: (value2) => {
      options?.validate?.(value2);
      if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
        throw new TypeError(`Expected array, found ${typeof value2}`);
      }
      if (value2.length !== size) {
        throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
      }
    }
  });
}
function option(type2) {
  return bcs.enum(`Option<${type2.name}>`, {
    None: null,
    Some: type2
  }).transform({
    input: (value2) => {
      if (value2 == null) {
        return { None: true };
      }
      return { Some: value2 };
    },
    output: (value2) => {
      if (value2.$kind === "Some") {
        return value2.Some;
      }
      return null;
    }
  });
}
function vector(type2, options) {
  return new BcsType({
    read: (reader) => {
      const length = reader.readULEB();
      const result = new Array(length);
      for (let i2 = 0; i2 < length; i2++) {
        result[i2] = type2.read(reader);
      }
      return result;
    },
    write: (value2, writer) => {
      writer.writeULEB(value2.length);
      for (const item of value2) {
        type2.write(item, writer);
      }
    },
    ...options,
    name: options?.name ?? `vector<${type2.name}>`,
    validate: (value2) => {
      options?.validate?.(value2);
      if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
        throw new TypeError(`Expected array, found ${typeof value2}`);
      }
    }
  });
}
function map(keyType, valueType) {
  return bcs.vector(bcs.tuple([keyType, valueType])).transform({
    name: `Map<${keyType.name}, ${valueType.name}>`,
    input: (value2) => {
      return [...value2.entries()];
    },
    output: (value2) => {
      const result = /* @__PURE__ */ new Map();
      for (const [key2, val] of value2) {
        result.set(key2, val);
      }
      return result;
    }
  });
}
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options,
      name: options?.name ?? "u8"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options,
      name: options?.name ?? "u16"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options,
      name: options?.name ?? "u32"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options,
      name: options?.name ?? "u64"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options,
      name: options?.name ?? "u128"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options,
      name: options?.name ?? "u256"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value2, writer) => writer.write8(value2 ? 1 : 0),
      ...options,
      name: options?.name ?? "bool",
      validate: (value2) => {
        options?.validate?.(value2);
        if (typeof value2 !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      read: (reader) => reader.readULEB(),
      serialize: (value2) => {
        return Uint8Array.from(ulebEncode(value2));
      },
      ...options,
      name: options?.name ?? "uleb128"
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType({
      size,
      read: (reader) => reader.readBytes(size),
      write: (value2, writer) => {
        writer.writeBytes(new Uint8Array(value2));
      },
      ...options,
      name: options?.name ?? `bytes[${size}]`,
      validate: (value2) => {
        options?.validate?.(value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(options) {
    return new BcsType({
      read: (reader) => {
        const length = reader.readULEB();
        return reader.readBytes(length);
      },
      write: (value2, writer) => {
        const array2 = new Uint8Array(value2);
        writer.writeULEB(array2.length);
        writer.writeBytes(array2);
      },
      ...options,
      name: options?.name ?? "vector<u8>",
      serializedSize: (value2) => {
        const length = "length" in value2 ? value2.length : null;
        return length == null ? null : ulebEncode(length).length + length;
      },
      validate: (value2) => {
        options?.validate?.(value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      toBytes: (value2) => new TextEncoder().encode(value2),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options,
      name: options?.name ?? "string"
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray,
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option,
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector,
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(fields, options) {
    return new BcsTuple({
      fields,
      ...options
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name2, fields, options) {
    return new BcsStruct({
      name: name2,
      fields,
      ...options
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name2, fields, options) {
    return new BcsEnum({
      name: name2,
      fields,
      ...options
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map,
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};

// node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = /* @__PURE__ */ Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);

// node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = /* @__PURE__ */ Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = /* @__PURE__ */ new Uint32Array(32);
function G1b(a3, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a3], Ah = BBUF[2 * a3 + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a3] = Al, BBUF[2 * a3 + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a3, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a3], Ah = BBUF[2 * a3 + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a3] = Al, BBUF[2 * a3 + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key: key2, salt, personalization } = opts;
  if (key2 !== void 0 && (key2.length < 1 || key2.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { blockLen, buffer, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i2) => out32[i2] = swap8IfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.buffer.set(buffer);
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    to.outputLen = outputLen;
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key: key2, personalization, salt } = opts;
    let keyLength = 0;
    if (key2 !== void 0) {
      key2 = toBytes(key2);
      keyLength = key2.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes(salt);
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes(personalization);
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key2 !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key2);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i2) => BBUF[i2] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = BSIGMA;
    for (let i2 = 0; i2 < 12; i2++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2b(opts));

// node_modules/@noble/hashes/esm/blake2b.js
var blake2b2 = blake2b;

// node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var MAX_SUI_NS_NAME_LENGTH = 235;
function isValidSuiNSName(name2) {
  if (name2.length > MAX_SUI_NS_NAME_LENGTH) {
    return false;
  }
  if (name2.includes("@")) {
    return SUI_NS_NAME_REGEX.test(name2);
  }
  return SUI_NS_DOMAIN_REGEX.test(name2);
}
function normalizeSuiNSName(name2, format = "at") {
  const lowerCase = name2.toLowerCase();
  let parts;
  if (lowerCase.includes("@")) {
    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name2}`);
    }
    const [labels, domain] = lowerCase.split("@");
    parts = [...labels ? labels.split(".") : [], domain];
  } else {
    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name2}`);
    }
    parts = lowerCase.split(".").slice(0, -1);
  }
  if (format === "dot") {
    return `${parts.join(".")}.sui`;
  }
  return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

// node_modules/@mysten/sui/dist/esm/utils/move-registry.js
var NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var VERSION_REGEX = /^\d+$/;
var MAX_APP_SIZE = 64;
var NAME_SEPARATOR = "/";
var isValidNamedPackage = (name2) => {
  const parts = name2.split(NAME_SEPARATOR);
  if (parts.length < 2 || parts.length > 3)
    return false;
  const [org, app, version] = parts;
  if (version !== void 0 && !VERSION_REGEX.test(version))
    return false;
  if (!isValidSuiNSName(org))
    return false;
  return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;
};
var isValidNamedType = (type2) => {
  const splitType = type2.split(/::|<|>|,/);
  for (const t3 of splitType) {
    if (t3.includes(NAME_SEPARATOR) && !isValidNamedPackage(t3))
      return false;
  }
  return true;
};

// node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value2) {
  try {
    const buffer = fromBase58(value2);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value2) {
  return isHex(value2) && getHexByteLength(value2) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value2) {
  return isValidSuiAddress(value2);
}
function parseTypeTag(type2) {
  if (!type2.includes("::"))
    return type2;
  return parseStructTag(type2);
}
function parseStructTag(type2) {
  const [address, module2] = type2.split("::");
  const isMvrPackage = isValidNamedPackage(address);
  const rest = type2.slice(address.length + module2.length + 4);
  const name2 = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: isMvrPackage ? address : normalizeSuiAddress(address),
    module: module2,
    name: name2,
    typeParams
  };
}
function normalizeStructTag(type2) {
  const { address, module: module2, name: name2, typeParams } = typeof type2 === "string" ? parseStructTag(type2) : type2;
  const formattedTypeParams = typeParams?.length > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module2}::${name2}${formattedTypeParams}`;
}
function normalizeSuiAddress(value2, forceAdd0x = false) {
  let address = value2.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value2, forceAdd0x = false) {
  return normalizeSuiAddress(value2, forceAdd0x);
}
function isHex(value2) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value2) && value2.length % 2 === 0;
}
function getHexByteLength(value2) {
  return /^(0x|0X)/.test(value2) ? (value2.length - 2) / 2 : value2.length / 2;
}

// node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag2) {
    if ("bool" in tag2) {
      return "bool";
    }
    if ("u8" in tag2) {
      return "u8";
    }
    if ("u16" in tag2) {
      return "u16";
    }
    if ("u32" in tag2) {
      return "u32";
    }
    if ("u64" in tag2) {
      return "u64";
    }
    if ("u128" in tag2) {
      return "u128";
    }
    if ("u256" in tag2) {
      return "u256";
    }
    if ("address" in tag2) {
      return "address";
    }
    if ("signer" in tag2) {
      return "signer";
    }
    if ("vector" in tag2) {
      return `vector<${TypeTagSerializer.tagToString(tag2.vector)}>`;
    }
    if ("struct" in tag2) {
      const struct = tag2.struct;
      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type2) {
  return bcs.enum("Option", {
    None: null,
    Some: type2
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex(val);
    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.byteVector().transform({
  name: "ObjectDigest",
  input: (value2) => fromBase58(value2),
  output: (value2) => toBase58(new Uint8Array(value2)),
  validate: (value2) => {
    if (fromBase58(value2).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef,
  SharedObject: SharedObjectRef,
  Receiving: SuiObjectRef
});
var Owner = bcs.enum("Owner", {
  AddressOwner: Address,
  ObjectOwner: Address,
  Shared: bcs.struct("Shared", {
    initialSharedVersion: bcs.u64()
  }),
  Immutable: null,
  ConsensusAddressOwner: bcs.struct("ConsensusAddressOwner", {
    owner: Address,
    startVersion: bcs.u64()
  })
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.struct("Pure", {
    bytes: bcs.byteVector().transform({
      input: (val) => typeof val === "string" ? fromBase64(val) : val,
      output: (val) => toBase64(new Uint8Array(val))
    })
  }),
  Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument = bcs.enum("Argument", {
  GasCoin: null,
  Input: bcs.u16(),
  Result: bcs.u16(),
  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  typeArguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
});
var Command = bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs.struct("TransferObjects", {
    objects: bcs.vector(Argument),
    address: Argument
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs.struct("SplitCoins", {
    coin: Argument,
    amounts: bcs.vector(Argument)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs.struct("MergeCoins", {
    destination: Argument,
    sources: bcs.vector(Argument)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs.struct("Publish", {
    modules: bcs.vector(
      bcs.byteVector().transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs.struct("MakeMoveVec", {
    type: optionEnum(TypeTag).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => val.Some ?? null
    }),
    elements: bcs.vector(Argument)
  }),
  Upgrade: bcs.struct("Upgrade", {
    modules: bcs.vector(
      bcs.byteVector().transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address),
    package: Address,
    ticket: Argument
  })
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  commands: bcs.vector(Command)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
function IntentMessage(T) {
  return bcs.struct(`IntentMessage<${T.name}>`, {
    intent: Intent,
    value: T
  });
}
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.bytes(64),
  Secp256k1: bcs.bytes(64),
  Secp256r1: bcs.bytes(64),
  ZkLogin: bcs.byteVector(),
  Passkey: bcs.byteVector()
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.bytes(32),
  Secp256k1: bcs.bytes(33),
  Secp256r1: bcs.bytes(33),
  ZkLogin: bcs.byteVector(),
  Passkey: bcs.bytes(33)
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.byteVector().transform({
  input: (val) => typeof val === "string" ? fromBase64(val) : val,
  output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});
var PasskeyAuthenticator = bcs.struct("PasskeyAuthenticator", {
  authenticatorData: bcs.byteVector(),
  clientDataJson: bcs.string(),
  userSignature: bcs.byteVector()
});

// node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
  NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.byteVector() }),
  UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
  PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
    packageId: Address,
    ticketId: Address
  })
});
var ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
  module: ModuleId,
  function: bcs.u16(),
  instruction: bcs.u16(),
  functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
  SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  MovePackageTooBig: bcs.struct("MovePackageTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs.option(MoveLocation),
  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs.struct("CommandArgumentError", {
    argIdx: bcs.u16(),
    kind: CommandArgumentError
  }),
  TypeArgumentError: bcs.struct("TypeArgumentError", {
    argumentIdx: bcs.u16(),
    kind: TypeArgumentError
  }),
  UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", {
    idx: bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs.struct("EffectsTooLarge", { currentSize: bcs.u64(), maxSize: bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
  WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
    currentSize: bcs.u64(),
    maxSize: bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: bcs.vector(Address)
    }
  ),
  AddressDeniedForCoin: bcs.struct("AddressDeniedForCoin", {
    address: Address,
    coinType: bcs.string()
  }),
  CoinTypeGlobalPause: bcs.struct("CoinTypeGlobalPause", { coinType: bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs.struct("ExecutionFailed", {
    error: ExecutionFailureStatus,
    command: bcs.option(bcs.u64())
  })
});
var GasCostSummary = bcs.struct("GasCostSummary", {
  computationCost: bcs.u64(),
  storageCost: bcs.u64(),
  storageRebate: bcs.u64(),
  nonRefundableStorageFee: bcs.u64()
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
  sharedObjects: bcs.vector(SuiObjectRef),
  transactionDigest: ObjectDigest,
  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  deleted: bcs.vector(SuiObjectRef),
  unwrappedThenDeleted: bcs.vector(SuiObjectRef),
  wrapped: bcs.vector(SuiObjectRef),
  gasObject: bcs.tuple([SuiObjectRef, Owner]),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
  PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
  inputState: ObjectIn,
  outputState: ObjectOut,
  idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest,
  // TODO: these have been renamed to MutateConsensusStreamEnded and ReadConsensusStreamEnded
  MutateDeleted: bcs.u64(),
  ReadDeleted: bcs.u64(),
  Cancelled: bcs.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  transactionDigest: ObjectDigest,
  gasObjectIndex: bcs.option(bcs.u32()),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest),
  lamportVersion: bcs.u64(),
  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
  auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
  V1: TransactionEffectsV1,
  V2: TransactionEffectsV2
});

// node_modules/@mysten/sui/dist/esm/bcs/pure.js
function pureBcsSchemaFromTypeName(name2) {
  switch (name2) {
    case "u8":
      return bcs.u8();
    case "u16":
      return bcs.u16();
    case "u32":
      return bcs.u32();
    case "u64":
      return bcs.u64();
    case "u128":
      return bcs.u128();
    case "u256":
      return bcs.u256();
    case "bool":
      return bcs.bool();
    case "string":
      return bcs.string();
    case "id":
    case "address":
      return Address;
  }
  const generic = name2.match(/^(vector|option)<(.+)>$/);
  if (generic) {
    const [kind, inner] = generic.slice(1);
    if (kind === "vector") {
      return bcs.vector(pureBcsSchemaFromTypeName(inner));
    } else {
      return bcs.option(pureBcsSchemaFromTypeName(inner));
    }
  }
  throw new Error(`Invalid Pure type name: ${name2}`);
}

// node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  AppId,
  Argument,
  CallArg,
  Command,
  CompressedSignature,
  GasData,
  Intent,
  IntentMessage,
  IntentScope,
  IntentVersion,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  Owner,
  PasskeyAuthenticator,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  TransactionData,
  TransactionDataV1,
  TransactionEffects,
  TransactionExpiration,
  TransactionKind,
  TypeTag
};

// node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
  return suiBcs.IntentMessage(suiBcs.bytes(message.length)).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33,
  Passkey: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key2 = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key2.length > blockLen ? hash.create().update(key2).digest() : key2);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key2, message) => new HMAC(hash, key2).update(message).digest();
hmac.create = (hash, key2) => new HMAC(hash, key2);

// node_modules/@noble/hashes/esm/sha256.js
var sha2562 = sha256;

// node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a3, b) {
  if (a3 === b)
    return true;
  if (a3.length !== b.length) {
    return false;
  }
  for (let i2 = 0; i2 < a3.length; i2++) {
    if (a3[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toBase64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b2(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.byteVector().serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return this.toSuiAddress() === address;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b2(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
    );
  }
};
function parseSerializedKeypairSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value2) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value2;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "description",
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: [
    "description",
    "variable",
    "type",
    "defaultValue",
    "directives"
  ],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "description",
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"],
  TypeCoordinate: ["name"],
  MemberCoordinate: ["name", "memberName"],
  ArgumentCoordinate: ["name", "fieldName", "argumentName"],
  DirectiveCoordinate: ["name"],
  DirectiveArgumentCoordinate: ["name", "argumentName"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  Kind2["TYPE_COORDINATE"] = "TypeCoordinate";
  Kind2["MEMBER_COORDINATE"] = "MemberCoordinate";
  Kind2["ARGUMENT_COORDINATE"] = "ArgumentCoordinate";
  Kind2["DIRECTIVE_COORDINATE"] = "DirectiveCoordinate";
  Kind2["DIRECTIVE_ARGUMENT_COORDINATE"] = "DirectiveArgumentCoordinate";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}

// node_modules/graphql/language/blockString.mjs
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries = Object.entries(object2);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries.map(
    ([key2, value2]) => key2 + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array2[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag2 = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag2 === "Object" && typeof object2.constructor === "function") {
    const name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag2;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key2 = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key2 = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = { ...node };
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key2 = inArray ? index : keys[index];
      node = parent[key2];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key2);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key2, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key2, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key2, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = hasMultilineItems(node.variableDefinitions) ? wrap("(\n", join2(node.variableDefinitions, "\n"), "\n)") : wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = wrap("", node.description, "\n") + join2(
        [
          node.operation,
          join2([node.name, varDefs]),
          join2(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2, description }) => wrap("", description, "\n") + variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join2(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives: directives2 }) => "..." + name2 + wrap(" ", join2(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet: selectionSet2 }) => join2(
      [
        "...",
        wrap("on ", typeCondition),
        join2(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({
      name: name2,
      typeCondition,
      variableDefinitions: variableDefinitions2,
      directives: directives2,
      selectionSet: selectionSet2,
      description
    }) => wrap("", description, "\n") + // Note: fragment variable definitions are experimental and may be changed
    // or removed in the future.
    `fragment ${name2}${wrap("(", join2(variableDefinitions2, ", "), ")")} on ${typeCondition} ${wrap("", join2(directives2, " "), " ")}` + selectionSet2
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values }) => "[" + join2(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join2(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join2(["schema", join2(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join2(["scalar", name2, join2(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join2(
      [
        "type",
        name2,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives: directives2 }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type2 + wrap(" ", join2(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join2(
      [name2 + ": " + type2, wrap("= ", defaultValue), join2(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join2(
      [
        "interface",
        name2,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, types }) => wrap("", description, "\n") + join2(
      ["union", name2, join2(directives2, " "), wrap("= ", join2(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, values }) => wrap("", description, "\n") + join2(["enum", name2, join2(directives2, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join2([name2, join2(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, fields }) => wrap("", description, "\n") + join2(["input", name2, join2(directives2, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join2(
      ["extend schema", join2(directives2, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives: directives2 }) => join2(["extend scalar", name2, join2(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join2(
      [
        "extend type",
        name2,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join2(
      [
        "extend interface",
        name2,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives: directives2, types }) => join2(
      [
        "extend union",
        name2,
        join2(directives2, " "),
        wrap("= ", join2(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives: directives2, values }) => join2(["extend enum", name2, join2(directives2, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives: directives2, fields }) => join2(["extend input", name2, join2(directives2, " "), block(fields)], " ")
  },
  // Schema Coordinates
  TypeCoordinate: {
    leave: ({ name: name2 }) => name2
  },
  MemberCoordinate: {
    leave: ({ name: name2, memberName }) => join2([name2, wrap(".", memberName)])
  },
  ArgumentCoordinate: {
    leave: ({ name: name2, fieldName, argumentName }) => join2([name2, wrap(".", fieldName), wrap("(", argumentName, ":)")])
  },
  DirectiveCoordinate: {
    leave: ({ name: name2 }) => join2(["@", name2])
  },
  DirectiveArgumentCoordinate: {
    leave: ({ name: name2, argumentName }) => join2(["@", name2, wrap("(", argumentName, ":)")])
  }
};
function join2(maybeArray, separator2 = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator2)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap("{\n", indent(join2(array2, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value2) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet2 = (obj, member, value2, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _prefix;
var _cache;
var _ClientCache = class _ClientCache2 {
  constructor({ prefix, cache } = {}) {
    __privateAdd2(this, _prefix);
    __privateAdd2(this, _cache);
    __privateSet2(this, _prefix, prefix ?? []);
    __privateSet2(this, _cache, cache ?? /* @__PURE__ */ new Map());
  }
  read(key2, load) {
    const cacheKey = [__privateGet2(this, _prefix), ...key2].join(":");
    if (__privateGet2(this, _cache).has(cacheKey)) {
      return __privateGet2(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet2(this, _cache).set(cacheKey, result);
    if (typeof result === "object" && result !== null && "then" in result) {
      return Promise.resolve(result).then((v) => {
        __privateGet2(this, _cache).set(cacheKey, v);
        return v;
      }).catch((err) => {
        __privateGet2(this, _cache).delete(cacheKey);
        throw err;
      });
    }
    return result;
  }
  readSync(key2, load) {
    const cacheKey = [__privateGet2(this, _prefix), ...key2].join(":");
    if (__privateGet2(this, _cache).has(cacheKey)) {
      return __privateGet2(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet2(this, _cache).set(cacheKey, result);
    return result;
  }
  clear(prefix) {
    const prefixKey = [...__privateGet2(this, _prefix), ...prefix ?? []].join(":");
    if (!prefixKey) {
      __privateGet2(this, _cache).clear();
      return;
    }
    for (const key2 of __privateGet2(this, _cache).keys()) {
      if (key2.startsWith(prefixKey)) {
        __privateGet2(this, _cache).delete(key2);
      }
    }
  }
  scope(prefix) {
    return new _ClientCache2({
      prefix: [...__privateGet2(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],
      cache: __privateGet2(this, _cache)
    });
  }
};
_prefix = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
var ClientCache = _ClientCache;

// node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient = class {
  constructor({
    network,
    base,
    cache = base?.cache ?? new ClientCache()
  }) {
    this.network = network;
    this.base = base ?? this;
    this.cache = cache;
  }
  $extend(...registrations) {
    return Object.create(
      this,
      Object.fromEntries(
        registrations.map((registration) => {
          return [registration.name, { value: registration.register(this) }];
        })
      )
    );
  }
};

// node_modules/@mysten/sui/dist/esm/utils/dynamic-fields.js
function deriveDynamicFieldID(parentId, typeTag, key2) {
  const address = suiBcs.Address.serialize(parentId).toBytes();
  const tag2 = suiBcs.TypeTag.serialize(typeTag).toBytes();
  const keyLength = suiBcs.u64().serialize(key2.length).toBytes();
  const hash = blake2b2.create({
    dkLen: 32
  });
  hash.update(new Uint8Array([240]));
  hash.update(address);
  hash.update(keyLength);
  hash.update(key2);
  hash.update(tag2);
  return `0x${toHex(hash.digest().slice(0, 32))}`;
}

// node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.44.0";
var TARGETED_RPC_VERSION = "1.61.0";

// node_modules/@mysten/sui/dist/esm/experimental/mvr.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value2) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet3 = (obj, member, value2, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
var _cache2;
var _url;
var _pageSize;
var _overrides;
var _MvrClient_instances;
var mvrPackageDataLoader_get;
var mvrTypeDataLoader_get;
var resolvePackages_fn;
var resolveTypes_fn;
var fetch_fn;
var NAME_SEPARATOR2 = "/";
var MVR_API_HEADER = {
  "Mvr-Source": `@mysten/sui@${PACKAGE_VERSION}`
};
var MvrClient = class {
  constructor({ cache, url, pageSize = 50, overrides }) {
    __privateAdd3(this, _MvrClient_instances);
    __privateAdd3(this, _cache2);
    __privateAdd3(this, _url);
    __privateAdd3(this, _pageSize);
    __privateAdd3(this, _overrides);
    __privateSet3(this, _cache2, cache);
    __privateSet3(this, _url, url);
    __privateSet3(this, _pageSize, pageSize);
    __privateSet3(this, _overrides, {
      packages: overrides?.packages,
      types: overrides?.types
    });
    validateOverrides(__privateGet3(this, _overrides));
  }
  async resolvePackage({
    package: name2
  }) {
    if (!hasMvrName(name2)) {
      return {
        package: name2
      };
    }
    const resolved = await __privateGet3(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name2);
    return {
      package: resolved
    };
  }
  async resolveType({
    type: type2
  }) {
    if (!hasMvrName(type2)) {
      return {
        type: type2
      };
    }
    const mvrTypes = [...extractMvrTypes(type2)];
    const resolvedTypes = await __privateGet3(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);
    const typeMap = {};
    for (let i2 = 0; i2 < mvrTypes.length; i2++) {
      const resolvedType = resolvedTypes[i2];
      if (resolvedType instanceof Error) {
        throw resolvedType;
      }
      typeMap[mvrTypes[i2]] = resolvedType;
    }
    return {
      type: replaceMvrNames(type2, typeMap)
    };
  }
  async resolve({
    types = [],
    packages = []
  }) {
    const mvrTypes = /* @__PURE__ */ new Set();
    for (const type2 of types ?? []) {
      extractMvrTypes(type2, mvrTypes);
    }
    const typesArray = [...mvrTypes];
    const [resolvedTypes, resolvedPackages] = await Promise.all([
      typesArray.length > 0 ? __privateGet3(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [],
      packages.length > 0 ? __privateGet3(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []
    ]);
    const typeMap = {
      ...__privateGet3(this, _overrides)?.types
    };
    for (const [i2, type2] of typesArray.entries()) {
      const resolvedType = resolvedTypes[i2];
      if (resolvedType instanceof Error) {
        throw resolvedType;
      }
      typeMap[type2] = resolvedType;
    }
    const replacedTypes = {};
    for (const type2 of types ?? []) {
      const resolvedType = replaceMvrNames(type2, typeMap);
      replacedTypes[type2] = {
        type: resolvedType
      };
    }
    const replacedPackages = {};
    for (const [i2, pkg] of (packages ?? []).entries()) {
      const resolvedPkg = __privateGet3(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i2];
      if (resolvedPkg instanceof Error) {
        throw resolvedPkg;
      }
      replacedPackages[pkg] = {
        package: resolvedPkg
      };
    }
    return {
      types: replacedTypes,
      packages: replacedPackages
    };
  }
};
_cache2 = /* @__PURE__ */ new WeakMap();
_url = /* @__PURE__ */ new WeakMap();
_pageSize = /* @__PURE__ */ new WeakMap();
_overrides = /* @__PURE__ */ new WeakMap();
_MvrClient_instances = /* @__PURE__ */ new WeakSet();
mvrPackageDataLoader_get = function() {
  return __privateGet3(this, _cache2).readSync(["#mvrPackageDataLoader", __privateGet3(this, _url) ?? ""], () => {
    const loader = new DataLoader(async (packages) => {
      if (!__privateGet3(this, _url)) {
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${packages.join(", ")})`
        );
      }
      const resolved = await __privateMethod(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);
      return packages.map(
        (pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`)
      );
    });
    const overrides = __privateGet3(this, _overrides)?.packages;
    if (overrides) {
      for (const [pkg, id] of Object.entries(overrides)) {
        loader.prime(pkg, id);
      }
    }
    return loader;
  });
};
mvrTypeDataLoader_get = function() {
  return __privateGet3(this, _cache2).readSync(["#mvrTypeDataLoader", __privateGet3(this, _url) ?? ""], () => {
    const loader = new DataLoader(async (types) => {
      if (!__privateGet3(this, _url)) {
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${types.join(", ")})`
        );
      }
      const resolved = await __privateMethod(this, _MvrClient_instances, resolveTypes_fn).call(this, types);
      return types.map((type2) => resolved[type2] ?? new Error(`Failed to resolve type: ${type2}`));
    });
    const overrides = __privateGet3(this, _overrides)?.types;
    if (overrides) {
      for (const [type2, id] of Object.entries(overrides)) {
        loader.prime(type2, id);
      }
    }
    return loader;
  });
};
resolvePackages_fn = async function(packages) {
  if (packages.length === 0)
    return {};
  const batches = chunk(packages, __privateGet3(this, _pageSize));
  const results = {};
  await Promise.all(
    batches.map(async (batch) => {
      const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, "/v1/resolution/bulk", {
        names: batch
      });
      if (!data?.resolution)
        return;
      for (const pkg of Object.keys(data?.resolution)) {
        const pkgData = data.resolution[pkg]?.package_id;
        if (!pkgData)
          continue;
        results[pkg] = pkgData;
      }
    })
  );
  return results;
};
resolveTypes_fn = async function(types) {
  if (types.length === 0)
    return {};
  const batches = chunk(types, __privateGet3(this, _pageSize));
  const results = {};
  await Promise.all(
    batches.map(async (batch) => {
      const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, "/v1/struct-definition/bulk", {
        types: batch
      });
      if (!data?.resolution)
        return;
      for (const type2 of Object.keys(data?.resolution)) {
        const typeData = data.resolution[type2]?.type_tag;
        if (!typeData)
          continue;
        results[type2] = typeData;
      }
    })
  );
  return results;
};
fetch_fn = async function(url, body) {
  if (!__privateGet3(this, _url)) {
    throw new Error("MVR Api URL is not set for the current client");
  }
  const response = await fetch(`${__privateGet3(this, _url)}${url}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...MVR_API_HEADER
    },
    body: JSON.stringify(body)
  });
  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({}));
    throw new Error(`Failed to resolve types: ${errorBody?.message}`);
  }
  return response.json();
};
function validateOverrides(overrides) {
  if (overrides?.packages) {
    for (const [pkg, id] of Object.entries(overrides.packages)) {
      if (!isValidNamedPackage(pkg)) {
        throw new Error(`Invalid package name: ${pkg}`);
      }
      if (!isValidSuiAddress(normalizeSuiAddress(id))) {
        throw new Error(`Invalid package ID: ${id}`);
      }
    }
  }
  if (overrides?.types) {
    for (const [type2, val] of Object.entries(overrides.types)) {
      if (parseStructTag(type2).typeParams.length > 0) {
        throw new Error(
          "Type overrides must be first-level only. If you want to supply generic types, just pass each type individually."
        );
      }
      const parsedValue = parseStructTag(val);
      if (!isValidSuiAddress(parsedValue.address)) {
        throw new Error(`Invalid type: ${val}`);
      }
    }
  }
}
function extractMvrTypes(type2, types = /* @__PURE__ */ new Set()) {
  if (typeof type2 === "string" && !hasMvrName(type2))
    return types;
  const tag2 = isStructTag(type2) ? type2 : parseStructTag(type2);
  if (hasMvrName(tag2.address))
    types.add(`${tag2.address}::${tag2.module}::${tag2.name}`);
  for (const param of tag2.typeParams) {
    extractMvrTypes(param, types);
  }
  return types;
}
function replaceMvrNames(tag2, typeCache) {
  const type2 = isStructTag(tag2) ? tag2 : parseStructTag(tag2);
  const typeTag = `${type2.address}::${type2.module}::${type2.name}`;
  const cacheHit = typeCache[typeTag];
  return normalizeStructTag({
    ...type2,
    address: cacheHit ? cacheHit.split("::")[0] : type2.address,
    typeParams: type2.typeParams.map((param) => replaceMvrNames(param, typeCache))
  });
}
function hasMvrName(nameOrType) {
  return nameOrType.includes(NAME_SEPARATOR2) || nameOrType.includes("@") || nameOrType.includes(".sui");
}
function isStructTag(type2) {
  return typeof type2 === "object" && "address" in type2 && "module" in type2 && "name" in type2 && "typeParams" in type2;
}
function findNamesInTransaction(builder) {
  const packages = /* @__PURE__ */ new Set();
  const types = /* @__PURE__ */ new Set();
  for (const command of builder.commands) {
    switch (command.$kind) {
      case "MakeMoveVec":
        if (command.MakeMoveVec.type) {
          getNamesFromTypeList([command.MakeMoveVec.type]).forEach((type2) => {
            types.add(type2);
          });
        }
        break;
      case "MoveCall":
        const moveCall = command.MoveCall;
        const pkg = moveCall.package.split("::")[0];
        if (hasMvrName(pkg)) {
          if (!isValidNamedPackage(pkg))
            throw new Error(`Invalid package name: ${pkg}`);
          packages.add(pkg);
        }
        getNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type2) => {
          types.add(type2);
        });
        break;
      default:
        break;
    }
  }
  return {
    packages: [...packages],
    types: [...types]
  };
}
function replaceNames(builder, resolved) {
  for (const command of builder.commands) {
    if (command.MakeMoveVec?.type) {
      if (!hasMvrName(command.MakeMoveVec.type))
        continue;
      if (!resolved.types[command.MakeMoveVec.type])
        throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);
      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;
    }
    const tx = command.MoveCall;
    if (!tx)
      continue;
    const nameParts = tx.package.split("::");
    const name2 = nameParts[0];
    if (hasMvrName(name2) && !resolved.packages[name2])
      throw new Error(`No address found for package: ${name2}`);
    if (hasMvrName(name2)) {
      nameParts[0] = resolved.packages[name2].package;
      tx.package = nameParts.join("::");
    }
    const types = tx.typeArguments;
    if (!types)
      continue;
    for (let i2 = 0; i2 < types.length; i2++) {
      if (!hasMvrName(types[i2]))
        continue;
      if (!resolved.types[types[i2]])
        throw new Error(`No resolution found for type: ${types[i2]}`);
      types[i2] = resolved.types[types[i2]].type;
    }
    tx.typeArguments = types;
  }
}
function getNamesFromTypeList(types) {
  const names = /* @__PURE__ */ new Set();
  for (const type2 of types) {
    if (hasMvrName(type2)) {
      if (!isValidNamedType(type2))
        throw new Error(`Invalid type with names: ${type2}`);
      names.add(type2);
    }
  }
  return names;
}

// node_modules/@mysten/sui/dist/esm/experimental/core.js
var DEFAULT_MVR_URLS = {
  mainnet: "https://mainnet.mvr.mystenlabs.com",
  testnet: "https://testnet.mvr.mystenlabs.com"
};
var Experimental_CoreClient = class extends Experimental_BaseClient {
  constructor(options) {
    super(options);
    this.core = this;
    this.mvr = new MvrClient({
      cache: this.cache.scope("core.mvr"),
      url: options.mvr?.url ?? DEFAULT_MVR_URLS[this.network],
      pageSize: options.mvr?.pageSize,
      overrides: options.mvr?.overrides
    });
  }
  async getObject(options) {
    const { objectId } = options;
    const {
      objects: [result]
    } = await this.getObjects({ objectIds: [objectId], signal: options.signal });
    if (result instanceof Error) {
      throw result;
    }
    return { object: result };
  }
  async getDynamicField(options) {
    const normalizedNameType = TypeTagSerializer.parseFromStr(
      (await this.core.mvr.resolveType({
        type: options.name.type
      })).type
    );
    const fieldId = deriveDynamicFieldID(options.parentId, normalizedNameType, options.name.bcs);
    const {
      objects: [fieldObject]
    } = await this.getObjects({
      objectIds: [fieldId],
      signal: options.signal
    });
    if (fieldObject instanceof Error) {
      throw fieldObject;
    }
    const fieldType = parseStructTag(fieldObject.type);
    const content = await fieldObject.content;
    return {
      dynamicField: {
        id: fieldObject.id,
        digest: fieldObject.digest,
        version: fieldObject.version,
        type: fieldObject.type,
        previousTransaction: fieldObject.previousTransaction,
        name: {
          type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),
          bcs: options.name.bcs
        },
        value: {
          type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),
          bcs: content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    ...input
  }) {
    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
    const abortPromise = new Promise((_, reject) => {
      abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
    });
    abortPromise.catch(() => {
    });
    while (true) {
      abortSignal.throwIfAborted();
      try {
        return await this.getTransaction({
          ...input,
          signal: abortSignal
        });
      } catch {
        await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
      }
    }
  }
};

// node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
  const type2 = typeof input;
  if (type2 === "string") {
    return `"${input}"`;
  }
  if (type2 === "number" || type2 === "bigint" || type2 === "boolean") {
    return `${input}`;
  }
  if (type2 === "object" || type2 === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type2;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = other?.message ?? // @ts-expect-error
  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _isValidObjectKey(object2, key2) {
  return Object.hasOwn(object2, key2) && key2 !== "__proto__" && key2 !== "prototype" && key2 !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The error issues.
     */
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
function check(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}
function integer(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "integer", dataset, config2);
      }
      return dataset;
    }
  };
}
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;
}
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < input.length; key2++) {
          const value2 = input[key2];
          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function bigint(message) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "bigint") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter,
    _run(dataset, config2) {
      return this.getter(dataset.value)._run(dataset, config2);
    }
  };
}
function literal(literal_, message) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message,
    _run(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nullable(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: `${wrapped.expects} | null`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === null) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function nullish(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${wrapped.expects} | null | undefined`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key2 in this.entries) {
          const value2 = input[key2];
          const valueDataset = this.entries[key2]._run(
            { typed: false, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key: key2,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key2 in input) {
            dataset.value[key2] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function record(key2, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key: key2,
    value: value2,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            const entryValue = input[entryKey];
            const keyDataset = this.key._run(
              { typed: false, value: entryKey },
              config2
            );
            if (keyDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues) {
                issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            const valueDataset = this.value._run(
              { typed: false, value: entryValue },
              config2
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function tuple(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key2 = 0; key2 < this.items.length; key2++) {
          const value2 = input[key2];
          const itemDataset = this.items[key2]._run(
            { typed: false, value: value2 },
            config2
          );
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key: key2,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(options.map((option2) => option2.expects))].join(" | ") || "never",
    async: false,
    options,
    message,
    _run(dataset, config2) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema._run(
          { typed: false, value: dataset.value },
          config2
        );
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function parse2(schema, input, config2) {
  const dataset = schema._run(
    { typed: false, value: input },
    getGlobalConfig(config2)
  );
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    _run(dataset, config2) {
      for (let index = 0; index < pipe2.length; index++) {
        if (dataset.issues && (pipe2[index].kind === "schema" || pipe2[index].kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
          dataset = pipe2[index]._run(dataset, config2);
        }
      }
      return dataset;
    }
  };
}

// node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
  const unionOptions = Object.entries(options).map(([key2, value2]) => object({ [key2]: value2 }));
  return pipe(
    union(unionOptions),
    transform((value2) => ({
      ...value2,
      $kind: Object.keys(value2)[0]
    }))
  );
}
var SuiAddress = pipe(
  string(),
  transform((value2) => normalizeSuiAddress(value2)),
  check(isValidSuiAddress)
);
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(
  union([string(), pipe(number(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRefSchema = object({
  objectId: SuiAddress,
  version: JsonU64,
  digest: string()
});
var ArgumentSchema = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number(), integer()) }),
    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
  ]),
  transform((value2) => ({
    ...value2,
    $kind: Object.keys(value2)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasDataSchema = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRefSchema))
});
var StructTagSchema = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBodySchema = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema))
    })
  }),
  object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignatureSchema = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBodySchema
});
var ProgrammableMoveCallSchema = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(ArgumentSchema),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema)))
});
var $Intent = object({
  name: string(),
  inputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),
  data: record(string(), unknown())
});
var CommandSchema = safeEnum({
  MoveCall: ProgrammableMoveCallSchema,
  TransferObjects: object({
    objects: array(ArgumentSchema),
    address: ArgumentSchema
  }),
  SplitCoins: object({
    coin: ArgumentSchema,
    amounts: array(ArgumentSchema)
  }),
  MergeCoins: object({
    destination: ArgumentSchema,
    sources: array(ArgumentSchema)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(ArgumentSchema)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: ArgumentSchema
  }),
  $Intent
});
var ObjectArgSchema = safeEnum({
  ImmOrOwnedObject: ObjectRefSchema,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRefSchema
});
var CallArgSchema = safeEnum({
  Object: ObjectArgSchema,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64)),
    mutable: optional(nullable(boolean()))
  })
});
var NormalizedCallArg = safeEnum({
  Object: ObjectArgSchema,
  Pure: object({
    bytes: BCSBytes
  })
});
var TransactionExpiration2 = safeEnum({
  None: literal(true),
  Epoch: JsonU64
});
var TransactionDataSchema = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration2),
  gasData: GasDataSchema,
  inputs: array(CallArgSchema),
  commands: array(CommandSchema)
});

// node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number(), integer()), string(), bigint()])
});
var ObjectArg2 = safeEnum({
  ImmOrOwned: ObjectRef,
  Shared: object({
    objectId: ObjectID,
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var NormalizedCallArg2 = safeEnum({
  Object: ObjectArg2,
  Pure: array(pipe(number(), integer()))
});
var TransactionInput = union([
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration3 = union([
  object({ Epoch: pipe(number(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint = pipe(
  union([number(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val))
      return false;
    try {
      BigInt(val);
      return true;
    } catch {
      return false;
    }
  })
);
var TypeTag2 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag2) }),
  object({ struct: lazy(() => StructTag2) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag2 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag2)
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(ObjectRef)),
  owner: optional(string())
});
var TransactionArgumentTypes = [
  TransactionInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number(), integer()),
    resultIndex: pipe(number(), integer())
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag2 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var SerializedTransactionDataV1 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration3),
  gasConfig: GasConfig,
  inputs: array(TransactionInput),
  transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
  const inputs = transactionData.inputs.map(
    (input, index) => {
      if (input.Object) {
        return {
          kind: "Input",
          index,
          value: {
            Object: input.Object.ImmOrOwnedObject ? {
              ImmOrOwned: input.Object.ImmOrOwnedObject
            } : input.Object.Receiving ? {
              Receiving: {
                digest: input.Object.Receiving.digest,
                version: input.Object.Receiving.version,
                objectId: input.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: input.Object.SharedObject.mutable,
                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
                objectId: input.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      }
      if (input.Pure) {
        return {
          kind: "Input",
          index,
          value: {
            Pure: Array.from(fromBase64(input.Pure.bytes))
          },
          type: "pure"
        };
      }
      if (input.UnresolvedPure) {
        return {
          kind: "Input",
          type: "pure",
          index,
          value: input.UnresolvedPure.value
        };
      }
      if (input.UnresolvedObject) {
        return {
          kind: "Input",
          type: "object",
          index,
          value: input.UnresolvedObject.objectId
        };
      }
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: transactionData.sender ?? void 0,
    expiration: transactionData.expiration?.$kind === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
    gasConfig: {
      owner: transactionData.gasData.owner ?? void 0,
      budget: transactionData.gasData.budget ?? void 0,
      price: transactionData.gasData.price ?? void 0,
      payment: transactionData.gasData.payment ?? void 0
    },
    inputs,
    transactions: transactionData.commands.map((command) => {
      if (command.MakeMoveVec) {
        return {
          kind: "MakeMoveVec",
          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
          objects: command.MakeMoveVec.elements.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.MergeCoins) {
        return {
          kind: "MergeCoins",
          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.MoveCall) {
        return {
          kind: "MoveCall",
          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
          typeArguments: command.MoveCall.typeArguments,
          arguments: command.MoveCall.arguments.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.Publish) {
        return {
          kind: "Publish",
          modules: command.Publish.modules.map((mod3) => Array.from(fromBase64(mod3))),
          dependencies: command.Publish.dependencies
        };
      }
      if (command.SplitCoins) {
        return {
          kind: "SplitCoins",
          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.TransferObjects) {
        return {
          kind: "TransferObjects",
          objects: command.TransferObjects.objects.map(
            (arg) => convertTransactionArgument(arg, inputs)
          ),
          address: convertTransactionArgument(command.TransferObjects.address, inputs)
        };
      }
      if (command.Upgrade) {
        return {
          kind: "Upgrade",
          modules: command.Upgrade.modules.map((mod3) => Array.from(fromBase64(mod3))),
          dependencies: command.Upgrade.dependencies,
          packageId: command.Upgrade.package,
          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
        };
      }
      throw new Error(`Unknown transaction ${Object.keys(command)}`);
    })
  };
}
function convertTransactionArgument(arg, inputs) {
  if (arg.$kind === "GasCoin") {
    return { kind: "GasCoin" };
  }
  if (arg.$kind === "Result") {
    return { kind: "Result", index: arg.Result };
  }
  if (arg.$kind === "NestedResult") {
    return { kind: "NestedResult", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };
  }
  if (arg.$kind === "Input") {
    return inputs[arg.Input];
  }
  throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
  return parse2(TransactionDataSchema, {
    version: 2,
    sender: data.sender ?? null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: data.gasConfig.owner ?? null,
      budget: data.gasConfig.budget?.toString() ?? null,
      price: data.gasConfig.price?.toString() ?? null,
      payment: data.gasConfig.payment?.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      })) ?? null
    },
    inputs: data.inputs.map((input) => {
      if (input.kind === "Input") {
        if (is(NormalizedCallArg2, input.value)) {
          const value2 = parse2(NormalizedCallArg2, input.value);
          if (value2.Object) {
            if (value2.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value2.Object.ImmOrOwned.objectId,
                    version: String(value2.Object.ImmOrOwned.version),
                    digest: value2.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value2.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: value2.Object.Shared.mutable ?? null,
                    initialSharedVersion: value2.Object.Shared.initialSharedVersion,
                    objectId: value2.Object.Shared.objectId
                  }
                }
              };
            }
            if (value2.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value2.Object.Receiving.digest,
                    version: String(value2.Object.Receiving.version),
                    objectId: value2.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase64(new Uint8Array(value2.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod3, fn] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod3,
              function: fn,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod3) => toBase64(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
              address: parseV1TransactionArgument(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod3) => toBase64(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e3) => e3.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b2(dataWithTag, { dkLen: 32 });
}

// node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class {
  constructor(clone) {
    this.version = 2;
    this.sender = clone?.sender ?? null;
    this.expiration = clone?.expiration ?? null;
    this.inputs = clone?.inputs ?? [];
    this.commands = clone?.commands ?? [];
    this.gasData = clone?.gasData ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return TransactionDataBuilder.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes) {
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData?.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return TransactionDataBuilder.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new TransactionDataBuilder(parse2(TransactionDataSchema, data));
    } else {
      return new TransactionDataBuilder(parse2(TransactionDataSchema, transactionDataFromV1(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toBase58(hash);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value2) {
    this.gasData = value2;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = overrides?.expiration ?? this.expiration;
    const sender = overrides?.sender ?? this.sender;
    const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress(this.gasData.owner ?? sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type2, arg) {
    const index = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index, type: type2, $kind: "Input" };
  }
  getInputUses(index, fn) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index) {
        fn(arg, command);
      }
      return arg;
    });
  }
  mapCommandArguments(index, fn) {
    const command = this.commands[index];
    switch (command.$kind) {
      case "MoveCall":
        command.MoveCall.arguments = command.MoveCall.arguments.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "TransferObjects":
        command.TransferObjects.objects = command.TransferObjects.objects.map(
          (arg) => fn(arg, command, index)
        );
        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);
        break;
      case "SplitCoins":
        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);
        command.SplitCoins.amounts = command.SplitCoins.amounts.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "MergeCoins":
        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);
        command.MergeCoins.sources = command.MergeCoins.sources.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "MakeMoveVec":
        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "Upgrade":
        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);
        break;
      case "$Intent":
        const inputs = command.$Intent.inputs;
        command.$Intent.inputs = {};
        for (const [key2, value2] of Object.entries(inputs)) {
          command.$Intent.inputs[key2] = Array.isArray(value2) ? value2.map((arg) => fn(arg, command, index)) : fn(value2, command, index);
        }
        break;
      case "Publish":
        break;
      default:
        throw new Error(`Unexpected transaction kind: ${command.$kind}`);
    }
  }
  mapArguments(fn) {
    for (const commandIndex of this.commands.keys()) {
      this.mapCommandArguments(commandIndex, fn);
    }
  }
  replaceCommand(index, replacement, resultIndex = index) {
    if (!Array.isArray(replacement)) {
      this.commands[index] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg, _command, commandIndex) => {
        if (commandIndex < index + replacement.length) {
          return arg;
        }
        switch (arg.$kind) {
          case "Result":
            if (arg.Result === index) {
              arg.Result = resultIndex;
            }
            if (arg.Result > index) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] === index) {
              arg.NestedResult[0] = resultIndex;
            }
            if (arg.NestedResult[0] > index) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return TransactionDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return parse2(TransactionDataSchema, this);
  }
  shallowClone() {
    return new TransactionDataBuilder({
      version: this.version,
      sender: this.sender,
      expiration: this.expiration,
      gasData: {
        ...this.gasData
      },
      inputs: [...this.inputs],
      commands: [...this.commands]
    });
  }
  applyResolvedData(resolved) {
    if (!this.sender) {
      this.sender = resolved.sender ?? null;
    }
    if (!this.expiration) {
      this.expiration = resolved.expiration ?? null;
    }
    if (!this.gasData.budget) {
      this.gasData.budget = resolved.gasData.budget;
    }
    if (!this.gasData.owner) {
      this.gasData.owner = resolved.gasData.owner ?? null;
    }
    if (!this.gasData.payment) {
      this.gasData.payment = resolved.gasData.payment;
    }
    if (!this.gasData.price) {
      this.gasData.price = resolved.gasData.price;
    }
    for (let i2 = 0; i2 < this.inputs.length; i2++) {
      const input = this.inputs[i2];
      const resolvedInput = resolved.inputs[i2];
      switch (input.$kind) {
        case "UnresolvedPure":
          if (resolvedInput.$kind !== "Pure") {
            throw new Error(
              `Expected input at index ${i2} to resolve to a Pure argument, but got ${JSON.stringify(
                resolvedInput
              )}`
            );
          }
          this.inputs[i2] = resolvedInput;
          break;
        case "UnresolvedObject":
          if (resolvedInput.$kind !== "Object") {
            throw new Error(
              `Expected input at index ${i2} to resolve to an Object argument, but got ${JSON.stringify(
                resolvedInput
              )}`
            );
          }
          if (resolvedInput.Object.$kind === "ImmOrOwnedObject" || resolvedInput.Object.$kind === "Receiving") {
            const original = input.UnresolvedObject;
            const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;
            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest || // Objects with shared object properties should not resolve to owned objects
            original.mutable != null || original.initialSharedVersion != null) {
              throw new Error(
                `Input at index ${i2} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`
              );
            }
          } else if (resolvedInput.Object.$kind === "SharedObject") {
            const original = input.UnresolvedObject;
            const resolved2 = resolvedInput.Object.SharedObject;
            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable || // Objects with owned object properties should not resolve to shared objects
            original.version != null || original.digest != null) {
              throw new Error(
                `Input at index ${i2} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`
              );
            }
          } else {
            throw new Error(
              `Input at index ${i2} resolved to an unexpected Object kind: ${JSON.stringify(
                resolvedInput.Object
              )}`
            );
          }
          this.inputs[i2] = resolvedInput;
          break;
      }
    }
  }
};

// node_modules/@mysten/sui/dist/esm/experimental/transports/utils.js
function parseTransactionBcs(bytes) {
  return {
    ...TransactionDataBuilder.fromBytes(bytes).snapshot(),
    bcs: bytes
  };
}
function parseTransactionEffectsBcs(effects) {
  const parsed = suiBcs.TransactionEffects.parse(effects);
  switch (parsed.$kind) {
    case "V1":
      return parseTransactionEffectsV1({ bytes: effects, effects: parsed.V1 });
    case "V2":
      return parseTransactionEffectsV2({ bytes: effects, effects: parsed.V2 });
    default:
      throw new Error(
        `Unknown transaction effects version: ${parsed.$kind}`
      );
  }
}
function parseTransactionEffectsV1(_) {
  throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV2({
  bytes,
  effects
}) {
  const changedObjects = effects.changedObjects.map(
    ([id, change]) => {
      return {
        id,
        inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: change.inputState.Exist?.[0][0] ?? null,
        inputDigest: change.inputState.Exist?.[0][1] ?? null,
        inputOwner: change.inputState.Exist?.[1] ?? null,
        outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
        outputVersion: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
        outputDigest: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[1] : change.outputState.ObjectWrite?.[0] ?? null,
        outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
        idOperation: change.idOperation.$kind
      };
    }
  );
  return {
    bcs: bytes,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.$kind === "Success" ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: add command
      error: effects.status.Failed.error.$kind
    },
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
    eventsDigest: effects.eventsDigest,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion,
    changedObjects,
    unchangedConsensusObjects: effects.unchangedSharedObjects.map(
      ([objectId, object2]) => {
        return {
          kind: object2.$kind === "MutateDeleted" ? "MutateConsensusStreamEnded" : object2.$kind === "ReadDeleted" ? "ReadConsensusStreamEnded" : object2.$kind,
          objectId,
          version: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[0] : object2[object2.$kind],
          digest: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[1] : null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxDataDigest
  };
}

// node_modules/@mysten/sui/dist/esm/graphql/generated/queries.js
var ZkLoginIntentScope = /* @__PURE__ */ ((ZkLoginIntentScope22) => {
  ZkLoginIntentScope22["PersonalMessage"] = "PERSONAL_MESSAGE";
  ZkLoginIntentScope22["TransactionData"] = "TRANSACTION_DATA";
  return ZkLoginIntentScope22;
})(ZkLoginIntentScope || {});
var TypedDocumentString = class extends String {
  constructor(value2, __meta__) {
    super(value2);
    this.value = value2;
    this.__meta__ = __meta__;
  }
  toString() {
    return this.value;
  }
};
var Object_Owner_FieldsFragmentDoc = new TypedDocumentString(`
    fragment OBJECT_OWNER_FIELDS on Owner {
  __typename
  ... on AddressOwner {
    address {
      address
    }
  }
  ... on ObjectOwner {
    address {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    address {
      address
    }
  }
}
    `, { "fragmentName": "OBJECT_OWNER_FIELDS" });
var Object_FieldsFragmentDoc = new TypedDocumentString(`
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransaction {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on Owner {
  __typename
  ... on AddressOwner {
    address {
      address
    }
  }
  ... on ObjectOwner {
    address {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    address {
      address
    }
  }
}`, { "fragmentName": "OBJECT_FIELDS" });
var Move_Object_FieldsFragmentDoc = new TypedDocumentString(`
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransaction {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on Owner {
  __typename
  ... on AddressOwner {
    address {
      address
    }
  }
  ... on ObjectOwner {
    address {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    address {
      address
    }
  }
}`, { "fragmentName": "MOVE_OBJECT_FIELDS" });
var Transaction_FieldsFragmentDoc = new TypedDocumentString(`
    fragment TRANSACTION_FIELDS on Transaction {
  digest
  transactionBcs
  signatures {
    signatureBytes
  }
  effects {
    effectsBcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}
    `, { "fragmentName": "TRANSACTION_FIELDS" });
var GetAllBalancesDocument = new TypedDocumentString(`
    query getAllBalances($owner: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $owner) {
    balances(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinType {
          repr
        }
        totalBalance
      }
    }
  }
}
    `);
var GetBalanceDocument = new TypedDocumentString(`
    query getBalance($owner: SuiAddress!, $coinType: String! = "0x2::sui::SUI") {
  address(address: $owner) {
    balance(coinType: $coinType) {
      coinType {
        repr
      }
      totalBalance
    }
  }
}
    `);
var GetCoinsDocument = new TypedDocumentString(`
    query getCoins($owner: SuiAddress!, $first: Int, $cursor: String, $type: String! = "0x2::coin::Coin<0x2::sui::SUI>") {
  address(address: $owner) {
    address
    objects(first: $first, after: $cursor, filter: {type: $type}) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        owner {
          ...OBJECT_OWNER_FIELDS
        }
        contents {
          bcs
          json
          type {
            repr
          }
        }
        address
        version
        digest
        previousTransaction {
          digest
        }
      }
    }
  }
}
    fragment OBJECT_OWNER_FIELDS on Owner {
  __typename
  ... on AddressOwner {
    address {
      address
    }
  }
  ... on ObjectOwner {
    address {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    address {
      address
    }
  }
}`);
var GetDynamicFieldsDocument = new TypedDocumentString(`
    query getDynamicFields($parentId: SuiAddress!, $first: Int, $cursor: String) {
  address(address: $parentId) {
    dynamicFields(first: $first, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name {
          bcs
          type {
            repr
          }
        }
        value {
          __typename
          ... on MoveValue {
            type {
              repr
            }
          }
          ... on MoveObject {
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}
    `);
var GetMoveFunctionDocument = new TypedDocumentString(`
    query getMoveFunction($package: SuiAddress!, $module: String!, $function: String!) {
  package(address: $package) {
    module(name: $module) {
      function(name: $function) {
        name
        visibility
        isEntry
        typeParameters {
          constraints
        }
        parameters {
          signature
        }
        return {
          signature
        }
      }
    }
  }
}
    `);
var GetReferenceGasPriceDocument = new TypedDocumentString(`
    query getReferenceGasPrice {
  epoch {
    referenceGasPrice
  }
}
    `);
var DefaultSuinsNameDocument = new TypedDocumentString(`
    query defaultSuinsName($address: SuiAddress!) {
  address(address: $address) {
    defaultSuinsName
  }
}
    `);
var GetOwnedObjectsDocument = new TypedDocumentString(`
    query getOwnedObjects($owner: SuiAddress!, $limit: Int, $cursor: String, $filter: ObjectFilter) {
  address(address: $owner) {
    objects(first: $limit, after: $cursor, filter: $filter) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        ...MOVE_OBJECT_FIELDS
      }
    }
  }
}
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransaction {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on Owner {
  __typename
  ... on AddressOwner {
    address {
      address
    }
  }
  ... on ObjectOwner {
    address {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    address {
      address
    }
  }
}`);
var MultiGetObjectsDocument = new TypedDocumentString(`
    query multiGetObjects($objectKeys: [ObjectKey!]!) {
  multiGetObjects(keys: $objectKeys) {
    ...OBJECT_FIELDS
  }
}
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransaction {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on Owner {
  __typename
  ... on AddressOwner {
    address {
      address
    }
  }
  ... on ObjectOwner {
    address {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    address {
      address
    }
  }
}`);
var SimulateTransactionDocument = new TypedDocumentString(`
    query simulateTransaction($transaction: JSON!) {
  simulateTransaction(transaction: $transaction) {
    error
    effects {
      transaction {
        ...TRANSACTION_FIELDS
      }
    }
  }
}
    fragment TRANSACTION_FIELDS on Transaction {
  digest
  transactionBcs
  signatures {
    signatureBytes
  }
  effects {
    effectsBcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var ExecuteTransactionDocument = new TypedDocumentString(`
    mutation executeTransaction($transactionDataBcs: Base64!, $signatures: [Base64!]!) {
  executeTransaction(
    transactionDataBcs: $transactionDataBcs
    signatures: $signatures
  ) {
    errors
    effects {
      transaction {
        ...TRANSACTION_FIELDS
      }
    }
  }
}
    fragment TRANSACTION_FIELDS on Transaction {
  digest
  transactionBcs
  signatures {
    signatureBytes
  }
  effects {
    effectsBcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var GetTransactionBlockDocument = new TypedDocumentString(`
    query getTransactionBlock($digest: String!) {
  transaction(digest: $digest) {
    ...TRANSACTION_FIELDS
  }
}
    fragment TRANSACTION_FIELDS on Transaction {
  digest
  transactionBcs
  signatures {
    signatureBytes
  }
  effects {
    effectsBcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var VerifyZkLoginSignatureDocument = new TypedDocumentString(`
    query verifyZkLoginSignature($bytes: Base64!, $signature: Base64!, $intentScope: ZkLoginIntentScope!, $author: SuiAddress!) {
  verifyZkLoginSignature(
    bytes: $bytes
    signature: $signature
    intentScope: $intentScope
    author: $author
  ) {
    success
    error
  }
}
    `);

// node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError = class extends Error {
};
var ObjectError = class extends SuiClientError {
  constructor(code, message) {
    super(message);
    this.code = code;
  }
  static fromResponse(response, objectId) {
    switch (response.code) {
      case "notExists":
        return new ObjectError(response.code, `Object ${response.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new ObjectError(
          response.code,
          `Dynamic field not found for object ${response.parent_object_id}`
        );
      case "deleted":
        return new ObjectError(response.code, `Object ${response.object_id} has been deleted`);
      case "displayError":
        return new ObjectError(response.code, `Display error: ${response.error}`);
      case "unknown":
      default:
        return new ObjectError(
          response.code,
          `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`
        );
    }
  }
};

// node_modules/@mysten/sui/dist/esm/graphql/core.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value2) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet4 = (obj, member, value2, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod2 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _graphqlClient;
var _GraphQLCoreClient_instances;
var graphqlQuery_fn;
var GraphQLCoreClient = class extends Experimental_CoreClient {
  constructor({
    graphqlClient,
    mvr
  }) {
    super({ network: graphqlClient.network, base: graphqlClient, mvr });
    __privateAdd4(this, _GraphQLCoreClient_instances);
    __privateAdd4(this, _graphqlClient);
    __privateSet4(this, _graphqlClient, graphqlClient);
  }
  async getObjects(options) {
    const batches = chunk(options.objectIds, 50);
    const results = [];
    for (const batch of batches) {
      const page = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
        query: MultiGetObjectsDocument,
        variables: {
          objectKeys: batch.map((address) => ({ address }))
        }
      }, (result) => result.multiGetObjects);
      results.push(
        ...batch.map((id) => normalizeSuiAddress(id)).map(
          (id) => page.find((obj) => obj?.address === id) ?? new ObjectError("notFound", `Object ${id} not found`)
        ).map((obj) => {
          if (obj instanceof ObjectError) {
            return obj;
          }
          return {
            id: obj.address,
            version: obj.version?.toString(),
            digest: obj.digest,
            owner: mapOwner(obj.owner),
            type: obj.asMoveObject?.contents?.type?.repr,
            content: Promise.resolve(
              obj.asMoveObject?.contents?.bcs ? fromBase64(obj.asMoveObject.contents.bcs) : new Uint8Array()
            ),
            previousTransaction: obj.previousTransaction?.digest ?? null
          };
        })
      );
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetOwnedObjectsDocument,
      variables: {
        owner: options.address,
        limit: options.limit,
        cursor: options.cursor,
        filter: options.type ? { type: (await this.mvr.resolveType({ type: options.type })).type } : void 0
      }
    }, (result) => result.address?.objects);
    return {
      objects: objects.nodes.map((obj) => ({
        id: obj.address,
        version: obj.version?.toString(),
        digest: obj.digest,
        owner: mapOwner(obj.owner),
        type: obj.contents?.type?.repr,
        content: Promise.resolve(
          obj.contents?.bcs ? fromBase64(obj.contents.bcs) : new Uint8Array()
        ),
        previousTransaction: obj.previousTransaction?.digest ?? null
      })),
      hasNextPage: objects.pageInfo.hasNextPage,
      cursor: objects.pageInfo.endCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetCoinsDocument,
      variables: {
        owner: options.address,
        cursor: options.cursor,
        first: options.limit,
        type: `0x2::coin::Coin<${(await this.mvr.resolveType({ type: options.coinType })).type}>`
      }
    }, (result) => result.address?.objects);
    return {
      cursor: coins.pageInfo.endCursor ?? null,
      hasNextPage: coins.pageInfo.hasNextPage,
      objects: coins.nodes.map((coin) => ({
        id: coin.address,
        version: coin.version?.toString(),
        digest: coin.digest,
        owner: mapOwner(coin.owner),
        type: coin.contents?.type?.repr,
        balance: coin.contents?.json?.balance,
        content: Promise.resolve(
          coin.contents?.bcs ? fromBase64(coin.contents.bcs) : new Uint8Array()
        ),
        previousTransaction: coin.previousTransaction?.digest ?? null
      }))
    };
  }
  async getBalance(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetBalanceDocument,
      variables: {
        owner: options.address,
        type: (await this.mvr.resolveType({ type: options.coinType })).type
      }
    }, (result2) => result2.address?.balance);
    return {
      balance: {
        coinType: result.coinType?.repr,
        balance: result.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetAllBalancesDocument,
      variables: { owner: options.address }
    }, (result) => result.address?.balances);
    return {
      cursor: balances.pageInfo.endCursor ?? null,
      hasNextPage: balances.pageInfo.hasNextPage,
      balances: balances.nodes.map((balance) => ({
        coinType: balance.coinType?.repr,
        balance: balance.totalBalance
      }))
    };
  }
  async getTransaction(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetTransactionBlockDocument,
      variables: { digest: options.digest }
    }, (result2) => result2.transaction);
    return {
      transaction: parseTransaction(result)
    };
  }
  async executeTransaction(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: ExecuteTransactionDocument,
      variables: {
        transactionDataBcs: toBase64(options.transaction),
        signatures: options.signatures
      }
    }, (result2) => result2.executeTransaction);
    if (result.errors) {
      if (result.errors.length === 1) {
        throw new Error(result.errors[0]);
      }
      throw new AggregateError(result.errors.map((error2) => new Error(error2)));
    }
    return {
      transaction: parseTransaction(result.effects?.transaction)
    };
  }
  async dryRunTransaction(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: SimulateTransactionDocument,
      variables: {
        transaction: {
          bcs: {
            value: toBase64(options.transaction)
          }
        }
      }
    }, (result2) => result2.simulateTransaction);
    if (result.error) {
      throw new Error(result.error);
    }
    return {
      transaction: parseTransaction(result.effects?.transaction)
    };
  }
  async getReferenceGasPrice() {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetReferenceGasPriceDocument
    }, (result2) => result2.epoch?.referenceGasPrice);
    return {
      referenceGasPrice: result
    };
  }
  async getDynamicFields(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetDynamicFieldsDocument,
      variables: { parentId: options.parentId }
    }, (result2) => result2.address?.dynamicFields);
    return {
      dynamicFields: result.nodes.map((dynamicField) => {
        const valueType = dynamicField.value?.__typename === "MoveObject" ? dynamicField.value.contents?.type?.repr : dynamicField.value?.type?.repr;
        return {
          id: deriveDynamicFieldID(
            options.parentId,
            dynamicField.name?.type?.repr,
            fromBase64(dynamicField.name?.bcs)
          ),
          type: normalizeStructTag(
            dynamicField.value?.__typename === "MoveObject" ? `0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${dynamicField.name?.type?.repr}>,0x2::object::ID>` : `0x2::dynamic_field::Field<${dynamicField.name?.type?.repr},${valueType}>`
          ),
          name: {
            type: dynamicField.name?.type?.repr,
            bcs: fromBase64(dynamicField.name?.bcs)
          },
          valueType
        };
      }),
      cursor: result.pageInfo.endCursor ?? null,
      hasNextPage: result.pageInfo.hasNextPage
    };
  }
  async verifyZkLoginSignature(options) {
    const intentScope = options.intentScope === "TransactionData" ? ZkLoginIntentScope.TransactionData : ZkLoginIntentScope.PersonalMessage;
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: VerifyZkLoginSignatureDocument,
      variables: {
        bytes: options.bytes,
        signature: options.signature,
        intentScope,
        author: options.author
      }
    }, (result2) => result2.verifyZkLoginSignature);
    return {
      success: result.success ?? false,
      errors: result.error ? [result.error] : []
    };
  }
  async defaultNameServiceName(options) {
    const name2 = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: DefaultSuinsNameDocument,
      signal: options.signal,
      variables: {
        address: options.address
      }
    }, (result) => result.address?.defaultSuinsName ?? null);
    return {
      data: { name: name2 }
    };
  }
  async getMoveFunction(options) {
    const moveFunction = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetMoveFunctionDocument,
      variables: {
        package: (await this.mvr.resolvePackage({ package: options.packageId })).package,
        module: options.moduleName,
        function: options.name
      }
    }, (result) => result.package?.module?.function);
    let visibility = "unknown";
    switch (moveFunction.visibility) {
      case "PUBLIC":
        visibility = "public";
        break;
      case "PRIVATE":
        visibility = "private";
        break;
      case "FRIEND":
        visibility = "friend";
        break;
    }
    return {
      function: {
        packageId: normalizeSuiAddress(options.packageId),
        moduleName: options.moduleName,
        name: moveFunction.name,
        visibility,
        isEntry: moveFunction.isEntry ?? false,
        typeParameters: moveFunction.typeParameters?.map(({ constraints }) => ({
          isPhantom: false,
          constraints: constraints.map((constraint) => {
            switch (constraint) {
              case "COPY":
                return "copy";
              case "DROP":
                return "drop";
              case "STORE":
                return "store";
              case "KEY":
                return "key";
              default:
                return "unknown";
            }
          }) ?? []
        })) ?? [],
        parameters: moveFunction.parameters?.map((param) => parseNormalizedSuiMoveType(param.signature)) ?? [],
        returns: moveFunction.return?.map(({ signature }) => parseNormalizedSuiMoveType(signature)) ?? []
      }
    };
  }
  resolveTransactionPlugin() {
    throw new Error("GraphQL client does not support transaction resolution yet");
  }
};
_graphqlClient = /* @__PURE__ */ new WeakMap();
_GraphQLCoreClient_instances = /* @__PURE__ */ new WeakSet();
graphqlQuery_fn = async function(options, getData) {
  const { data, errors } = await __privateGet4(this, _graphqlClient).query(options);
  handleGraphQLErrors(errors);
  const extractedData = data && (getData ? getData(data) : data);
  if (extractedData == null) {
    throw new Error("Missing response data");
  }
  return extractedData;
};
function handleGraphQLErrors(errors) {
  if (!errors || errors.length === 0)
    return;
  const errorInstances = errors.map((error2) => new GraphQLResponseError(error2));
  if (errorInstances.length === 1) {
    throw errorInstances[0];
  }
  throw new AggregateError(errorInstances);
}
var GraphQLResponseError = class extends Error {
  constructor(error2) {
    super(error2.message);
    this.locations = error2.locations;
  }
};
function mapOwner(owner) {
  switch (owner.__typename) {
    case "AddressOwner":
      return { $kind: "AddressOwner", AddressOwner: owner.address?.address };
    case "ConsensusAddressOwner":
      return {
        $kind: "ConsensusAddressOwner",
        ConsensusAddressOwner: {
          owner: owner?.address?.address,
          startVersion: String(owner.startVersion)
        }
      };
    case "ObjectOwner":
      return { $kind: "ObjectOwner", ObjectOwner: owner.address?.address };
    case "Immutable":
      return { $kind: "Immutable", Immutable: true };
    case "Shared":
      return {
        $kind: "Shared",
        Shared: { initialSharedVersion: String(owner.initialSharedVersion) }
      };
  }
}
function parseTransaction(transaction) {
  const objectTypes = {};
  transaction.effects?.unchangedConsensusObjects?.nodes.forEach((node) => {
    if (node.__typename === "ConsensusObjectRead") {
      const type2 = node.object?.asMoveObject?.contents?.type?.repr;
      const address = node.object?.asMoveObject?.address;
      if (type2 && address) {
        objectTypes[address] = type2;
      }
    }
  });
  transaction.effects?.objectChanges?.nodes.forEach((node) => {
    const address = node.address;
    const type2 = node.inputState?.asMoveObject?.contents?.type?.repr ?? node.outputState?.asMoveObject?.contents?.type?.repr;
    if (address && type2) {
      objectTypes[address] = type2;
    }
  });
  if (transaction.effects?.balanceChanges?.pageInfo.hasNextPage) {
    throw new Error("Pagination for balance changes is not supported");
  }
  return {
    digest: transaction.digest,
    effects: parseTransactionEffectsBcs(fromBase64(transaction.effects?.effectsBcs)),
    epoch: transaction.effects?.epoch?.epochId?.toString() ?? null,
    objectTypes: Promise.resolve(objectTypes),
    transaction: parseTransactionBcs(fromBase64(transaction.transactionBcs)),
    signatures: transaction.signatures.map((sig) => sig.signatureBytes),
    balanceChanges: transaction.effects?.balanceChanges?.nodes.map((change) => ({
      coinType: change?.coinType?.repr,
      address: change.owner?.address,
      amount: change.amount
    })) ?? []
    // events: transaction.events?.pageInfo.hasNextPage
  };
}
function parseNormalizedSuiMoveType(type2) {
  let reference = null;
  if (type2.ref === "&") {
    reference = "immutable";
  } else if (type2.ref === "&mut") {
    reference = "mutable";
  }
  return {
    reference,
    body: parseNormalizedSuiMoveTypeBody(type2.body)
  };
}
function parseNormalizedSuiMoveTypeBody(type2) {
  switch (type2) {
    case "address":
      return { $kind: "address" };
    case "bool":
      return { $kind: "bool" };
    case "u8":
      return { $kind: "u8" };
    case "u16":
      return { $kind: "u16" };
    case "u32":
      return { $kind: "u32" };
    case "u64":
      return { $kind: "u64" };
    case "u128":
      return { $kind: "u128" };
    case "u256":
      return { $kind: "u256" };
  }
  if (typeof type2 === "string") {
    throw new Error(`Unknown type: ${type2}`);
  }
  if ("vector" in type2) {
    return {
      $kind: "vector",
      vector: parseNormalizedSuiMoveTypeBody(type2.vector)
    };
  }
  if ("datatype" in type2) {
    return {
      $kind: "datatype",
      datatype: {
        typeName: `${normalizeSuiAddress(type2.datatype.package)}::${type2.datatype.module}::${type2.datatype.type}`,
        typeParameters: type2.datatype.typeParameters.map((t3) => parseNormalizedSuiMoveTypeBody(t3))
      }
    };
  }
  if ("typeParameter" in type2) {
    return {
      $kind: "typeParameter",
      index: type2.typeParameter
    };
  }
  throw new Error(`Unknown type: ${JSON.stringify(type2)}`);
}

// node_modules/@mysten/sui/dist/esm/graphql/client.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value2) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet5 = (obj, member, value2, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _url2;
var _queries;
var _headers;
var _fetch;
var SuiGraphQLRequestError = class extends Error {
};
var SuiGraphQLClient = class extends Experimental_BaseClient {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {},
    network = "unknown",
    mvr
  }) {
    super({
      network
    });
    __privateAdd5(this, _url2);
    __privateAdd5(this, _queries);
    __privateAdd5(this, _headers);
    __privateAdd5(this, _fetch);
    __privateSet5(this, _url2, url);
    __privateSet5(this, _queries, queries);
    __privateSet5(this, _headers, headers);
    __privateSet5(this, _fetch, (...args) => fetchFn(...args));
    this.core = new GraphQLCoreClient({
      graphqlClient: this,
      mvr
    });
  }
  async query(options) {
    const res = await __privateGet5(this, _fetch).call(this, __privateGet5(this, _url2), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet5(this, _headers)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" || options.query instanceof String ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      }),
      signal: options.signal
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet5(this, _queries)[query]
    });
  }
};
_url2 = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase64(serializedSignature);
}

// node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE = 32;
var SUI_PRIVATE_KEY_PREFIX = "suiprivkey";
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b2(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes) {
    return this.signWithIntent(bytes, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    const { signature } = await this.signWithIntent(
      bcs.byteVector().serialize(bytes).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase64(bytes),
      signature
    };
  }
  async signAndExecuteTransaction({
    transaction,
    client
  }) {
    const bytes = await transaction.build({ client });
    const { signature } = await this.signTransaction(bytes);
    const response = await client.core.executeTransaction({
      transaction: bytes,
      signatures: [signature]
    });
    return response.transaction;
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};
var Keypair = class extends Signer {
};
function decodeSuiPrivateKey(value2) {
  const { prefix, words } = bech32.decode(value2);
  if (prefix !== SUI_PRIVATE_KEY_PREFIX) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
  return {
    scheme: signatureScheme,
    schema: signatureScheme,
    secretKey
  };
}
function encodeSuiPrivateKey(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));
}

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c);
  anumber(dkLen);
  anumber(asyncTick);
  if (c < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@scure/bip39/esm/index.js
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/@mysten/sui/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHex(mnemonicToSeed(mnemonics));
}

// node_modules/@noble/hashes/esm/sha512.js
var sha5122 = sha512;

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h = hmac.create(sha5122, ED25519_CURVE);
  const I = h.update(fromHex(seed)).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key: key2, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key2.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key2, 1);
  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key2.length + 1);
  const I = hmac.create(sha5122, chainCode).update(data).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key: key2, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {
    key: key2,
    chainCode
  });
};

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return ed25519.verify(bytes, message, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class extends Keypair {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = {
        publicKey: keypair.publicKey,
        secretKey: keypair.secretKey.slice(0, 32)
      };
    } else {
      const privateKey = ed25519.utils.randomPrivateKey();
      this.keypair = {
        publicKey: ed25519.getPublicKey(privateKey),
        secretKey: privateKey
      };
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    const secretKey = ed25519.utils.randomPrivateKey();
    return new Ed25519Keypair({
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    });
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key as a byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey(secretKey);
      if (decoded.schema !== "ED25519") {
        throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = {
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    };
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = ed25519.sign(signData, secretKey);
      if (!ed25519.verify(signature, signData, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new Ed25519Keypair(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Ed25519 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey(
      this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),
      this.getKeyScheme()
    );
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  async sign(data) {
    return ed25519.sign(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key: key2 } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return Ed25519Keypair.fromSecretKey(key2);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(seedHex, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key: key2 } = derivePath(path, seedHex);
    return Ed25519Keypair.fromSecretKey(key2);
  }
};

// node_modules/@mysten/sui/dist/esm/utils/constants.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");
var SUI_RANDOM_OBJECT_ID = normalizeSuiObjectId("0x8");

// src/mnemonic-wallet.ts
var MnemonicWallet = class {
  constructor(mnemonic) {
    this.mnemonic = mnemonic;
    const keypair = Ed25519Keypair.deriveKeypair(mnemonic);
    this.keypair = keypair;
    const privateKey = keypair.getSecretKey();
    const publicKey = keypair.getPublicKey();
    this.address = publicKey.toSuiAddress();
    this.privateKey = privateKey;
    this.publicKey = toBase64(publicKey.toRawBytes());
  }
  getAddress() {
    return this.address;
  }
  async signPersonalMessage(message) {
    let intent = messageWithIntent("PersonalMessage", suiBcs.vector(suiBcs.u8()).serialize(message).toBytes());
    const signature = await this.generateSignature(intent, this.keypair);
    return signature;
  }
  async signTransaction(message) {
    let intent = messageWithIntent("TransactionData", message);
    const signature = await this.generateSignature(intent, this.keypair);
    return signature;
  }
  async generateSignature(data, keyPair) {
    const digest = blake2b2(data, { dkLen: 32 });
    const pubkey = keyPair.getPublicKey();
    const signature = await keyPair.sign(digest);
    const signatureScheme = keyPair.getKeyScheme();
    return toSerializedSignature({
      signature,
      signatureScheme,
      publicKey: pubkey
    });
  }
  destroy() {
    this.mnemonic = "";
    this.address = "";
    this.privateKey = "";
    this.publicKey = "";
    this.keypair = new Ed25519Keypair();
  }
};

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError = class extends Error {
  constructor(e3, r, i2, n2, t3, a3, o2) {
    if (super(e3), this.name = "GraphQLError", this.message = e3, t3) {
      this.path = t3;
    }
    if (r) {
      this.nodes = Array.isArray(r) ? r : [r];
    }
    if (i2) {
      this.source = i2;
    }
    if (n2) {
      this.positions = n2;
    }
    if (a3) {
      this.originalError = a3;
    }
    var l = o2;
    if (!l && a3) {
      var d = a3.extensions;
      if (d && "object" == typeof d) {
        l = d;
      }
    }
    this.extensions = l || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i;
var n;
function error(e3) {
  return new GraphQLError(`Syntax Error: Unexpected token at ${n} in ${e3}`);
}
function advance(e3) {
  if (e3.lastIndex = n, e3.test(i)) {
    return i.slice(n, n = e3.lastIndex);
  }
}
var t = / +(?=[^\s])/y;
function blockString(e3) {
  var r = e3.split("\n");
  var i2 = "";
  var n2 = 0;
  var a3 = 0;
  var o2 = r.length - 1;
  for (var l = 0; l < r.length; l++) {
    if (t.lastIndex = 0, t.test(r[l])) {
      if (l && (!n2 || t.lastIndex < n2)) {
        n2 = t.lastIndex;
      }
      a3 = a3 || l, o2 = l;
    }
  }
  for (var d = a3; d <= o2; d++) {
    if (d !== a3) {
      i2 += "\n";
    }
    i2 += r[d].slice(n2).replace(/\\"""/g, '"""');
  }
  return i2;
}
function ignored() {
  for (var e3 = 0 | i.charCodeAt(n++); 9 === e3 || 10 === e3 || 13 === e3 || 32 === e3 || 35 === e3 || 44 === e3 || 65279 === e3; e3 = 0 | i.charCodeAt(n++)) {
    if (35 === e3) {
      for (; (e3 = 0 | i.charCodeAt(n++)) && 10 !== e3 && 13 !== e3; ) {
      }
    }
  }
  n--;
}
function name() {
  var e3 = n;
  for (var r = 0 | i.charCodeAt(n++); r >= 48 && r <= 57 || r >= 65 && r <= 90 || 95 === r || r >= 97 && r <= 122; r = 0 | i.charCodeAt(n++)) {
  }
  if (e3 === n - 1) {
    throw error("Name");
  }
  var t3 = i.slice(e3, --n);
  return ignored(), t3;
}
function nameNode() {
  return {
    kind: "Name",
    value: name()
  };
}
var a = /(?:"""|(?:[\s\S]*?[^\\])""")/y;
var o = /(?:(?:\.\d+)?[eE][+-]?\d+|\.\d+)/y;
function value(e3) {
  var r;
  switch (i.charCodeAt(n)) {
    case 91:
      n++, ignored();
      var t3 = [];
      for (; 93 !== i.charCodeAt(n); ) {
        t3.push(value(e3));
      }
      return n++, ignored(), {
        kind: "ListValue",
        values: t3
      };
    case 123:
      n++, ignored();
      var l = [];
      for (; 125 !== i.charCodeAt(n); ) {
        var d = nameNode();
        if (58 !== i.charCodeAt(n++)) {
          throw error("ObjectField");
        }
        ignored(), l.push({
          kind: "ObjectField",
          name: d,
          value: value(e3)
        });
      }
      return n++, ignored(), {
        kind: "ObjectValue",
        fields: l
      };
    case 36:
      if (e3) {
        throw error("Variable");
      }
      return n++, {
        kind: "Variable",
        name: nameNode()
      };
    case 34:
      if (34 === i.charCodeAt(n + 1) && 34 === i.charCodeAt(n + 2)) {
        if (n += 3, null == (r = advance(a))) {
          throw error("StringValue");
        }
        return ignored(), {
          kind: "StringValue",
          value: blockString(r.slice(0, -3)),
          block: true
        };
      } else {
        var u = n;
        var s;
        n++;
        var c = false;
        for (s = 0 | i.charCodeAt(n++); 92 === s && (n++, c = true) || 10 !== s && 13 !== s && 34 !== s && s; s = 0 | i.charCodeAt(n++)) {
        }
        if (34 !== s) {
          throw error("StringValue");
        }
        return r = i.slice(u, n), ignored(), {
          kind: "StringValue",
          value: c ? JSON.parse(r) : r.slice(1, -1),
          block: false
        };
      }
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      var v = n++;
      var f;
      for (; (f = 0 | i.charCodeAt(n++)) >= 48 && f <= 57; ) {
      }
      var m = i.slice(v, --n);
      if (46 === (f = i.charCodeAt(n)) || 69 === f || 101 === f) {
        if (null == (r = advance(o))) {
          throw error("FloatValue");
        }
        return ignored(), {
          kind: "FloatValue",
          value: m + r
        };
      } else {
        return ignored(), {
          kind: "IntValue",
          value: m
        };
      }
    case 110:
      if (117 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 108 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "NullValue"
        };
      } else {
        break;
      }
    case 116:
      if (114 === i.charCodeAt(n + 1) && 117 === i.charCodeAt(n + 2) && 101 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "BooleanValue",
          value: true
        };
      } else {
        break;
      }
    case 102:
      if (97 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 115 === i.charCodeAt(n + 3) && 101 === i.charCodeAt(n + 4)) {
        return n += 5, ignored(), {
          kind: "BooleanValue",
          value: false
        };
      } else {
        break;
      }
  }
  return {
    kind: "EnumValue",
    value: name()
  };
}
function arguments_(e3) {
  if (40 === i.charCodeAt(n)) {
    var r = [];
    n++, ignored();
    do {
      var t3 = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("Argument");
      }
      ignored(), r.push({
        kind: "Argument",
        name: t3,
        value: value(e3)
      });
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), r;
  }
}
function directives(e3) {
  if (64 === i.charCodeAt(n)) {
    var r = [];
    do {
      n++, r.push({
        kind: "Directive",
        name: nameNode(),
        arguments: arguments_(e3)
      });
    } while (64 === i.charCodeAt(n));
    return r;
  }
}
function type() {
  var e3 = 0;
  for (; 91 === i.charCodeAt(n); ) {
    e3++, n++, ignored();
  }
  var r = {
    kind: "NamedType",
    name: nameNode()
  };
  do {
    if (33 === i.charCodeAt(n)) {
      n++, ignored(), r = {
        kind: "NonNullType",
        type: r
      };
    }
    if (e3) {
      if (93 !== i.charCodeAt(n++)) {
        throw error("NamedType");
      }
      ignored(), r = {
        kind: "ListType",
        type: r
      };
    }
  } while (e3--);
  return r;
}
function selectionSetStart() {
  if (123 !== i.charCodeAt(n++)) {
    throw error("SelectionSet");
  }
  return ignored(), selectionSet();
}
function selectionSet() {
  var e3 = [];
  do {
    if (46 === i.charCodeAt(n)) {
      if (46 !== i.charCodeAt(++n) || 46 !== i.charCodeAt(++n)) {
        throw error("SelectionSet");
      }
      switch (n++, ignored(), i.charCodeAt(n)) {
        case 64:
          e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: directives(false),
            selectionSet: selectionSetStart()
          });
          break;
        case 111:
          if (110 === i.charCodeAt(n + 1)) {
            n += 2, ignored(), e3.push({
              kind: "InlineFragment",
              typeCondition: {
                kind: "NamedType",
                name: nameNode()
              },
              directives: directives(false),
              selectionSet: selectionSetStart()
            });
          } else {
            e3.push({
              kind: "FragmentSpread",
              name: nameNode(),
              directives: directives(false)
            });
          }
          break;
        case 123:
          n++, ignored(), e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: void 0,
            selectionSet: selectionSet()
          });
          break;
        default:
          e3.push({
            kind: "FragmentSpread",
            name: nameNode(),
            directives: directives(false)
          });
      }
    } else {
      var r = nameNode();
      var t3 = void 0;
      if (58 === i.charCodeAt(n)) {
        n++, ignored(), t3 = r, r = nameNode();
      }
      var a3 = arguments_(false);
      var o2 = directives(false);
      var l = void 0;
      if (123 === i.charCodeAt(n)) {
        n++, ignored(), l = selectionSet();
      }
      e3.push({
        kind: "Field",
        alias: t3,
        name: r,
        arguments: a3,
        directives: o2,
        selectionSet: l
      });
    }
  } while (125 !== i.charCodeAt(n));
  return n++, ignored(), {
    kind: "SelectionSet",
    selections: e3
  };
}
function variableDefinitions() {
  if (ignored(), 40 === i.charCodeAt(n)) {
    var e3 = [];
    n++, ignored();
    do {
      var r = void 0;
      if (34 === i.charCodeAt(n)) {
        r = value(true);
      }
      if (36 !== i.charCodeAt(n++)) {
        throw error("Variable");
      }
      var t3 = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("VariableDefinition");
      }
      ignored();
      var a3 = type();
      var o2 = void 0;
      if (61 === i.charCodeAt(n)) {
        n++, ignored(), o2 = value(true);
      }
      ignored();
      var l = {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: t3
        },
        type: a3,
        defaultValue: o2,
        directives: directives(true)
      };
      if (r) {
        l.description = r;
      }
      e3.push(l);
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), e3;
  }
}
function fragmentDefinition(e3) {
  var r = nameNode();
  if (111 !== i.charCodeAt(n++) || 110 !== i.charCodeAt(n++)) {
    throw error("FragmentDefinition");
  }
  ignored();
  var t3 = {
    kind: "FragmentDefinition",
    name: r,
    typeCondition: {
      kind: "NamedType",
      name: nameNode()
    },
    directives: directives(false),
    selectionSet: selectionSetStart()
  };
  if (e3) {
    t3.description = e3;
  }
  return t3;
}
function definitions() {
  var e3 = [];
  do {
    var r = void 0;
    if (34 === i.charCodeAt(n)) {
      r = value(true);
    }
    if (123 === i.charCodeAt(n)) {
      if (r) {
        throw error("Document");
      }
      n++, ignored(), e3.push({
        kind: "OperationDefinition",
        operation: "query",
        name: void 0,
        variableDefinitions: void 0,
        directives: void 0,
        selectionSet: selectionSet()
      });
    } else {
      var t3 = name();
      switch (t3) {
        case "fragment":
          e3.push(fragmentDefinition(r));
          break;
        case "query":
        case "mutation":
        case "subscription":
          var a3;
          var o2 = void 0;
          if (40 !== (a3 = i.charCodeAt(n)) && 64 !== a3 && 123 !== a3) {
            o2 = nameNode();
          }
          var l = {
            kind: "OperationDefinition",
            operation: t3,
            name: o2,
            variableDefinitions: variableDefinitions(),
            directives: directives(false),
            selectionSet: selectionSetStart()
          };
          if (r) {
            l.description = r;
          }
          e3.push(l);
          break;
        default:
          throw error("Document");
      }
    }
  } while (n < i.length);
  return e3;
}
function parse3(e3, r) {
  if (i = e3.body ? e3.body : e3, n = 0, ignored(), r && r.noLocation) {
    return {
      kind: "Document",
      definitions: definitions()
    };
  } else {
    return {
      kind: "Document",
      definitions: definitions(),
      loc: {
        start: 0,
        end: i.length,
        startToken: void 0,
        endToken: void 0,
        source: {
          body: i,
          name: "graphql.web",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      }
    };
  }
}

// node_modules/gql.tada/dist/gql-tada.mjs
var a2 = 0;
var e2 = /* @__PURE__ */ new Set();
function initGraphQLTada() {
  function graphql2(t3, i2) {
    var o2 = parse3(t3).definitions;
    var s = /* @__PURE__ */ new Set();
    for (var f of i2 || []) {
      for (var u of f.definitions) {
        if (u.kind === e.FRAGMENT_DEFINITION && !s.has(u)) {
          o2.push(u);
          s.add(u);
        }
      }
    }
    var d;
    if ((d = o2[0].kind === e.FRAGMENT_DEFINITION) && o2[0].directives) {
      o2[0].directives = o2[0].directives.filter((r) => "_unmask" !== r.name.value);
    }
    var c;
    return {
      kind: e.DOCUMENT,
      definitions: o2,
      get loc() {
        if (!c && d) {
          var r = t3 + function concatLocSources(r2) {
            try {
              a2++;
              var n2 = "";
              for (var t4 of r2) {
                if (!e2.has(t4)) {
                  e2.add(t4);
                  var { loc: i3 } = t4;
                  if (i3) {
                    n2 += i3.source.body;
                  }
                }
              }
              return n2;
            } finally {
              if (0 == --a2) {
                e2.clear();
              }
            }
          }(i2 || []);
          return {
            start: 0,
            end: r.length,
            source: {
              body: r,
              name: "GraphQLTada",
              locationOffset: {
                line: 1,
                column: 1
              }
            }
          };
        }
        return c;
      },
      set loc(r) {
        c = r;
      }
    };
  }
  graphql2.scalar = function scalar(r, n2) {
    return n2;
  };
  graphql2.persisted = function persisted(n2, a3) {
    return {
      kind: e.DOCUMENT,
      definitions: a3 ? a3.definitions : [],
      documentId: n2
    };
  };
  return graphql2;
}
var t2 = initGraphQLTada();

// node_modules/@mysten/sui/dist/esm/graphql/schemas/latest/index.js
var graphql = initGraphQLTada();

// src/constant.ts
var PACKAGE_ID = "0xed4f3a658b14dfd565e1b8beecd7949f3966bbe13cdd2837d1afd6391227bca3";
var DIR_TYPE = PACKAGE_ID + "::perlite_sync::Directory";
var FILE_TYPE = PACKAGE_ID + "::perlite_sync::File";
var GRAPHQL_URL = "https://sui-testnet.mystenlabs.com/";
var NET_WORK = "testnet";

// src/server/vault-server.ts
var queryByAddressAndType = graphql(`
    query($address: SuiAddress!, $type: String!, $cursor: String) {
      address(address: $address) {
        objects(filter: { type: $type } first: 50 after: $cursor) {
          edges {
            node {
              contents {
                json
              }
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    }
`);
async function getVaultByAddress(address, vaultName) {
  let dirs = await getUserOwnDirectory(address, GRAPHQL_URL);
  if (dirs.length === 0) {
    return void 0;
  }
  let files = await getUserOwnFile(address, GRAPHQL_URL);
  const dirMap = /* @__PURE__ */ new Map();
  const parentMap = /* @__PURE__ */ new Map();
  const fileMap = /* @__PURE__ */ new Map();
  dirs.forEach((dir2) => {
    dirMap.set(dir2.id, dir2);
    if (!parentMap.has(dir2.parent)) {
      parentMap.set(dir2.parent, []);
    }
    parentMap.get(dir2.parent).push(dir2);
  });
  files.forEach((file) => {
    if (!fileMap.has(file.belong_dir)) {
      fileMap.set(file.belong_dir, []);
    }
    fileMap.get(file.belong_dir).push(file);
  });
  const buildDirectory = (dirId) => {
    const dir2 = dirMap.get(dirId);
    const childDirs = (parentMap.get(dirId) || []).sort((a3, b) => a3.name.localeCompare(b.name)).map((d) => buildDirectory(d.id));
    const files2 = (fileMap.get(dirId) || []).sort((a3, b) => a3.title.localeCompare(b.title));
    return {
      ...dir2,
      directories: childDirs,
      files: files2
    };
  };
  const rootDir = dirs.find((d) => d.is_root && d.name === vaultName);
  if (!rootDir) {
    return void 0;
  }
  const dir = buildDirectory(rootDir.id);
  if (dir) {
    return {
      id: dir.id,
      name: dir.name,
      directories: dir.directories,
      files: dir.files,
      created_at: rootDir.created_at,
      updated_at: rootDir.updated_at
    };
  } else {
    return void 0;
  }
}
async function getUserOwnDirectory(address, graphqlUrl) {
  const suiGraphQLClient = new SuiGraphQLClient({ url: graphqlUrl });
  const type2 = DIR_TYPE;
  console.log("\u67E5\u8BE2\u76EE\u5F55:", type2);
  let endCursor = null;
  const result = [];
  const parseDirData = (data) => {
    return data?.address?.objects?.edges.map((edge) => {
      const json = edge.node.contents?.json;
      return {
        id: json.id,
        name: json.name,
        parent: json.parent,
        is_root: json.is_root,
        created_at: new Date(json.created_at),
        updated_at: new Date(json.updated_at)
      };
    }) || [];
  };
  let hasNextPage = false;
  do {
    const currentPage = await suiGraphQLClient.query({
      query: queryByAddressAndType,
      variables: { address, type: type2, cursor: endCursor }
    });
    result.push(...parseDirData(currentPage.data));
    endCursor = currentPage.data?.address?.objects?.pageInfo?.endCursor;
    hasNextPage = currentPage.data?.address?.objects?.pageInfo?.hasNextPage;
  } while (hasNextPage);
  return result;
}
async function getUserOwnFile(address, graphqlUrl) {
  const suiGraphQLClient = new SuiGraphQLClient({ url: graphqlUrl });
  const type2 = FILE_TYPE;
  let endCursor = null;
  const result = [];
  const parseFileData = (data) => {
    return data?.address?.objects?.edges.map((edge) => {
      const json = edge.node.contents?.json;
      return {
        id: json.id,
        title: json.title,
        belong_dir: json.belong_dir,
        blob_id: json.blob_id,
        end_epoch: json.end_epoch,
        created_at: new Date(json.created_at),
        updated_at: new Date(json.updated_at)
      };
    }) || [];
  };
  let hasNextPage = false;
  do {
    const currentPage = await suiGraphQLClient.query({
      query: queryByAddressAndType,
      variables: { address, type: type2, cursor: endCursor }
    });
    result.push(...parseFileData(currentPage.data));
    endCursor = currentPage.data?.address?.objects?.pageInfo?.endCursor;
    hasNextPage = currentPage.data?.address?.objects?.pageInfo?.hasNextPage;
  } while (hasNextPage);
  return result;
}

// node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
  const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
  if (typeof typeSignature === "string") {
    switch (typeSignature) {
      case "address":
        return suiBcs.Address;
      case "bool":
        return suiBcs.Bool;
      case "u8":
        return suiBcs.U8;
      case "u16":
        return suiBcs.U16;
      case "u32":
        return suiBcs.U32;
      case "u64":
        return suiBcs.U64;
      case "u128":
        return suiBcs.U128;
      case "u256":
        return suiBcs.U256;
      default:
        throw new Error(`Unknown type signature ${typeSignature}`);
    }
  }
  if ("vector" in typeSignature) {
    if (typeSignature.vector === "u8") {
      return suiBcs.byteVector().transform({
        input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
        output: (val) => val
      });
    }
    const type2 = getPureBcsSchema(typeSignature.vector);
    return type2 ? suiBcs.vector(type2) : null;
  }
  if ("datatype" in typeSignature) {
    const pkg = normalizeSuiAddress(typeSignature.datatype.package);
    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
        const type2 = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
        return type2 ? suiBcs.vector(type2) : null;
      }
    }
    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizedTypeToMoveTypeSignature(type2) {
  if (typeof type2 === "object" && "Reference" in type2) {
    return {
      ref: "&",
      body: normalizedTypeToMoveTypeSignatureBody(type2.Reference)
    };
  }
  if (typeof type2 === "object" && "MutableReference" in type2) {
    return {
      ref: "&mut",
      body: normalizedTypeToMoveTypeSignatureBody(type2.MutableReference)
    };
  }
  return {
    ref: null,
    body: normalizedTypeToMoveTypeSignatureBody(type2)
  };
}
function normalizedTypeToMoveTypeSignatureBody(type2) {
  if (typeof type2 === "string") {
    switch (type2) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type2}`);
    }
  }
  if ("Vector" in type2) {
    return { vector: normalizedTypeToMoveTypeSignatureBody(type2.Vector) };
  }
  if ("Struct" in type2) {
    return {
      datatype: {
        package: type2.Struct.address,
        module: type2.Struct.module,
        type: type2.Struct.name,
        typeParameters: type2.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
      }
    };
  }
  if ("TypeParameter" in type2) {
    return { typeParameter: type2.TypeParameter };
  }
  throw new Error(`Unexpected type ${JSON.stringify(type2)}`);
}

// node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()
    }
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};

// node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var Commands = {
  MoveCall(input) {
    const [pkg, mod3 = "", fn = ""] = "target" in input ? input.target.split("::") : [input.package, input.module, input.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: pkg,
        module: mod3,
        function: fn,
        typeArguments: input.typeArguments ?? [],
        arguments: input.arguments ?? []
      }
    };
  },
  TransferObjects(objects, address) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: objects.map((o2) => parse2(ArgumentSchema, o2)),
        address: parse2(ArgumentSchema, address)
      }
    };
  },
  SplitCoins(coin, amounts) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: parse2(ArgumentSchema, coin),
        amounts: amounts.map((o2) => parse2(ArgumentSchema, o2))
      }
    };
  },
  MergeCoins(destination, sources) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: parse2(ArgumentSchema, destination),
        sources: sources.map((o2) => parse2(ArgumentSchema, o2))
      }
    };
  },
  Publish({
    modules,
    dependencies
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: modules.map(
          (module2) => typeof module2 === "string" ? module2 : toBase64(new Uint8Array(module2))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      }
    };
  },
  Upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: modules.map(
          (module2) => typeof module2 === "string" ? module2 : toBase64(new Uint8Array(module2))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        package: packageId,
        ticket: parse2(ArgumentSchema, ticket)
      }
    };
  },
  MakeMoveVec({
    type: type2,
    elements
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: type2 ?? null,
        elements: elements.map((o2) => parse2(ArgumentSchema, o2))
      }
    };
  },
  Intent({
    name: name2,
    inputs = {},
    data = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name: name2,
        inputs: Object.fromEntries(
          Object.entries(inputs).map(([key2, value2]) => [
            key2,
            Array.isArray(value2) ? value2.map((o2) => parse2(ArgumentSchema, o2)) : parse2(ArgumentSchema, value2)
          ])
        ),
        data
      }
    };
  }
};

// node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
  return union(
    Object.entries(options).map(([key2, value2]) => object({ [key2]: value2 }))
  );
}
var Argument2 = enumUnion({
  GasCoin: literal(true),
  Input: pipe(number(), integer()),
  Result: pipe(number(), integer()),
  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])
});
var GasData2 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRefSchema))
});
var ProgrammableMoveCall2 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument2)
});
var $Intent2 = object({
  name: string(),
  inputs: record(string(), union([Argument2, array(Argument2)])),
  data: record(string(), unknown())
});
var Command2 = enumUnion({
  MoveCall: ProgrammableMoveCall2,
  TransferObjects: object({
    objects: array(Argument2),
    address: Argument2
  }),
  SplitCoins: object({
    coin: Argument2,
    amounts: array(Argument2)
  }),
  MergeCoins: object({
    destination: Argument2,
    sources: array(Argument2)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument2)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument2
  }),
  $Intent: $Intent2
});
var ObjectArg3 = enumUnion({
  ImmOrOwnedObject: ObjectRefSchema,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRefSchema
});
var CallArg2 = enumUnion({
  Object: ObjectArg3,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64)),
    mutable: optional(nullable(boolean()))
  })
});
var TransactionExpiration4 = enumUnion({
  None: literal(true),
  Epoch: JsonU64
});
var SerializedTransactionDataV2Schema = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration4),
  gasData: GasData2,
  inputs: array(CallArg2),
  commands: array(Command2),
  digest: optional(nullable(string()))
});

// node_modules/@mysten/sui/dist/esm/jsonRpc/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_GAS = 5e10;
function jsonRpcClientResolveTransactionPlugin(client) {
  return async function resolveTransactionData(transactionData, options, next) {
    await normalizeInputs(transactionData, client);
    await resolveObjectReferences(transactionData, client);
    if (!options.onlyTransactionKind) {
      await setGasPrice(transactionData, client);
      await setGasBudget(transactionData, client);
      await setGasPayment(transactionData, client);
    }
    return await next();
  };
}
async function setGasPrice(transactionData, client) {
  if (!transactionData.gasConfig.price) {
    transactionData.gasConfig.price = String(await client.getReferenceGasPrice());
  }
}
async function setGasBudget(transactionData, client) {
  if (transactionData.gasConfig.budget) {
    return;
  }
  const dryRunResult = await client.dryRunTransactionBlock({
    transactionBlock: transactionData.build({
      overrides: {
        gasData: {
          budget: String(MAX_GAS),
          payment: []
        }
      }
    })
  });
  if (dryRunResult.effects.status.status !== "success") {
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
      { cause: dryRunResult }
    );
  }
  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);
  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
  transactionData.gasConfig.budget = String(
    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
  );
}
async function setGasPayment(transactionData, client) {
  if (!transactionData.gasConfig.payment) {
    const coins = await client.getCoins({
      owner: transactionData.gasConfig.owner || transactionData.sender,
      coinType: SUI_TYPE_ARG
    });
    const paymentCoins = coins.data.filter((coin) => {
      const matchingInput = transactionData.inputs.find((input) => {
        if (input.Object?.ImmOrOwnedObject) {
          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
        }
        return false;
      });
      return !matchingInput;
    }).map((coin) => ({
      objectId: coin.coinObjectId,
      digest: coin.digest,
      version: coin.version
    }));
    if (!paymentCoins.length) {
      throw new Error("No valid gas coins found for the transaction.");
    }
    transactionData.gasConfig.payment = paymentCoins.map(
      (payment) => parse2(ObjectRefSchema, payment)
    );
  }
}
async function resolveObjectReferences(transactionData, client) {
  const objectsToResolve = transactionData.inputs.filter((input) => {
    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);
  });
  const dedupedIds = [
    ...new Set(
      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))
    )
  ];
  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
  const resolved = (await Promise.all(
    objectChunks.map(
      (chunk2) => client.multiGetObjects({
        ids: chunk2,
        options: { showOwner: true }
      })
    )
  )).flat();
  const responsesById = new Map(
    dedupedIds.map((id, index) => {
      return [id, resolved[index]];
    })
  );
  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));
  if (invalidObjects.length) {
    throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
  }
  const objects = resolved.map((object2) => {
    if (object2.error || !object2.data) {
      throw new Error(`Failed to fetch object: ${object2.error}`);
    }
    const owner = object2.data.owner;
    const initialSharedVersion = owner && typeof owner === "object" ? "Shared" in owner ? owner.Shared.initial_shared_version : "ConsensusAddressOwner" in owner ? owner.ConsensusAddressOwner.start_version : null : null;
    return {
      objectId: object2.data.objectId,
      digest: object2.data.digest,
      version: object2.data.version,
      initialSharedVersion
    };
  });
  const objectsById = new Map(
    dedupedIds.map((id, index) => {
      return [id, objects[index]];
    })
  );
  for (const [index, input] of transactionData.inputs.entries()) {
    if (!input.UnresolvedObject) {
      continue;
    }
    let updated;
    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);
    const object2 = objectsById.get(id);
    if (input.UnresolvedObject.initialSharedVersion ?? object2?.initialSharedVersion) {
      updated = Inputs.SharedObjectRef({
        objectId: id,
        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object2?.initialSharedVersion,
        mutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index)
      });
    } else if (isUsedAsReceiving(transactionData, index)) {
      updated = Inputs.ReceivingRef(
        {
          objectId: id,
          digest: input.UnresolvedObject.digest ?? object2?.digest,
          version: input.UnresolvedObject.version ?? object2?.version
        }
      );
    }
    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({
      objectId: id,
      digest: input.UnresolvedObject.digest ?? object2?.digest,
      version: input.UnresolvedObject.version ?? object2?.version
    });
  }
}
async function normalizeInputs(transactionData, client) {
  const { inputs, commands } = transactionData;
  const moveCallsToResolve = [];
  const moveFunctionsToResolve = /* @__PURE__ */ new Set();
  commands.forEach((command) => {
    if (command.MoveCall) {
      if (command.MoveCall._argumentTypes) {
        return;
      }
      const inputs2 = command.MoveCall.arguments.map((arg) => {
        if (arg.$kind === "Input") {
          return transactionData.inputs[arg.Input];
        }
        return null;
      });
      const needsResolution = inputs2.some(
        (input) => input?.UnresolvedPure || input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== "boolean"
      );
      if (needsResolution) {
        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
        moveFunctionsToResolve.add(functionName);
        moveCallsToResolve.push(command.MoveCall);
      }
    }
  });
  const moveFunctionParameters = /* @__PURE__ */ new Map();
  if (moveFunctionsToResolve.size > 0) {
    await Promise.all(
      [...moveFunctionsToResolve].map(async (functionName) => {
        const [packageId, moduleId, functionId] = functionName.split("::");
        const def = await client.getNormalizedMoveFunction({
          package: packageId,
          module: moduleId,
          function: functionId
        });
        moveFunctionParameters.set(
          functionName,
          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))
        );
      })
    );
  }
  if (moveCallsToResolve.length) {
    await Promise.all(
      moveCallsToResolve.map(async (moveCall) => {
        const parameters = moveFunctionParameters.get(
          `${moveCall.package}::${moveCall.module}::${moveCall.function}`
        );
        if (!parameters) {
          return;
        }
        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));
        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;
        moveCall._argumentTypes = params;
      })
    );
  }
  commands.forEach((command) => {
    if (!command.MoveCall) {
      return;
    }
    const moveCall = command.MoveCall;
    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
    const params = moveCall._argumentTypes;
    if (!params) {
      return;
    }
    if (params.length !== command.MoveCall.arguments.length) {
      throw new Error(`Incorrect number of arguments for ${fnName}`);
    }
    params.forEach((param, i2) => {
      const arg = moveCall.arguments[i2];
      if (arg.$kind !== "Input")
        return;
      const input = inputs[arg.Input];
      if (!input.UnresolvedPure && !input.UnresolvedObject) {
        return;
      }
      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;
      const schema = getPureBcsSchema(param.body);
      if (schema) {
        arg.type = "pure";
        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
        return;
      }
      if (typeof inputValue !== "string") {
        throw new Error(
          `Expect the argument to be an object id string, got ${JSON.stringify(
            inputValue,
            null,
            2
          )}`
        );
      }
      arg.type = "object";
      const unresolvedObject = input.UnresolvedPure ? {
        $kind: "UnresolvedObject",
        UnresolvedObject: {
          objectId: inputValue
        }
      } : input;
      inputs[arg.Input] = unresolvedObject;
    });
  });
}
function isUsedAsMutable(transactionData, index) {
  let usedAsMutable = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
    }
    if (tx.$kind === "MakeMoveVec" || tx.$kind === "MergeCoins" || tx.$kind === "SplitCoins" || tx.$kind === "TransferObjects") {
      usedAsMutable = true;
    }
  });
  return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index) {
  let usedAsReceiving = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
    }
  });
  return usedAsReceiving;
}
function isReceivingType(type2) {
  if (typeof type2.body !== "object" || !("datatype" in type2.body)) {
    return false;
  }
  return type2.body.datatype.package === "0x2" && type2.body.datatype.module === "transfer" && type2.body.datatype.type === "Receiving";
}

// node_modules/@mysten/sui/dist/esm/transactions/resolve.js
function needsTransactionResolution(data, options) {
  if (data.inputs.some((input) => {
    return input.UnresolvedObject || input.UnresolvedPure;
  })) {
    return true;
  }
  if (!options.onlyTransactionKind) {
    if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {
      return true;
    }
  }
  return false;
}
async function resolveTransactionPlugin(transactionData, options, next) {
  normalizeRawArguments(transactionData);
  if (!needsTransactionResolution(transactionData, options)) {
    await validate(transactionData);
    return next();
  }
  const client = getClient(options);
  const plugin = client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client);
  return plugin(transactionData, options, async () => {
    await validate(transactionData);
    await next();
  });
}
function validate(transactionData) {
  transactionData.inputs.forEach((input, index) => {
    if (input.$kind !== "Object" && input.$kind !== "Pure") {
      throw new Error(
        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          input
        )}`
      );
    }
  });
}
function getClient(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}
function normalizeRawArguments(transactionData) {
  for (const command of transactionData.commands) {
    switch (command.$kind) {
      case "SplitCoins":
        command.SplitCoins.amounts.forEach((amount) => {
          normalizeRawArgument(amount, suiBcs.U64, transactionData);
        });
        break;
      case "TransferObjects":
        normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
        break;
    }
  }
}
function normalizeRawArgument(arg, schema, transactionData) {
  if (arg.$kind !== "Input") {
    return;
  }
  const input = transactionData.inputs[arg.Input];
  if (input.$kind !== "UnresolvedPure") {
    return;
  }
  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}

// node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
  function object2(value2) {
    return makeObject(value2);
  }
  object2.system = (options) => {
    const mutable = options?.mutable;
    if (mutable !== void 0) {
      return object2(
        Inputs.SharedObjectRef({
          objectId: "0x5",
          initialSharedVersion: 1,
          mutable
        })
      );
    }
    return object2({
      $kind: "UnresolvedObject",
      UnresolvedObject: {
        objectId: "0x5",
        initialSharedVersion: 1
      }
    });
  };
  object2.clock = () => object2(
    Inputs.SharedObjectRef({
      objectId: "0x6",
      initialSharedVersion: 1,
      mutable: false
    })
  );
  object2.random = () => object2({
    $kind: "UnresolvedObject",
    UnresolvedObject: {
      objectId: "0x8",
      mutable: false
    }
  });
  object2.denyList = (options) => {
    return object2({
      $kind: "UnresolvedObject",
      UnresolvedObject: {
        objectId: "0x403",
        mutable: options?.mutable
      }
    });
  };
  object2.option = ({ type: type2, value: value2 }) => (tx) => tx.moveCall({
    typeArguments: [type2],
    target: `0x1::option::${value2 === null ? "none" : "some"}`,
    arguments: value2 === null ? [] : [tx.object(value2)]
  });
  return object2;
}

// node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(typeOrSerializedValue, value2) {
    if (typeof typeOrSerializedValue === "string") {
      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value2));
    }
    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {
      return makePure(typeOrSerializedValue);
    }
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  pure.u8 = (value2) => makePure(suiBcs.U8.serialize(value2));
  pure.u16 = (value2) => makePure(suiBcs.U16.serialize(value2));
  pure.u32 = (value2) => makePure(suiBcs.U32.serialize(value2));
  pure.u64 = (value2) => makePure(suiBcs.U64.serialize(value2));
  pure.u128 = (value2) => makePure(suiBcs.U128.serialize(value2));
  pure.u256 = (value2) => makePure(suiBcs.U256.serialize(value2));
  pure.bool = (value2) => makePure(suiBcs.Bool.serialize(value2));
  pure.string = (value2) => makePure(suiBcs.String.serialize(value2));
  pure.address = (value2) => makePure(suiBcs.Address.serialize(value2));
  pure.id = pure.address;
  pure.vector = (type2, value2) => {
    return makePure(
      suiBcs.vector(pureBcsSchemaFromTypeName(type2)).serialize(value2)
    );
  };
  pure.option = (type2, value2) => {
    return makePure(suiBcs.option(pureBcsSchemaFromTypeName(type2)).serialize(value2));
  };
  return pure;
}

// node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if (arg.Object) {
    if (arg.Object.ImmOrOwnedObject) {
      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
    }
    if (arg.Object.Receiving) {
      return normalizeSuiAddress(arg.Object.Receiving.objectId);
    }
    return normalizeSuiAddress(arg.Object.SharedObject.objectId);
  }
  if (arg.UnresolvedObject) {
    return normalizeSuiAddress(arg.UnresolvedObject.objectId);
  }
  return void 0;
}

// node_modules/@mysten/sui/dist/esm/transactions/plugins/NamedPackagesPlugin.js
var cacheMap = /* @__PURE__ */ new WeakMap();
var namedPackagesPlugin = (options) => {
  let mvrClient;
  if (options) {
    const overrides = options.overrides ?? {
      packages: {},
      types: {}
    };
    if (!cacheMap.has(overrides)) {
      cacheMap.set(overrides, new ClientCache());
    }
    mvrClient = new MvrClient({
      cache: cacheMap.get(overrides),
      url: options.url,
      pageSize: options.pageSize,
      overrides
    });
  }
  return async (transactionData, buildOptions, next) => {
    const names = findNamesInTransaction(transactionData);
    if (names.types.length === 0 && names.packages.length === 0) {
      return next();
    }
    const resolved = await (mvrClient || getClient2(buildOptions).core.mvr).resolve({
      types: names.types,
      packages: names.packages
    });
    replaceNames(transactionData, resolved);
    await next();
  };
};
function getClient2(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}

// node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value2) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet6 = (obj, member, value2, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod3 = (obj, member, method) => (__accessCheck6(obj, member, "access private method"), method);
var _serializationPlugins;
var _buildPlugins;
var _intentResolvers;
var _inputSection;
var _commandSection;
var _availableResults;
var _pendingPromises;
var _added;
var _data;
var _Transaction_instances;
var fork_fn;
var addCommand_fn;
var addInput_fn;
var normalizeTransactionArgument_fn;
var resolveArgument_fn;
var prepareBuild_fn;
var runPlugins_fn;
var waitForPendingTasks_fn;
var sortCommandsAndInputs_fn;
function createTransactionResult(index, length = Infinity) {
  const baseResult = {
    $kind: "Result",
    get Result() {
      return typeof index === "function" ? index() : index;
    }
  };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    $kind: "NestedResult",
    get NestedResult() {
      return [typeof index === "function" ? index() : index, resultIndex];
    }
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i2 = 0;
          while (i2 < length) {
            yield nestedResultFor(i2);
            i2++;
          }
        };
      }
      if (typeof property === "symbol")
        return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0)
        return;
      return nestedResultFor(resultIndex);
    }
  });
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
  try {
    const target = globalThis;
    if (!target[TRANSACTION_REGISTRY_KEY]) {
      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
    }
    return target[TRANSACTION_REGISTRY_KEY];
  } catch {
    return modulePluginRegistry;
  }
}
var _Transaction = class _Transaction2 {
  constructor() {
    __privateAdd6(this, _Transaction_instances);
    __privateAdd6(this, _serializationPlugins);
    __privateAdd6(this, _buildPlugins);
    __privateAdd6(this, _intentResolvers, /* @__PURE__ */ new Map());
    __privateAdd6(this, _inputSection, []);
    __privateAdd6(this, _commandSection, []);
    __privateAdd6(this, _availableResults, /* @__PURE__ */ new Set());
    __privateAdd6(this, _pendingPromises, /* @__PURE__ */ new Set());
    __privateAdd6(this, _added, /* @__PURE__ */ new Map());
    __privateAdd6(this, _data);
    this.object = createObjectMethods(
      (value2) => {
        if (typeof value2 === "function") {
          return this.object(this.add(value2));
        }
        if (typeof value2 === "object" && is(ArgumentSchema, value2)) {
          return value2;
        }
        const id = getIdFromCallArg(value2);
        const inserted = __privateGet6(this, _data).inputs.find((i2) => id === getIdFromCallArg(i2));
        if (inserted?.Object?.SharedObject && typeof value2 === "object" && value2.Object?.SharedObject) {
          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value2.Object.SharedObject.mutable;
        }
        return inserted ? { $kind: "Input", Input: __privateGet6(this, _data).inputs.indexOf(inserted), type: "object" } : __privateMethod3(this, _Transaction_instances, addInput_fn).call(this, "object", typeof value2 === "string" ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: { objectId: normalizeSuiAddress(value2) }
        } : value2);
      }
    );
    const globalPlugins = getGlobalPluginRegistry();
    __privateSet6(this, _data, new TransactionDataBuilder());
    __privateSet6(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
    __privateSet6(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _Transaction2();
    __privateSet6(tx, _data, TransactionDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromBase64(serialized) : serialized
    ));
    __privateSet6(tx, _inputSection, __privateGet6(tx, _data).inputs.slice());
    __privateSet6(tx, _commandSection, __privateGet6(tx, _data).commands.slice());
    __privateSet6(tx, _availableResults, new Set(__privateGet6(tx, _commandSection).map((_, i2) => i2)));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(transaction) {
    const newTransaction = new _Transaction2();
    if (isTransaction(transaction)) {
      __privateSet6(newTransaction, _data, TransactionDataBuilder.restore(
        transaction.getData()
      ));
    } else if (typeof transaction !== "string" || !transaction.startsWith("{")) {
      __privateSet6(newTransaction, _data, TransactionDataBuilder.fromBytes(
        typeof transaction === "string" ? fromBase64(transaction) : transaction
      ));
    } else {
      __privateSet6(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));
    }
    __privateSet6(newTransaction, _inputSection, __privateGet6(newTransaction, _data).inputs.slice());
    __privateSet6(newTransaction, _commandSection, __privateGet6(newTransaction, _data).commands.slice());
    __privateSet6(newTransaction, _availableResults, new Set(__privateGet6(newTransaction, _commandSection).map((_, i2) => i2)));
    return newTransaction;
  }
  static registerGlobalSerializationPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().serializationPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalSerializationPlugin(name2) {
    getGlobalPluginRegistry().serializationPlugins.delete(name2);
  }
  static registerGlobalBuildPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().buildPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalBuildPlugin(name2) {
    getGlobalPluginRegistry().buildPlugins.delete(name2);
  }
  addSerializationPlugin(step) {
    __privateGet6(this, _serializationPlugins).push(step);
  }
  addBuildPlugin(step) {
    __privateGet6(this, _buildPlugins).push(step);
  }
  addIntentResolver(intent, resolver) {
    if (__privateGet6(this, _intentResolvers).has(intent) && __privateGet6(this, _intentResolvers).get(intent) !== resolver) {
      throw new Error(`Intent resolver for ${intent} already exists`);
    }
    __privateGet6(this, _intentResolvers).set(intent, resolver);
  }
  setSender(sender) {
    __privateGet6(this, _data).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet6(this, _data).sender) {
      __privateGet6(this, _data).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet6(this, _data).expiration = expiration ? parse2(TransactionExpiration2, expiration) : null;
  }
  setGasPrice(price) {
    __privateGet6(this, _data).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet6(this, _data).gasConfig.budget = String(budget);
  }
  setGasBudgetIfNotSet(budget) {
    if (__privateGet6(this, _data).gasData.budget == null) {
      __privateGet6(this, _data).gasConfig.budget = String(budget);
    }
  }
  setGasOwner(owner) {
    __privateGet6(this, _data).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet6(this, _data).gasConfig.payment = payments.map((payment) => parse2(ObjectRefSchema, payment));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return serializeV1TransactionData(__privateGet6(this, _data).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return __privateGet6(this, _data).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value2) => {
        if (isSerializedBcs(value2)) {
          return __privateMethod3(this, _Transaction_instances, addInput_fn).call(this, "pure", {
            $kind: "Pure",
            Pure: {
              bytes: value2.toBase64()
            }
          });
        }
        return __privateMethod3(this, _Transaction_instances, addInput_fn).call(this, "pure", is(NormalizedCallArg, value2) ? parse2(NormalizedCallArg, value2) : value2 instanceof Uint8Array ? Inputs.Pure(value2) : { $kind: "UnresolvedPure", UnresolvedPure: { value: value2 } });
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  add(command) {
    if (typeof command === "function") {
      if (__privateGet6(this, _added).has(command)) {
        return __privateGet6(this, _added).get(command);
      }
      const fork = __privateMethod3(this, _Transaction_instances, fork_fn).call(this);
      const result = command(fork);
      if (!(result && typeof result === "object" && "then" in result)) {
        __privateSet6(this, _availableResults, __privateGet6(fork, _availableResults));
        __privateGet6(this, _added).set(command, result);
        return result;
      }
      const placeholder = __privateMethod3(this, _Transaction_instances, addCommand_fn).call(this, {
        $kind: "$Intent",
        $Intent: {
          name: "AsyncTransactionThunk",
          inputs: {},
          data: {
            resultIndex: __privateGet6(this, _data).commands.length,
            result: null
          }
        }
      });
      __privateGet6(this, _pendingPromises).add(
        Promise.resolve(result).then((result2) => {
          placeholder.$Intent.data.result = result2;
        })
      );
      const txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);
      __privateGet6(this, _added).set(command, txResult);
      return txResult;
    } else {
      __privateMethod3(this, _Transaction_instances, addCommand_fn).call(this, command);
    }
    return createTransactionResult(__privateGet6(this, _data).commands.length - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    const command = Commands.SplitCoins(
      typeof coin === "string" ? this.object(coin) : __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, coin),
      amounts.map(
        (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)
      )
    );
    __privateMethod3(this, _Transaction_instances, addCommand_fn).call(this, command);
    return createTransactionResult(__privateGet6(this, _data).commands.length - 1, amounts.length);
  }
  mergeCoins(destination, sources) {
    return this.add(
      Commands.MergeCoins(
        this.object(destination),
        sources.map((src) => this.object(src))
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Commands.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return this.add(
      Commands.Upgrade({
        modules,
        dependencies,
        package: packageId,
        ticket: this.object(ticket)
      })
    );
  }
  moveCall({
    arguments: args,
    ...input
  }) {
    return this.add(
      Commands.MoveCall({
        ...input,
        arguments: args?.map((arg) => __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Commands.TransferObjects(
        objects.map((obj) => this.object(obj)),
        typeof address === "string" ? this.pure.address(address) : __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type: type2,
    elements
  }) {
    return this.add(
      Commands.MakeMoveVec({
        type: type2,
        elements: elements.map((obj) => this.object(obj))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(serializeV1TransactionData(__privateGet6(this, _data).snapshot()));
  }
  async toJSON(options = {}) {
    await this.prepareForSerialization(options);
    const fullyResolved = this.isFullyResolved();
    return JSON.stringify(
      parse2(
        SerializedTransactionDataV2Schema,
        fullyResolved ? {
          ...__privateGet6(this, _data).snapshot(),
          digest: __privateGet6(this, _data).getDigest()
        } : __privateGet6(this, _data).snapshot()
      ),
      (_key, value2) => typeof value2 === "bigint" ? value2.toString() : value2,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes = await this.build(buildOptions);
    return signer.signTransaction(bytes);
  }
  /**
   *  Ensures that:
   *  - All objects have been fully resolved to a specific version
   *  - All pure inputs have been serialized to bytes
   *  - All async thunks have been fully resolved
   *  - All transaction intents have been resolved
   * 	- The gas payment, budget, and price have been set
   *  - The transaction sender has been set
   *
   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)
   */
  isFullyResolved() {
    if (!__privateGet6(this, _data).sender) {
      return false;
    }
    if (__privateGet6(this, _pendingPromises).size > 0) {
      return false;
    }
    if (__privateGet6(this, _data).commands.some((cmd) => cmd.$Intent)) {
      return false;
    }
    if (needsTransactionResolution(__privateGet6(this, _data), {})) {
      return false;
    }
    return true;
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod3(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet6(this, _data).build({
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod3(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet6(this, _data).getDigest();
  }
  async prepareForSerialization(options) {
    await __privateMethod3(this, _Transaction_instances, waitForPendingTasks_fn).call(this);
    __privateMethod3(this, _Transaction_instances, sortCommandsAndInputs_fn).call(this);
    const intents = /* @__PURE__ */ new Set();
    for (const command of __privateGet6(this, _data).commands) {
      if (command.$Intent) {
        intents.add(command.$Intent.name);
      }
    }
    const steps = [...__privateGet6(this, _serializationPlugins)];
    for (const intent of intents) {
      if (options.supportedIntents?.includes(intent)) {
        continue;
      }
      if (!__privateGet6(this, _intentResolvers).has(intent)) {
        throw new Error(`Missing intent resolver for ${intent}`);
      }
      steps.push(__privateGet6(this, _intentResolvers).get(intent));
    }
    steps.push(namedPackagesPlugin());
    await __privateMethod3(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
  }
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_inputSection = /* @__PURE__ */ new WeakMap();
_commandSection = /* @__PURE__ */ new WeakMap();
_availableResults = /* @__PURE__ */ new WeakMap();
_pendingPromises = /* @__PURE__ */ new WeakMap();
_added = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
fork_fn = function() {
  const fork = new _Transaction();
  __privateSet6(fork, _data, __privateGet6(this, _data));
  __privateSet6(fork, _serializationPlugins, __privateGet6(this, _serializationPlugins));
  __privateSet6(fork, _buildPlugins, __privateGet6(this, _buildPlugins));
  __privateSet6(fork, _intentResolvers, __privateGet6(this, _intentResolvers));
  __privateSet6(fork, _pendingPromises, __privateGet6(this, _pendingPromises));
  __privateSet6(fork, _availableResults, new Set(__privateGet6(this, _availableResults)));
  __privateSet6(fork, _added, __privateGet6(this, _added));
  __privateGet6(this, _inputSection).push(__privateGet6(fork, _inputSection));
  __privateGet6(this, _commandSection).push(__privateGet6(fork, _commandSection));
  return fork;
};
addCommand_fn = function(command) {
  const resultIndex = __privateGet6(this, _data).commands.length;
  __privateGet6(this, _commandSection).push(command);
  __privateGet6(this, _availableResults).add(resultIndex);
  __privateGet6(this, _data).commands.push(command);
  __privateGet6(this, _data).mapCommandArguments(resultIndex, (arg) => {
    if (arg.$kind === "Result" && !__privateGet6(this, _availableResults).has(arg.Result)) {
      throw new Error(
        `Result { Result: ${arg.Result} } is not available to use in the current transaction`
      );
    }
    if (arg.$kind === "NestedResult" && !__privateGet6(this, _availableResults).has(arg.NestedResult[0])) {
      throw new Error(
        `Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`
      );
    }
    if (arg.$kind === "Input" && arg.Input >= __privateGet6(this, _data).inputs.length) {
      throw new Error(
        `Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`
      );
    }
    return arg;
  });
  return command;
};
addInput_fn = function(type2, input) {
  __privateGet6(this, _inputSection).push(input);
  return __privateGet6(this, _data).addInput(type2, input);
};
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
  if (typeof arg === "function") {
    const resolved = this.add(arg);
    if (typeof resolved === "function") {
      return __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, resolved);
    }
    return parse2(ArgumentSchema, resolved);
  }
  return parse2(ArgumentSchema, arg);
};
prepareBuild_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet6(this, _data).sender) {
    throw new Error("Missing transaction sender");
  }
  await __privateMethod3(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet6(this, _buildPlugins), resolveTransactionPlugin], options);
};
runPlugins_fn = async function(plugins, options) {
  try {
    const createNext = (i2) => {
      if (i2 >= plugins.length) {
        return () => {
        };
      }
      const plugin = plugins[i2];
      return async () => {
        const next = createNext(i2 + 1);
        let calledNext = false;
        let nextResolved = false;
        await plugin(__privateGet6(this, _data), options, async () => {
          if (calledNext) {
            throw new Error(`next() was call multiple times in TransactionPlugin ${i2}`);
          }
          calledNext = true;
          await next();
          nextResolved = true;
        });
        if (!calledNext) {
          throw new Error(`next() was not called in TransactionPlugin ${i2}`);
        }
        if (!nextResolved) {
          throw new Error(`next() was not awaited in TransactionPlugin ${i2}`);
        }
      };
    };
    await createNext(0)();
  } finally {
    __privateSet6(this, _inputSection, __privateGet6(this, _data).inputs.slice());
    __privateSet6(this, _commandSection, __privateGet6(this, _data).commands.slice());
  }
};
waitForPendingTasks_fn = async function() {
  while (__privateGet6(this, _pendingPromises).size > 0) {
    const newPromise = Promise.all(__privateGet6(this, _pendingPromises));
    __privateGet6(this, _pendingPromises).clear();
    __privateGet6(this, _pendingPromises).add(newPromise);
    await newPromise;
    __privateGet6(this, _pendingPromises).delete(newPromise);
  }
};
sortCommandsAndInputs_fn = function() {
  const unorderedCommands = __privateGet6(this, _data).commands;
  const unorderedInputs = __privateGet6(this, _data).inputs;
  const orderedCommands = __privateGet6(this, _commandSection).flat(Infinity);
  const orderedInputs = __privateGet6(this, _inputSection).flat(Infinity);
  if (orderedCommands.length !== unorderedCommands.length) {
    throw new Error("Unexpected number of commands found in transaction data");
  }
  if (orderedInputs.length !== unorderedInputs.length) {
    throw new Error("Unexpected number of inputs found in transaction data");
  }
  const filteredCommands = orderedCommands.filter(
    (cmd) => cmd.$Intent?.name !== "AsyncTransactionThunk"
  );
  __privateGet6(this, _data).commands = filteredCommands;
  __privateGet6(this, _data).inputs = orderedInputs;
  __privateSet6(this, _commandSection, filteredCommands);
  __privateSet6(this, _inputSection, orderedInputs);
  __privateSet6(this, _availableResults, new Set(filteredCommands.map((_, i2) => i2)));
  function getOriginalIndex(index) {
    const command = unorderedCommands[index];
    if (command.$Intent?.name === "AsyncTransactionThunk") {
      const result = command.$Intent.data.result;
      if (result == null) {
        throw new Error("AsyncTransactionThunk has not been resolved");
      }
      return getOriginalIndex(result.Result);
    }
    const updated = filteredCommands.indexOf(command);
    if (updated === -1) {
      throw new Error("Unable to find original index for command");
    }
    return updated;
  }
  __privateGet6(this, _data).mapArguments((arg) => {
    if (arg.$kind === "Input") {
      const updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);
      if (updated === -1) {
        throw new Error("Input has not been resolved");
      }
      return { ...arg, Input: updated };
    } else if (arg.$kind === "Result") {
      const updated = getOriginalIndex(arg.Result);
      return { ...arg, Result: updated };
    } else if (arg.$kind === "NestedResult") {
      const updated = getOriginalIndex(arg.NestedResult[0]);
      return { ...arg, NestedResult: [updated, arg.NestedResult[1]] };
    }
    return arg;
  });
  for (const [i2, cmd] of unorderedCommands.entries()) {
    if (cmd.$Intent?.name === "AsyncTransactionThunk") {
      try {
        cmd.$Intent.data.resultIndex = getOriginalIndex(i2);
      } catch {
      }
    }
  }
};
var Transaction = _Transaction;

// node_modules/@mysten/sui/dist/esm/jsonRpc/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// node_modules/@mysten/sui/dist/esm/jsonRpc/rpc-websocket-client.js
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value2) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet7 = (obj, member, value2, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod4 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet7(obj, member, value2, setter);
  },
  get _() {
    return __privateGet7(obj, member, getter);
  }
});
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _WebsocketClient_instances;
var setupWebSocket_fn;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd7(this, _WebsocketClient_instances);
    __privateAdd7(this, _requestId, 0);
    __privateAdd7(this, _disconnects, 0);
    __privateAdd7(this, _webSocket, null);
    __privateAdd7(this, _connectionPromise, null);
    __privateAdd7(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd7(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params, signal) {
    const webSocket = await __privateMethod4(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet7(this, _requestId, __privateGet7(this, _requestId) + 1);
      __privateGet7(this, _pendingRequests).set(__privateGet7(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet7(this, _pendingRequests).delete(__privateGet7(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      signal?.addEventListener("abort", () => {
        __privateGet7(this, _pendingRequests).delete(__privateGet7(this, _requestId));
        reject(signal.reason);
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet7(this, _requestId), method, params }));
    }).then(({ error: error2, result }) => {
      if (error2) {
        throw new JsonRpcError(error2.message, error2.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet7(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_WebsocketClient_instances = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet7(this, _connectionPromise)) {
    return __privateGet7(this, _connectionPromise);
  }
  __privateSet7(this, _connectionPromise, new Promise((resolve) => {
    __privateGet7(this, _webSocket)?.close();
    __privateSet7(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet7(this, _webSocket).addEventListener("open", () => {
      __privateSet7(this, _disconnects, 0);
      resolve(__privateGet7(this, _webSocket));
    });
    __privateGet7(this, _webSocket).addEventListener("close", () => {
      __privateWrapper(this, _disconnects)._++;
      if (__privateGet7(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod4(this, _WebsocketClient_instances, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet7(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error2) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error2 }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet7(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet7(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet7(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet7(this, _connectionPromise);
};
reconnect_fn = async function() {
  __privateGet7(this, _webSocket)?.close();
  __privateSet7(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet7(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null)
      return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params,
      this.input.signal
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// node_modules/@mysten/sui/dist/esm/jsonRpc/http-transport.js
var __typeError8 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError8("Cannot " + msg);
var __privateGet8 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd8 = (obj, member, value2) => member.has(obj) ? __typeError8("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet8 = (obj, member, value2, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod5 = (obj, member, method) => (__accessCheck8(obj, member, "access private method"), method);
var _requestId2;
var _options;
var _websocketClient;
var _JsonRpcHTTPTransport_instances;
var getWebsocketClient_fn;
var JsonRpcHTTPTransport = class {
  constructor(options) {
    __privateAdd8(this, _JsonRpcHTTPTransport_instances);
    __privateAdd8(this, _requestId2, 0);
    __privateAdd8(this, _options);
    __privateAdd8(this, _websocketClient);
    __privateSet8(this, _options, options);
  }
  fetch(input, init) {
    const fetchFn = __privateGet8(this, _options).fetch ?? fetch;
    if (!fetchFn) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetchFn(input, init);
  }
  async request(input) {
    __privateSet8(this, _requestId2, __privateGet8(this, _requestId2) + 1);
    const res = await this.fetch(__privateGet8(this, _options).rpc?.url ?? __privateGet8(this, _options).url, {
      method: "POST",
      signal: input.signal,
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        "Client-Request-Method": input.method,
        ...__privateGet8(this, _options).rpc?.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet8(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod5(this, _JsonRpcHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);
    if (input.signal) {
      input.signal.throwIfAborted();
      input.signal.addEventListener("abort", () => {
        unsubscribe();
      });
    }
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_JsonRpcHTTPTransport_instances = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  if (!__privateGet8(this, _websocketClient)) {
    const WebSocketConstructor = __privateGet8(this, _options).WebSocketConstructor ?? WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet8(this, _websocketClient, new WebsocketClient(
      __privateGet8(this, _options).websocket?.url ?? __privateGet8(this, _options).url,
      {
        WebSocketConstructor,
        ...__privateGet8(this, _options).websocket
      }
    ));
  }
  return __privateGet8(this, _websocketClient);
};

// node_modules/@mysten/sui/dist/esm/client/network.js
function getFullnodeUrl(network) {
  switch (network) {
    case "mainnet":
      return "https://fullnode.mainnet.sui.io:443";
    case "testnet":
      return "https://fullnode.testnet.sui.io:443";
    case "devnet":
      return "https://fullnode.devnet.sui.io:443";
    case "localnet":
      return "http://127.0.0.1:9000";
    default:
      throw new Error(`Unknown network: ${network}`);
  }
}

// node_modules/@mysten/sui/dist/esm/jsonRpc/core.js
var __typeError9 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck9 = (obj, member, msg) => member.has(obj) || __typeError9("Cannot " + msg);
var __privateGet9 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd9 = (obj, member, value2) => member.has(obj) ? __typeError9("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet9 = (obj, member, value2, setter) => (__accessCheck9(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _jsonRpcClient;
var JSONRpcCoreClient = class extends Experimental_CoreClient {
  constructor({
    jsonRpcClient,
    mvr
  }) {
    super({ network: jsonRpcClient.network, base: jsonRpcClient, mvr });
    __privateAdd9(this, _jsonRpcClient);
    __privateSet9(this, _jsonRpcClient, jsonRpcClient);
  }
  async getObjects(options) {
    const batches = chunk(options.objectIds, 50);
    const results = [];
    for (const batch of batches) {
      const objects = await __privateGet9(this, _jsonRpcClient).multiGetObjects({
        ids: batch,
        options: {
          showOwner: true,
          showType: true,
          showBcs: true,
          showPreviousTransaction: true
        },
        signal: options.signal
      });
      for (const [idx, object2] of objects.entries()) {
        if (object2.error) {
          results.push(ObjectError.fromResponse(object2.error, batch[idx]));
        } else {
          results.push(parseObject(object2.data));
        }
      }
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateGet9(this, _jsonRpcClient).getOwnedObjects({
      owner: options.address,
      limit: options.limit,
      cursor: options.cursor,
      options: {
        showOwner: true,
        showType: true,
        showBcs: true,
        showPreviousTransaction: true
      },
      filter: options.type ? { StructType: options.type } : null,
      signal: options.signal
    });
    return {
      objects: objects.data.map((result) => {
        if (result.error) {
          throw ObjectError.fromResponse(result.error);
        }
        return parseObject(result.data);
      }),
      hasNextPage: objects.hasNextPage,
      cursor: objects.nextCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateGet9(this, _jsonRpcClient).getCoins({
      owner: options.address,
      coinType: options.coinType,
      limit: options.limit,
      cursor: options.cursor,
      signal: options.signal
    });
    return {
      objects: coins.data.map((coin) => {
        return {
          id: coin.coinObjectId,
          version: coin.version,
          digest: coin.digest,
          balance: coin.balance,
          type: `0x2::coin::Coin<${coin.coinType}>`,
          content: Promise.resolve(
            Coin.serialize({
              id: coin.coinObjectId,
              balance: {
                value: coin.balance
              }
            }).toBytes()
          ),
          owner: {
            $kind: "ObjectOwner",
            ObjectOwner: options.address
          },
          previousTransaction: coin.previousTransaction
        };
      }),
      hasNextPage: coins.hasNextPage,
      cursor: coins.nextCursor ?? null
    };
  }
  async getBalance(options) {
    const balance = await __privateGet9(this, _jsonRpcClient).getBalance({
      owner: options.address,
      coinType: options.coinType,
      signal: options.signal
    });
    return {
      balance: {
        coinType: balance.coinType,
        balance: balance.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateGet9(this, _jsonRpcClient).getAllBalances({
      owner: options.address,
      signal: options.signal
    });
    return {
      balances: balances.map((balance) => ({
        coinType: balance.coinType,
        balance: balance.totalBalance
      })),
      hasNextPage: false,
      cursor: null
    };
  }
  async getTransaction(options) {
    const transaction = await __privateGet9(this, _jsonRpcClient).getTransactionBlock({
      digest: options.digest,
      options: {
        showRawInput: true,
        showObjectChanges: true,
        showRawEffects: true,
        showEvents: true,
        showEffects: true,
        showBalanceChanges: true
      },
      signal: options.signal
    });
    return {
      transaction: parseTransaction2(transaction)
    };
  }
  async executeTransaction(options) {
    const transaction = await __privateGet9(this, _jsonRpcClient).executeTransactionBlock({
      transactionBlock: options.transaction,
      signature: options.signatures,
      options: {
        showRawEffects: true,
        showEvents: true,
        showObjectChanges: true,
        showRawInput: true,
        showEffects: true,
        showBalanceChanges: true
      },
      signal: options.signal
    });
    return {
      transaction: parseTransaction2(transaction)
    };
  }
  async dryRunTransaction(options) {
    const tx = Transaction.from(options.transaction);
    const result = await __privateGet9(this, _jsonRpcClient).dryRunTransactionBlock({
      transactionBlock: options.transaction,
      signal: options.signal
    });
    const { effects, objectTypes } = parseTransactionEffectsJson({
      effects: result.effects,
      objectChanges: result.objectChanges
    });
    return {
      transaction: {
        digest: await tx.getDigest(),
        epoch: null,
        effects,
        objectTypes: Promise.resolve(objectTypes),
        signatures: [],
        transaction: parseTransactionBcs(options.transaction),
        balanceChanges: result.balanceChanges.map((change) => ({
          coinType: change.coinType,
          address: parseOwnerAddress(change.owner),
          amount: change.amount
        }))
      }
    };
  }
  async getReferenceGasPrice(options) {
    const referenceGasPrice = await __privateGet9(this, _jsonRpcClient).getReferenceGasPrice({
      signal: options?.signal
    });
    return {
      referenceGasPrice: String(referenceGasPrice)
    };
  }
  async getDynamicFields(options) {
    const dynamicFields = await __privateGet9(this, _jsonRpcClient).getDynamicFields({
      parentId: options.parentId,
      limit: options.limit,
      cursor: options.cursor
    });
    return {
      dynamicFields: dynamicFields.data.map((dynamicField) => {
        return {
          id: dynamicField.objectId,
          type: dynamicField.objectType,
          name: {
            type: dynamicField.name.type,
            bcs: fromBase64(dynamicField.bcsName)
          }
        };
      }),
      hasNextPage: dynamicFields.hasNextPage,
      cursor: dynamicFields.nextCursor
    };
  }
  async verifyZkLoginSignature(options) {
    const result = await __privateGet9(this, _jsonRpcClient).verifyZkLoginSignature({
      bytes: options.bytes,
      signature: options.signature,
      intentScope: options.intentScope,
      author: options.author
    });
    return {
      success: result.success,
      errors: result.errors
    };
  }
  async defaultNameServiceName(options) {
    const name2 = (await __privateGet9(this, _jsonRpcClient).resolveNameServiceNames(options)).data[0];
    return {
      data: {
        name: name2
      }
    };
  }
  resolveTransactionPlugin() {
    return jsonRpcClientResolveTransactionPlugin(__privateGet9(this, _jsonRpcClient));
  }
  async getMoveFunction(options) {
    const result = await __privateGet9(this, _jsonRpcClient).getNormalizedMoveFunction({
      package: (await this.mvr.resolvePackage({ package: options.packageId })).package,
      module: options.moduleName,
      function: options.name
    });
    return {
      function: {
        packageId: normalizeSuiAddress(options.packageId),
        moduleName: options.moduleName,
        name: options.name,
        visibility: parseVisibility(result.visibility),
        isEntry: result.isEntry,
        typeParameters: result.typeParameters.map((abilities) => ({
          isPhantom: false,
          constraints: parseAbilities(abilities)
        })),
        parameters: result.parameters.map((param) => parseNormalizedSuiMoveType2(param)),
        returns: result.return.map((ret) => parseNormalizedSuiMoveType2(ret))
      }
    };
  }
};
_jsonRpcClient = /* @__PURE__ */ new WeakMap();
function parseObject(object2) {
  return {
    id: object2.objectId,
    version: object2.version,
    digest: object2.digest,
    type: object2.type,
    content: Promise.resolve(
      object2.bcs?.dataType === "moveObject" ? fromBase64(object2.bcs.bcsBytes) : new Uint8Array()
    ),
    owner: parseOwner(object2.owner),
    previousTransaction: object2.previousTransaction ?? null
  };
}
function parseOwner(owner) {
  if (owner === "Immutable") {
    return {
      $kind: "Immutable",
      Immutable: true
    };
  }
  if ("ConsensusAddressOwner" in owner) {
    return {
      $kind: "ConsensusAddressOwner",
      ConsensusAddressOwner: {
        owner: owner.ConsensusAddressOwner.owner,
        startVersion: owner.ConsensusAddressOwner.start_version
      }
    };
  }
  if ("AddressOwner" in owner) {
    return {
      $kind: "AddressOwner",
      AddressOwner: owner.AddressOwner
    };
  }
  if ("ObjectOwner" in owner) {
    return {
      $kind: "ObjectOwner",
      ObjectOwner: owner.ObjectOwner
    };
  }
  if ("Shared" in owner) {
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: owner.Shared.initial_shared_version
      }
    };
  }
  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseOwnerAddress(owner) {
  if (owner === "Immutable") {
    return null;
  }
  if ("ConsensusAddressOwner" in owner) {
    return owner.ConsensusAddressOwner.owner;
  }
  if ("AddressOwner" in owner) {
    return owner.AddressOwner;
  }
  if ("ObjectOwner" in owner) {
    return owner.ObjectOwner;
  }
  if ("Shared" in owner) {
    return null;
  }
  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseTransaction2(transaction) {
  const parsedTx = suiBcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction))[0];
  const objectTypes = {};
  transaction.objectChanges?.forEach((change) => {
    if (change.type !== "published") {
      objectTypes[change.objectId] = change.objectType;
    }
  });
  const bytes = suiBcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes();
  const data = TransactionDataBuilder.restore({
    version: 2,
    sender: parsedTx.intentMessage.value.V1.sender,
    expiration: parsedTx.intentMessage.value.V1.expiration,
    gasData: parsedTx.intentMessage.value.V1.gasData,
    inputs: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,
    commands: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction.commands
  });
  return {
    digest: transaction.digest,
    epoch: transaction.effects?.executedEpoch ?? null,
    effects: parseTransactionEffectsBcs(new Uint8Array(transaction.rawEffects)),
    objectTypes: Promise.resolve(objectTypes),
    transaction: {
      ...data,
      bcs: bytes
    },
    signatures: parsedTx.txSignatures,
    balanceChanges: transaction.balanceChanges?.map((change) => ({
      coinType: change.coinType,
      address: parseOwnerAddress(change.owner),
      amount: change.amount
    })) ?? []
  };
}
function parseTransactionEffectsJson({
  bytes,
  effects,
  objectChanges
}) {
  const changedObjects = [];
  const unchangedConsensusObjects = [];
  const objectTypes = {};
  objectChanges?.forEach((change) => {
    switch (change.type) {
      case "published":
        changedObjects.push({
          id: change.packageId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "PackageWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: null,
          idOperation: "Created"
        });
        break;
      case "transferred":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: change.digest,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: change.sender
          },
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.recipient),
          idOperation: "None"
        });
        objectTypes[change.objectId] = change.objectType;
        break;
      case "mutated":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.previousVersion,
          inputDigest: null,
          inputOwner: parseOwner(change.owner),
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.owner),
          idOperation: "None"
        });
        objectTypes[change.objectId] = change.objectType;
        break;
      case "deleted":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: effects.deleted?.find((d) => d.objectId === change.objectId)?.digest ?? null,
          inputOwner: null,
          outputState: "DoesNotExist",
          outputVersion: null,
          outputDigest: null,
          outputOwner: null,
          idOperation: "Deleted"
        });
        objectTypes[change.objectId] = change.objectType;
        break;
      case "wrapped":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: null,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: change.sender
          },
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: effects.wrapped?.find((w) => w.objectId === change.objectId)?.digest ?? null,
          outputOwner: {
            $kind: "ObjectOwner",
            ObjectOwner: change.sender
          },
          idOperation: "None"
        });
        objectTypes[change.objectId] = change.objectType;
        break;
      case "created":
        changedObjects.push({
          id: change.objectId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.owner),
          idOperation: "Created"
        });
        objectTypes[change.objectId] = change.objectType;
        break;
    }
  });
  return {
    objectTypes,
    effects: {
      bcs: bytes ?? null,
      digest: effects.transactionDigest,
      version: 2,
      status: effects.status.status === "success" ? { success: true, error: null } : { success: false, error: effects.status.error },
      gasUsed: effects.gasUsed,
      transactionDigest: effects.transactionDigest,
      gasObject: {
        id: effects.gasObject?.reference.objectId,
        inputState: "Exists",
        inputVersion: null,
        inputDigest: null,
        inputOwner: null,
        outputState: "ObjectWrite",
        outputVersion: effects.gasObject.reference.version,
        outputDigest: effects.gasObject.reference.digest,
        outputOwner: parseOwner(effects.gasObject.owner),
        idOperation: "None"
      },
      eventsDigest: effects.eventsDigest ?? null,
      dependencies: effects.dependencies ?? [],
      lamportVersion: effects.gasObject.reference.version,
      changedObjects,
      unchangedConsensusObjects,
      auxiliaryDataDigest: null
    }
  };
}
var Balance = suiBcs.struct("Balance", {
  value: suiBcs.u64()
});
var Coin = suiBcs.struct("Coin", {
  id: suiBcs.Address,
  balance: Balance
});
function parseNormalizedSuiMoveType2(type2) {
  if (typeof type2 !== "string") {
    if ("Reference" in type2) {
      return {
        reference: "immutable",
        body: parseNormalizedSuiMoveTypeBody2(type2.Reference)
      };
    }
    if ("MutableReference" in type2) {
      return {
        reference: "mutable",
        body: parseNormalizedSuiMoveTypeBody2(type2.MutableReference)
      };
    }
  }
  return {
    reference: null,
    body: parseNormalizedSuiMoveTypeBody2(type2)
  };
}
function parseNormalizedSuiMoveTypeBody2(type2) {
  switch (type2) {
    case "Address":
      return { $kind: "address" };
    case "Bool":
      return { $kind: "bool" };
    case "U8":
      return { $kind: "u8" };
    case "U16":
      return { $kind: "u16" };
    case "U32":
      return { $kind: "u32" };
    case "U64":
      return { $kind: "u64" };
    case "U128":
      return { $kind: "u128" };
    case "U256":
      return { $kind: "u256" };
  }
  if (typeof type2 === "string") {
    throw new Error(`Unknown type: ${type2}`);
  }
  if ("Vector" in type2) {
    return {
      $kind: "vector",
      vector: parseNormalizedSuiMoveTypeBody2(type2.Vector)
    };
  }
  if ("Struct" in type2) {
    return {
      $kind: "datatype",
      datatype: {
        typeName: `${normalizeSuiAddress(type2.Struct.address)}::${type2.Struct.module}::${type2.Struct.name}`,
        typeParameters: type2.Struct.typeArguments.map((t3) => parseNormalizedSuiMoveTypeBody2(t3))
      }
    };
  }
  if ("TypeParameter" in type2) {
    return {
      $kind: "typeParameter",
      index: type2.TypeParameter
    };
  }
  throw new Error(`Unknown type: ${JSON.stringify(type2)}`);
}
function parseAbilities(abilitySet) {
  return abilitySet.abilities.map((ability) => {
    switch (ability) {
      case "Copy":
        return "copy";
      case "Drop":
        return "drop";
      case "Store":
        return "store";
      case "Key":
        return "key";
      default:
        return "unknown";
    }
  });
}
function parseVisibility(visibility) {
  switch (visibility) {
    case "Public":
      return "public";
    case "Private":
      return "private";
    case "Friend":
      return "friend";
    default:
      return "unknown";
  }
}

// node_modules/@mysten/sui/dist/esm/jsonRpc/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiJsonRpcClient = class extends Experimental_BaseClient {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    super({ network: options.network ?? "unknown" });
    this.jsonRpc = this;
    this.transport = options.transport ?? new JsonRpcHTTPTransport({ url: options.url });
    this.core = new JSONRpcCoreClient({
      jsonRpcClient: this,
      mvr: options.mvr
    });
  }
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  async getRpcApiVersion({ signal } = {}) {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: [],
      signal
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins({
    coinType,
    owner,
    cursor,
    limit,
    signal
  }) {
    if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
      throw new Error("Invalid Sui address");
    }
    if (coinType && hasMvrName(coinType)) {
      coinType = (await this.core.mvr.resolveType({
        type: coinType
      })).type;
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [owner, coinType, cursor, limit],
      signal
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance({ owner, coinType, signal }) {
    if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
      throw new Error("Invalid Sui address");
    }
    if (coinType && hasMvrName(coinType)) {
      coinType = (await this.core.mvr.resolveType({
        type: coinType
      })).type;
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [owner, coinType],
      signal
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllBalances",
      params: [input.owner],
      signal: input.signal
    });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata({ coinType, signal }) {
    if (coinType && hasMvrName(coinType)) {
      coinType = (await this.core.mvr.resolveType({
        type: coinType
      })).type;
    }
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [coinType],
      signal
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply({ coinType, signal }) {
    if (coinType && hasMvrName(coinType)) {
      coinType = (await this.core.mvr.resolveType({
        type: coinType
      })).type;
    }
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [coinType],
      signal
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params, { signal } = {}) {
    return await this.transport.request({ method, params, signal });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes({
    package: pkg,
    module: module2,
    function: fn,
    signal
  }) {
    if (pkg && isValidNamedPackage(pkg)) {
      pkg = (await this.core.mvr.resolvePackage({
        package: pkg
      })).package;
    }
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [pkg, module2, fn],
      signal
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage({
    package: pkg,
    signal
  }) {
    if (pkg && isValidNamedPackage(pkg)) {
      pkg = (await this.core.mvr.resolvePackage({
        package: pkg
      })).package;
    }
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [pkg],
      signal
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule({
    package: pkg,
    module: module2,
    signal
  }) {
    if (pkg && isValidNamedPackage(pkg)) {
      pkg = (await this.core.mvr.resolvePackage({
        package: pkg
      })).package;
    }
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [pkg, module2],
      signal
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction({
    package: pkg,
    module: module2,
    function: fn,
    signal
  }) {
    if (pkg && isValidNamedPackage(pkg)) {
      pkg = (await this.core.mvr.resolvePackage({
        package: pkg
      })).package;
    }
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [pkg, module2, fn],
      signal
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct({
    package: pkg,
    module: module2,
    struct,
    signal
  }) {
    if (pkg && isValidNamedPackage(pkg)) {
      pkg = (await this.core.mvr.resolvePackage({
        package: pkg
      })).package;
    }
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [pkg, module2, struct],
      signal
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    const filter = input.filter ? {
      ...input.filter
    } : void 0;
    if (filter && "MoveModule" in filter && isValidNamedPackage(filter.MoveModule.package)) {
      filter.MoveModule = {
        module: filter.MoveModule.module,
        package: (await this.core.mvr.resolvePackage({
          package: filter.MoveModule.package
        })).package
      };
    } else if (filter && "StructType" in filter && hasMvrName(filter.StructType)) {
      filter.StructType = (await this.core.mvr.resolveType({
        type: filter.StructType
      })).type;
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ],
      signal: input.signal
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options],
      signal: input.signal
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options],
      signal: input.signal
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options],
      signal: input.signal
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks({
    filter,
    options,
    cursor,
    limit,
    order,
    signal
  }) {
    if (filter && "MoveFunction" in filter && isValidNamedPackage(filter.MoveFunction.package)) {
      filter = {
        ...filter,
        MoveFunction: {
          package: (await this.core.mvr.resolvePackage({
            package: filter.MoveFunction.package
          })).package
        }
      };
    }
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter,
          options
        },
        cursor,
        limit,
        (order || "descending") === "descending"
      ],
      signal
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options],
      signal: input.signal
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d) => {
      if (!isValidTransactionDigest(d)) {
        throw new Error(`Invalid Transaction digest ${d}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options],
      signal: input.signal
    });
  }
  async executeTransactionBlock({
    transactionBlock,
    signature,
    options,
    requestType,
    signal
  }) {
    const result = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof transactionBlock === "string" ? transactionBlock : toBase64(transactionBlock),
        Array.isArray(signature) ? signature : [signature],
        options
      ],
      signal
    });
    if (requestType === "WaitForLocalExecution") {
      try {
        await this.waitForTransaction({
          digest: result.digest
        });
      } catch {
      }
    }
    return result;
  }
  async signAndExecuteTransaction({
    transaction,
    signer,
    ...input
  }) {
    let transactionBytes;
    if (transaction instanceof Uint8Array) {
      transactionBytes = transaction;
    } else {
      transaction.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transaction.build({ client: this });
    }
    const { signature, bytes } = await signer.signTransaction(transactionBytes);
    return this.executeTransactionBlock({
      transactionBlock: bytes,
      signature,
      ...input
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks({ signal } = {}) {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: [],
      signal
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice({ signal } = {}) {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: [],
      signal
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getStakes",
      params: [input.owner],
      signal: input.signal
    });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds],
      signal: input.signal
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState({
    signal
  } = {}) {
    return await this.transport.request({
      method: "suix_getLatestSuiSystemState",
      params: [],
      signal
    });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents({
    query,
    cursor,
    limit,
    order,
    signal
  }) {
    if (query && "MoveEventType" in query && hasMvrName(query.MoveEventType)) {
      query = {
        ...query,
        MoveEventType: (await this.core.mvr.resolveType({
          type: query.MoveEventType
        })).type
      };
    }
    if (query && "MoveEventModule" in query && isValidNamedPackage(query.MoveEventModule.package)) {
      query = {
        ...query,
        MoveEventModule: {
          module: query.MoveEventModule.module,
          package: (await this.core.mvr.resolvePackage({
            package: query.MoveEventModule.package
          })).package
        }
      };
    }
    if ("MoveModule" in query && isValidNamedPackage(query.MoveModule.package)) {
      query = {
        ...query,
        MoveModule: {
          module: query.MoveModule.module,
          package: (await this.core.mvr.resolvePackage({
            package: query.MoveModule.package
          })).package
        }
      };
    }
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [query, cursor, limit, (order || "descending") === "descending"],
      signal
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage,
      signal: input.signal
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage,
      signal: input.signal
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    let devInspectTxBytes;
    if (isTransaction(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toBase64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toBase64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    input.signal?.throwIfAborted();
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch],
      signal: input.signal
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toBase64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name],
      signal: input.signal
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber({
    signal
  } = {}) {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: [],
      signal
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({
      method: "sui_getCheckpoint",
      params: [input.id],
      signal: input.signal
    });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input?.limit, input.descendingOrder],
      signal: input.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input?.epoch],
      signal: input?.signal
    });
  }
  async getNetworkMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getNetworkMetrics",
      params: [],
      signal
    });
  }
  async getAddressMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getLatestAddressMetrics",
      params: [],
      signal
    });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input?.cursor, input?.limit, input?.descendingOrder],
      signal: input?.signal
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input?.descendingOrder],
      signal: input?.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input?.cursor, input?.limit, input?.descendingOrder],
      signal: input?.signal
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getMoveCallMetrics",
      params: [],
      signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getCurrentEpoch",
      params: [],
      signal
    });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getValidatorsApy",
      params: [],
      signal
    });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier({ signal } = {}) {
    const checkpoint = await this.getCheckpoint({ id: "0", signal });
    const bytes = fromBase58(checkpoint.digest);
    return toHex(bytes.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name],
      signal: input.signal
    });
  }
  async resolveNameServiceNames({
    format = "dot",
    ...input
  }) {
    const { nextCursor, hasNextPage, data } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit],
      signal: input.signal
    });
    return {
      hasNextPage,
      nextCursor,
      data: data.map((name2) => normalizeSuiNSName(name2, format))
    };
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input?.version],
      signal: input?.signal
    });
  }
  async verifyZkLoginSignature(input) {
    return await this.transport.request({
      method: "sui_verifyZkLoginSignature",
      params: [input.bytes, input.signature, input.intentScope, input.author],
      signal: input.signal
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    pollInterval = 2 * 1e3,
    ...input
  }) {
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal?.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/utils/dist/esm/b58.js
var toBase582 = (buffer) => base58.encode(buffer);
var fromBase582 = (str) => base58.decode(str);

// node_modules/@mysten/seal/node_modules/@mysten/utils/dist/esm/b64.js
function fromBase642(base64String3) {
  return Uint8Array.from(atob(base64String3), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE2 = 8192;
function toBase642(bytes) {
  if (bytes.length < CHUNK_SIZE2) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i2 = 0; i2 < bytes.length; i2 += CHUNK_SIZE2) {
    const chunk2 = bytes.slice(i2, i2 + CHUNK_SIZE2);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// node_modules/@mysten/seal/node_modules/@mysten/utils/dist/esm/hex.js
function fromHex2(hexStr) {
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex2(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@mysten/seal/node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode2(num) {
  const arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode2(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    const byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}

// node_modules/@mysten/seal/node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader2 = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    const value2 = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value2;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    const value2 = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value2;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    const value2 = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value2;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    const value1 = this.read32();
    const value2 = this.read32();
    const result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    const value1 = BigInt(this.read64());
    const value2 = BigInt(this.read64());
    const result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    const value1 = BigInt(this.read128());
    const value2 = BigInt(this.read128());
    const result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    const start = this.bytePosition + this.dataView.byteOffset;
    const value2 = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value2;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    const start = this.bytePosition + this.dataView.byteOffset;
    const buffer = new Uint8Array(this.dataView.buffer, start);
    const { value: value2, length } = ulebDecode2(buffer);
    this.shift(length);
    return value2;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    const length = this.readULEB();
    const result = [];
    for (let i2 = 0; i2 < length; i2++) {
      result.push(cb(this, i2, length));
    }
    return result;
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr2(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase582(data);
    case "base64":
      return toBase642(data);
    case "hex":
      return toHex2(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters2(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    const char = str[i2];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// node_modules/@mysten/seal/node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter2 = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value2) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value2));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value2) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value2), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value2) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value2), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value2) {
    toLittleEndian2(BigInt(value2), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value2) {
    toLittleEndian2(BigInt(value2), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value2) {
    toLittleEndian2(BigInt(value2), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value2) {
    ulebEncode2(value2).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector2, cb) {
    this.writeULEB(vector2.length);
    Array.from(vector2).forEach((el, i2) => cb(this, el, i2, vector2.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i2 = 0; i2 < this.bytePosition; i2++) {
      yield this.dataView.getUint8(i2);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr2(this.toBytes(), encoding);
  }
};
function toLittleEndian2(bigint2, size) {
  const result = new Uint8Array(size);
  let i2 = 0;
  while (bigint2 > 0) {
    result[i2] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i2 += 1;
  }
  return result;
}

// node_modules/@mysten/seal/node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError10 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck10 = (obj, member, msg) => member.has(obj) || __typeError10("Cannot " + msg);
var __privateGet10 = (obj, member, getter) => (__accessCheck10(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd10 = (obj, member, value2) => member.has(obj) ? __typeError10("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet10 = (obj, member, value2, setter) => (__accessCheck10(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _write2;
var _serialize2;
var _schema2;
var _bytes2;
var _BcsType3 = class _BcsType4 {
  constructor(options) {
    __privateAdd10(this, _write2);
    __privateAdd10(this, _serialize2);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet10(this, _write2, options.write);
    __privateSet10(this, _serialize2, options.serialize ?? ((value2, options2) => {
      const writer = new BcsWriter2({
        initialSize: this.serializedSize(value2) ?? void 0,
        ...options2
      });
      __privateGet10(this, _write2).call(this, value2, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value2, writer) {
    this.validate(value2);
    __privateGet10(this, _write2).call(this, value2, writer);
  }
  serialize(value2, options) {
    this.validate(value2);
    return new SerializedBcs2(this, __privateGet10(this, _serialize2).call(this, value2, options));
  }
  parse(bytes) {
    const reader = new BcsReader2(bytes);
    return this.read(reader);
  }
  fromHex(hex2) {
    return this.parse(fromHex2(hex2));
  }
  fromBase58(b64) {
    return this.parse(fromBase582(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase642(b64));
  }
  transform({
    name: name2,
    input,
    output,
    validate: validate2
  }) {
    return new _BcsType4({
      name: name2 ?? this.name,
      read: (reader) => output ? output(this.read(reader)) : this.read(reader),
      write: (value2, writer) => __privateGet10(this, _write2).call(this, input ? input(value2) : value2, writer),
      serializedSize: (value2) => this.serializedSize(input ? input(value2) : value2),
      serialize: (value2, options) => __privateGet10(this, _serialize2).call(this, input ? input(value2) : value2, options),
      validate: (value2) => {
        validate2?.(value2);
        this.validate(input ? input(value2) : value2);
      }
    });
  }
};
_write2 = /* @__PURE__ */ new WeakMap();
_serialize2 = /* @__PURE__ */ new WeakMap();
var BcsType2 = _BcsType3;
var SERIALIZED_BCS_BRAND2 = Symbol.for("@mysten/serialized-bcs");
var SerializedBcs2 = class {
  constructor(type2, schema) {
    __privateAdd10(this, _schema2);
    __privateAdd10(this, _bytes2);
    __privateSet10(this, _schema2, type2);
    __privateSet10(this, _bytes2, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND2]() {
    return true;
  }
  toBytes() {
    return __privateGet10(this, _bytes2);
  }
  toHex() {
    return toHex2(__privateGet10(this, _bytes2));
  }
  toBase64() {
    return toBase642(__privateGet10(this, _bytes2));
  }
  toBase58() {
    return toBase582(__privateGet10(this, _bytes2));
  }
  parse() {
    return __privateGet10(this, _schema2).parse(__privateGet10(this, _bytes2));
  }
};
_schema2 = /* @__PURE__ */ new WeakMap();
_bytes2 = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType2({
  size,
  ...options
}) {
  return new BcsType2({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType2({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType2({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](value2),
    validate: (value2) => {
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      options.validate?.(value2);
    }
  });
}
function bigUIntBcsType2({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType2({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](BigInt(value2)),
    validate: (val) => {
      const value2 = BigInt(val);
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      options.validate?.(value2);
    }
  });
}
function dynamicSizeBcsType2({
  serialize,
  ...options
}) {
  const type2 = new BcsType2({
    ...options,
    serialize,
    write: (value2, writer) => {
      for (const byte of type2.serialize(value2).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type2;
}
function stringLikeBcsType2({
  toBytes: toBytes3,
  fromBytes,
  ...options
}) {
  return new BcsType2({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex2, writer) => {
      const bytes = toBytes3(hex2);
      writer.writeULEB(bytes.length);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        writer.write8(bytes[i2]);
      }
    },
    serialize: (value2) => {
      const bytes = toBytes3(value2);
      const size = ulebEncode2(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value2) => {
      if (typeof value2 !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value2}. Expected string`);
      }
      options.validate?.(value2);
    }
  });
}
function lazyBcsType2(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType2({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value2) => getType().serializedSize(value2),
    write: (value2, writer) => getType().write(value2, writer),
    serialize: (value2, options) => getType().serialize(value2, options).toBytes()
  });
}

// node_modules/@mysten/seal/node_modules/@mysten/bcs/dist/esm/bcs.js
var bcs2 = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType2({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType2({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType2({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType2({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType2({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType2({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType2({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value2, writer) => writer.write8(value2 ? 1 : 0),
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (typeof value2 !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType2({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value2) => {
        return Uint8Array.from(ulebEncode2(value2));
      },
      ...options
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType2({
      name: `bytes[${size}]`,
      size,
      read: (reader) => reader.readBytes(size),
      write: (value2, writer) => {
        const array2 = new Uint8Array(value2);
        for (let i2 = 0; i2 < size; i2++) {
          writer.write8(array2[i2] ?? 0);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(options) {
    return new BcsType2({
      name: `bytesVector`,
      read: (reader) => {
        const length = reader.readULEB();
        return reader.readBytes(length);
      },
      write: (value2, writer) => {
        const array2 = new Uint8Array(value2);
        writer.writeULEB(array2.length);
        for (let i2 = 0; i2 < array2.length; i2++) {
          writer.write8(array2[i2] ?? 0);
        }
      },
      ...options,
      serializedSize: (value2) => {
        const length = "length" in value2 ? value2.length : null;
        return length == null ? null : ulebEncode2(length).length + length;
      },
      validate: (value2) => {
        options?.validate?.(value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType2({
      name: "string",
      toBytes: (value2) => new TextEncoder().encode(value2),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size, type2, options) {
    return new BcsType2({
      name: `${type2.name}[${size}]`,
      read: (reader) => {
        const result = new Array(size);
        for (let i2 = 0; i2 < size; i2++) {
          result[i2] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type2) {
    return bcs2.enum(`Option<${type2.name}>`, {
      None: null,
      Some: type2
    }).transform({
      input: (value2) => {
        if (value2 == null) {
          return { None: true };
        }
        return { Some: value2 };
      },
      output: (value2) => {
        if (value2.$kind === "Some") {
          return value2.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type2, options) {
    return new BcsType2({
      name: `vector<${type2.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i2 = 0; i2 < length; i2++) {
          result[i2] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        writer.writeULEB(value2.length);
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType2({
      name: `(${types.map((t3) => t3.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i2 = 0; i2 < types.length; i2++) {
          const size = types[i2].serializedSize(values[i2]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type2 of types) {
          result.push(type2.read(reader));
        }
        return result;
      },
      write: (value2, writer) => {
        for (let i2 = 0; i2 < types.length; i2++) {
          types[i2].write(value2[i2], writer);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (!Array.isArray(value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name2, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType2({
      name: name2,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type2] of canonicalOrder) {
          const size = type2.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type2] of canonicalOrder) {
          result[field] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const [field, type2] of canonicalOrder) {
          type2.write(value2[field], writer);
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name2, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType2({
      name: name2,
      read: (reader) => {
        const index = reader.readULEB();
        const enumEntry = canonicalOrder[index];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index} for enum ${name2}`);
        }
        const [kind, type2] = enumEntry;
        return {
          [kind]: type2?.read(reader) ?? true,
          $kind: kind
        };
      },
      write: (value2, writer) => {
        const [name22, val] = Object.entries(value2).filter(
          ([name3]) => Object.hasOwn(values, name3)
        )[0];
        for (let i2 = 0; i2 < canonicalOrder.length; i2++) {
          const [optionName, optionType] = canonicalOrder[i2];
          if (optionName === name22) {
            writer.writeULEB(i2);
            optionType?.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value2) => {
        options?.validate?.(value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
        const keys = Object.keys(value2).filter(
          (k) => value2[k] !== void 0 && Object.hasOwn(values, k)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${name2}}`
          );
        }
        const [variant] = keys;
        if (!Object.hasOwn(values, variant)) {
          throw new TypeError(`Invalid enum variant ${variant}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs2.vector(bcs2.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value2) => {
        return [...value2.entries()];
      },
      output: (value2) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key2, val] of value2) {
          result.set(key2, val);
        }
        return result;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType2(cb);
  }
};

// node_modules/@noble/curves/esm/utils.js
var _0n6 = /* @__PURE__ */ BigInt(0);
var _1n6 = /* @__PURE__ */ BigInt(1);
function _abool2(value2, title = "") {
  if (typeof value2 !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value2);
  }
  return value2;
}
function _abytes2(value2, length, title = "") {
  const bytes = isBytes(value2);
  const len = value2?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n6 : BigInt("0x" + hex2);
}
function bytesToNumberBE2(bytes) {
  return hexToNumber2(bytesToHex(bytes));
}
function bytesToNumberLE2(bytes) {
  abytes(bytes);
  return hexToNumber2(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE2(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n2, len) {
  return numberToBytesBE2(n2, len).reverse();
}
function ensureBytes2(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e3) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e3);
    }
  } else if (isBytes(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes2(a3, b) {
  if (a3.length !== b.length)
    return false;
  let diff2 = 0;
  for (let i2 = 0; i2 < a3.length; i2++)
    diff2 |= a3[i2] ^ b[i2];
  return diff2 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
var isPosBig2 = (n2) => typeof n2 === "bigint" && _0n6 <= n2;
function inRange2(n2, min, max2) {
  return isPosBig2(n2) && isPosBig2(min) && isPosBig2(max2) && min <= n2 && n2 < max2;
}
function aInRange2(title, n2, min, max2) {
  if (!inRange2(n2, min, max2))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max2 + ", got " + n2);
}
function bitLen2(n2) {
  let len;
  for (len = 0; n2 > _0n6; n2 >>= _1n6, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n6;
}
var bitMask2 = (n2) => (_1n6 << BigInt(n2)) - _1n6;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen2 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject2(object2, fields, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized2(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n4 = /* @__PURE__ */ BigInt(2);
var _3n3 = /* @__PURE__ */ BigInt(3);
var _4n2 = /* @__PURE__ */ BigInt(4);
var _5n3 = /* @__PURE__ */ BigInt(5);
var _7n2 = /* @__PURE__ */ BigInt(7);
var _8n4 = /* @__PURE__ */ BigInt(8);
var _9n2 = /* @__PURE__ */ BigInt(9);
var _16n2 = /* @__PURE__ */ BigInt(16);
function mod2(a3, b) {
  const result = a3 % b;
  return result >= _0n7 ? result : b + result;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n7) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number2, modulo) {
  if (number2 === _0n7)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n7)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a3 = mod2(number2, modulo);
  let b = modulo;
  let x = _0n7, y = _1n7, u = _1n7, v = _0n7;
  while (a3 !== _0n7) {
    const q = b / a3;
    const r = b % a3;
    const m = x - u * q;
    const n2 = y - v * q;
    b = a3, a3 = r, x = u, y = v, u = m, v = n2;
  }
  const gcd2 = b;
  if (gcd2 !== _1n7)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function assertIsSquare2(Fp4, root, n2) {
  if (!Fp4.eql(Fp4.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod42(Fp4, n2) {
  const p1div4 = (Fp4.ORDER + _1n7) / _4n2;
  const root = Fp4.pow(n2, p1div4);
  assertIsSquare2(Fp4, root, n2);
  return root;
}
function sqrt5mod82(Fp4, n2) {
  const p5div8 = (Fp4.ORDER - _5n3) / _8n4;
  const n22 = Fp4.mul(n2, _2n4);
  const v = Fp4.pow(n22, p5div8);
  const nv = Fp4.mul(n2, v);
  const i2 = Fp4.mul(Fp4.mul(nv, _2n4), v);
  const root = Fp4.mul(nv, Fp4.sub(i2, Fp4.ONE));
  assertIsSquare2(Fp4, root, n2);
  return root;
}
function sqrt9mod162(P) {
  const Fp_ = Field2(P);
  const tn = tonelliShanks2(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n2) / _16n2;
  return (Fp4, n2) => {
    let tv1 = Fp4.pow(n2, c4);
    let tv2 = Fp4.mul(tv1, c1);
    const tv3 = Fp4.mul(tv1, c2);
    const tv4 = Fp4.mul(tv1, c3);
    const e1 = Fp4.eql(Fp4.sqr(tv2), n2);
    const e22 = Fp4.eql(Fp4.sqr(tv3), n2);
    tv1 = Fp4.cmov(tv1, tv2, e1);
    tv2 = Fp4.cmov(tv4, tv3, e22);
    const e3 = Fp4.eql(Fp4.sqr(tv2), n2);
    const root = Fp4.cmov(tv1, tv2, e3);
    assertIsSquare2(Fp4, root, n2);
    return root;
  };
}
function tonelliShanks2(P) {
  if (P < _3n3)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n7;
  let S = 0;
  while (Q % _2n4 === _0n7) {
    Q /= _2n4;
    S++;
  }
  let Z = _2n4;
  const _Fp = Field2(P);
  while (FpLegendre2(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod42;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n7) / _2n4;
  return function tonelliSlow(Fp4, n2) {
    if (Fp4.is0(n2))
      return n2;
    if (FpLegendre2(Fp4, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp4.mul(Fp4.ONE, cc);
    let t3 = Fp4.pow(n2, Q);
    let R = Fp4.pow(n2, Q1div2);
    while (!Fp4.eql(t3, Fp4.ONE)) {
      if (Fp4.is0(t3))
        return Fp4.ZERO;
      let i2 = 1;
      let t_tmp = Fp4.sqr(t3);
      while (!Fp4.eql(t_tmp, Fp4.ONE)) {
        i2++;
        t_tmp = Fp4.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n7 << BigInt(M - i2 - 1);
      const b = Fp4.pow(c, exponent);
      M = i2;
      c = Fp4.sqr(b);
      t3 = Fp4.mul(t3, c);
      R = Fp4.mul(R, b);
    }
    return R;
  };
}
function FpSqrt2(P) {
  if (P % _4n2 === _3n3)
    return sqrt3mod42;
  if (P % _8n4 === _5n3)
    return sqrt5mod82;
  if (P % _16n2 === _9n2)
    return sqrt9mod162(P);
  return tonelliShanks2(P);
}
var isNegativeLE2 = (num, modulo) => (mod2(num, modulo) & _1n7) === _1n7;
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS2.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  _validateObject2(field, opts);
  return field;
}
function FpPow2(Fp4, num, power) {
  if (power < _0n7)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n7)
    return Fp4.ONE;
  if (power === _1n7)
    return num;
  let p = Fp4.ONE;
  let d = num;
  while (power > _0n7) {
    if (power & _1n7)
      p = Fp4.mul(p, d);
    d = Fp4.sqr(d);
    power >>= _1n7;
  }
  return p;
}
function FpInvertBatch2(Fp4, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp4.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp4.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp4.mul(acc, num);
  }, Fp4.ONE);
  const invertedAcc = Fp4.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp4.is0(num))
      return acc;
    inverted[i2] = Fp4.mul(acc, inverted[i2]);
    return Fp4.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre2(Fp4, n2) {
  const p1mod2 = (Fp4.ORDER - _1n7) / _2n4;
  const powered = Fp4.pow(n2, p1mod2);
  const yes = Fp4.eql(powered, Fp4.ONE);
  const zero = Fp4.eql(powered, Fp4.ZERO);
  const no = Fp4.eql(powered, Fp4.neg(Fp4.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength2(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
  if (ORDER <= _0n7)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE2)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE2 = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n7,
    ONE: _1n7,
    allowedLengths,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n7 <= num && num < ORDER;
    },
    is0: (num) => num === _0n7,
    // is valid and invertible
    isValidNot0: (num) => !f.is0(num) && f.isValid(num),
    isOdd: (num) => (num & _1n7) === _1n7,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow2(f, num, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert2(num, ORDER),
    sqrt: _sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt2(ORDER);
      return sqrtP(f, n2);
    }),
    toBytes: (num) => isLE2 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE2 ? bytesToNumberLE2(bytes) : bytesToNumberBE2(bytes);
      if (modFromBytes)
        scalar = mod2(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch2(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a3, b, c) => c ? b : a3
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key2, fieldOrder, isLE2 = false) {
  const len = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE2(key2) : bytesToNumberBE2(key2);
  const reduced = mod2(num, fieldOrder - _1n7) + _1n7;
  return isLE2 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
function negateCt2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ2(c, points) {
  const invertedZs = FpInvertBatch2(c.Fp, points.map((p) => p.Z));
  return points.map((p, i2) => c.fromAffine(p.toAffine(invertedZs[i2])));
}
function validateW2(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts2(W, scalarBits) {
  validateW2(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask2(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets2(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n8;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints2(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i2) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars2(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i2) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
function getW2(P) {
  return pointWindowSizes2.get(P) || 1;
}
function assert02(n2) {
  if (n2 !== _0n8)
    throw new Error("invalid wNAF");
}
var wNAF2 = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point, bits) {
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p = this.ZERO) {
    let d = elm;
    while (n2 > _0n8) {
      if (n2 & _1n8)
        p = p.add(d);
      d = d.double();
      n2 >>= _1n8;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts2(W, this.bits);
    const points = [];
    let p = point;
    let base = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p;
      points.push(base);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts2(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f = f.add(negateCt2(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt2(isNeg, precomputes[offset]));
      }
    }
    assert02(n2);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts2(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n8)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets2(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert02(n2);
    return acc;
  }
  getPrecomputes(W, point, transform2) {
    let comp = pointPrecomputes2.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform2 === "function")
          comp = transform2(comp);
        pointPrecomputes2.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform2) {
    const W = getW2(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform2), scalar);
  }
  unsafe(point, scalar, transform2, prev) {
    const W = getW2(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform2), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW2(W, this.bits);
    pointWindowSizes2.set(P, W);
    pointPrecomputes2.delete(P);
  }
  hasCache(elm) {
    return getW2(elm) !== 1;
  }
};
function mulEndoUnsafe(Point, point, k1, k2) {
  let acc = point;
  let p1 = Point.ZERO;
  let p2 = Point.ZERO;
  while (k1 > _0n8 || k2 > _0n8) {
    if (k1 & _1n8)
      p1 = p1.add(acc);
    if (k2 & _1n8)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n8;
    k2 >>= _1n8;
  }
  return { p1, p2 };
}
function pippenger2(c, fieldN, points, scalars) {
  validateMSMPoints2(points, c);
  validateMSMScalars2(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen2(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask2(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField2(order, field, isLE2) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField2(field);
    return field;
  } else {
    return Field2(order, { isLE: isLE2 });
  }
}
function _createCurveFields2(type2, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type2 === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type2} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n8))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp4 = createField2(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn3 = createField2(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type2 === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp4.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp: Fp4, Fn: Fn3 };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE2;
function i2osp(value2, length) {
  anum(value2);
  anum(length);
  if (value2 < 0 || value2 >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value2);
  const res = Array.from({ length }).fill(0);
  for (let i2 = length - 1; i2 >= 0; i2--) {
    res[i2] = value2 & 255;
    value2 >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a3, b) {
  const arr = new Uint8Array(a3.length);
  for (let i2 = 0; i2 < a3.length; i2++) {
    arr[i2] = a3[i2] ^ b[i2];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST2) {
  if (!isBytes(DST2) && typeof DST2 !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST2 === "string" ? utf8ToBytes(DST2) : DST2;
}
function expand_message_xmd(msg, DST2, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST2 = normDST(DST2);
  if (DST2.length > 255)
    DST2 = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST2));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST2, i2osp(DST2.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b[i2] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST2, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST2 = normDST(DST2);
  if (DST2.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST2 = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST2).digest();
  }
  if (lenInBytes > 65535 || DST2.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST2).update(i2osp(DST2.length, 1)).digest();
}
function hash_to_field(msg, count2, options) {
  _validateObject2(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash, expand, DST: DST2 } = options;
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count2);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count2 * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST2, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST2, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count2);
  for (let i2 = 0; i2 < count2; i2++) {
    const e3 = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i2 * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e3[j] = mod2(os2ip(tv), p);
    }
    u[i2] = e3;
  }
  return u;
}
function isogenyMap(field, map2) {
  const coeff = map2.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    const [xd_inv, yd_inv] = FpInvertBatch2(field, [xd, yd], true);
    x = field.mul(xn, xd_inv);
    y = field.mul(y, field.mul(yn, yd_inv));
    return { x, y };
  };
}
var _DST_scalar = utf8ToBytes("HashToScalar-");
function createHasher2(Point, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map2(num) {
    return Point.fromAffine(mapToCurve(num));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point.ZERO))
      return Point.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map2(u[0]);
      const u1 = map2(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map2(u[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map2(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N = Point.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n5) / den;
function _splitEndoScalar(k, basis, n2) {
  const [[a1, b1], [a22, b2]] = basis;
  const c1 = divNearest(b2 * k, n2);
  const c2 = divNearest(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a22;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n9;
  const k2neg = k2 < _0n9;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask2(Math.ceil(bitLen2(n2) / 2)) + _1n9;
  if (k1 < _0n9 || k1 >= MAX_NUM || k2 < _0n9 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
  if (!["compact", "recovered", "der"].includes(format))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag2, data) => {
      const { Err: E } = DER;
      if (tag2 < 0 || tag2 > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t3 = numberToHexUnpadded(tag2);
      return t3 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag2, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag2 < 0 || tag2 > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag2)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length = length << 8 | b;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E } = DER;
      if (num < _0n9)
        throw new E("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE2(data);
    }
  },
  toSig(hex2) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes2("signature", hex2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n5 = BigInt(2);
var _3n4 = BigInt(3);
var _4n3 = BigInt(4);
function _normFnElement(Fn3, key2) {
  const { BYTES: expected } = Fn3;
  let num;
  if (typeof key2 === "bigint") {
    num = key2;
  } else {
    let bytes = ensureBytes2("private key", key2);
    try {
      num = Fn3.fromBytes(bytes);
    } catch (error2) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key2}`);
    }
  }
  if (!Fn3.isValidNot0(num))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields2("weierstrass", params, extraOpts);
  const { Fp: Fp4, Fn: Fn3 } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject2(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp4.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp4, Fn3);
  function assertCompressionIsSupported() {
    if (!Fp4.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp4.toBytes(x);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp4.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp4.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    _abytes2(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length === comp && (head === 2 || head === 3)) {
      const x = Fp4.fromBytes(tail);
      if (!Fp4.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp4.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp4.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp4.neg(y);
      return { x, y };
    } else if (length === uncomp && head === 4) {
      const L = Fp4.BYTES;
      const x = Fp4.fromBytes(tail.subarray(0, L));
      const y = Fp4.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp4.sqr(x);
    const x3 = Fp4.mul(x2, x);
    return Fp4.add(Fp4.add(x3, Fp4.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp4.sqr(y);
    const right = weierstrassEquation(x);
    return Fp4.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp4.mul(Fp4.pow(CURVE.a, _3n4), _4n3);
  const _27b2 = Fp4.mul(Fp4.sqr(CURVE.b), BigInt(27));
  if (Fp4.is0(Fp4.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp4.isValid(n2) || banZero && Fp4.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn3.ORDER);
  }
  const toAffineMemo = memoized2((p, iz) => {
    const { X, Y, Z } = p;
    if (Fp4.eql(Z, Fp4.ONE))
      return { x: X, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp4.ONE : Fp4.inv(Z);
    const x = Fp4.mul(X, iz);
    const y = Fp4.mul(Y, iz);
    const zz = Fp4.mul(Z, iz);
    if (is0)
      return { x: Fp4.ZERO, y: Fp4.ZERO };
    if (!Fp4.eql(zz, Fp4.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized2((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp4.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp4.isValid(x) || !Fp4.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point(Fp4.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt2(k1neg, k1p);
    k2p = negateCt2(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp4.isValid(x) || !Fp4.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      if (Fp4.is0(x) && Fp4.is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp4.ONE);
    }
    static fromBytes(bytes) {
      const P = Point.fromAffine(decodePoint(_abytes2(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex2) {
      return Point.fromBytes(ensureBytes2("pointHex", hex2));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n4);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp4.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp4.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp4.eql(Fp4.mul(X1, Z2), Fp4.mul(X2, Z1));
      const U2 = Fp4.eql(Fp4.mul(Y1, Z2), Fp4.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point(this.X, Fp4.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a3, b } = CURVE;
      const b3 = Fp4.mul(b, _3n4);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
      let t0 = Fp4.mul(X1, X1);
      let t1 = Fp4.mul(Y1, Y1);
      let t22 = Fp4.mul(Z1, Z1);
      let t3 = Fp4.mul(X1, Y1);
      t3 = Fp4.add(t3, t3);
      Z3 = Fp4.mul(X1, Z1);
      Z3 = Fp4.add(Z3, Z3);
      X3 = Fp4.mul(a3, Z3);
      Y3 = Fp4.mul(b3, t22);
      Y3 = Fp4.add(X3, Y3);
      X3 = Fp4.sub(t1, Y3);
      Y3 = Fp4.add(t1, Y3);
      Y3 = Fp4.mul(X3, Y3);
      X3 = Fp4.mul(t3, X3);
      Z3 = Fp4.mul(b3, Z3);
      t22 = Fp4.mul(a3, t22);
      t3 = Fp4.sub(t0, t22);
      t3 = Fp4.mul(a3, t3);
      t3 = Fp4.add(t3, Z3);
      Z3 = Fp4.add(t0, t0);
      t0 = Fp4.add(Z3, t0);
      t0 = Fp4.add(t0, t22);
      t0 = Fp4.mul(t0, t3);
      Y3 = Fp4.add(Y3, t0);
      t22 = Fp4.mul(Y1, Z1);
      t22 = Fp4.add(t22, t22);
      t0 = Fp4.mul(t22, t3);
      X3 = Fp4.sub(X3, t0);
      Z3 = Fp4.mul(t22, t1);
      Z3 = Fp4.add(Z3, Z3);
      Z3 = Fp4.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
      const a3 = CURVE.a;
      const b3 = Fp4.mul(CURVE.b, _3n4);
      let t0 = Fp4.mul(X1, X2);
      let t1 = Fp4.mul(Y1, Y2);
      let t22 = Fp4.mul(Z1, Z2);
      let t3 = Fp4.add(X1, Y1);
      let t4 = Fp4.add(X2, Y2);
      t3 = Fp4.mul(t3, t4);
      t4 = Fp4.add(t0, t1);
      t3 = Fp4.sub(t3, t4);
      t4 = Fp4.add(X1, Z1);
      let t5 = Fp4.add(X2, Z2);
      t4 = Fp4.mul(t4, t5);
      t5 = Fp4.add(t0, t22);
      t4 = Fp4.sub(t4, t5);
      t5 = Fp4.add(Y1, Z1);
      X3 = Fp4.add(Y2, Z2);
      t5 = Fp4.mul(t5, X3);
      X3 = Fp4.add(t1, t22);
      t5 = Fp4.sub(t5, X3);
      Z3 = Fp4.mul(a3, t4);
      X3 = Fp4.mul(b3, t22);
      Z3 = Fp4.add(X3, Z3);
      X3 = Fp4.sub(t1, Z3);
      Z3 = Fp4.add(t1, Z3);
      Y3 = Fp4.mul(X3, Z3);
      t1 = Fp4.add(t0, t0);
      t1 = Fp4.add(t1, t0);
      t22 = Fp4.mul(a3, t22);
      t4 = Fp4.mul(b3, t4);
      t1 = Fp4.add(t1, t22);
      t22 = Fp4.sub(t0, t22);
      t22 = Fp4.mul(a3, t22);
      t4 = Fp4.add(t4, t22);
      t0 = Fp4.mul(t1, t4);
      Y3 = Fp4.add(Y3, t0);
      t0 = Fp4.mul(t5, t4);
      X3 = Fp4.mul(t3, X3);
      X3 = Fp4.sub(X3, t0);
      t0 = Fp4.mul(t3, t1);
      Z3 = Fp4.mul(t5, Z3);
      Z3 = Fp4.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn3.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n2) => wnaf.cached(this, n2, (p) => normalizeZ2(Point, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ2(Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn3.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n9 || p.is0())
        return Point.ZERO;
      if (sc === _1n9)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a3, b) {
      const sum = this.multiplyUnsafe(a3).add(Q.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n9)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n9)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ2(Point, points);
    }
    static msm(points, scalars) {
      return pippenger2(Point, Fn3, points, scalars);
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(_normFnElement(Fn3, privateKey));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp4.ONE);
  Point.ZERO = new Point(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
  Point.Fp = Fp4;
  Point.Fn = Fn3;
  const bits = Fn3.BITS;
  const wnaf = new wNAF2(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point.BASE.precompute(8);
  return Point;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp4, Z) {
  const q = Fp4.ORDER;
  let l = _0n9;
  for (let o2 = q - _1n9; o2 % _2n5 === _0n9; o2 /= _2n5)
    l += _1n9;
  const c1 = l;
  const _2n_pow_c1_1 = _2n5 << c1 - _1n9 - _1n9;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n5;
  const c2 = (q - _1n9) / _2n_pow_c1;
  const c3 = (c2 - _1n9) / _2n5;
  const c4 = _2n_pow_c1 - _1n9;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp4.pow(Z, c2);
  const c7 = Fp4.pow(Z, (c2 + _1n9) / _2n5);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp4.pow(v, c4);
    let tv3 = Fp4.sqr(tv2);
    tv3 = Fp4.mul(tv3, v);
    let tv5 = Fp4.mul(u, tv3);
    tv5 = Fp4.pow(tv5, c3);
    tv5 = Fp4.mul(tv5, tv2);
    tv2 = Fp4.mul(tv5, v);
    tv3 = Fp4.mul(tv5, u);
    let tv4 = Fp4.mul(tv3, tv2);
    tv5 = Fp4.pow(tv4, c5);
    let isQR = Fp4.eql(tv5, Fp4.ONE);
    tv2 = Fp4.mul(tv3, c7);
    tv5 = Fp4.mul(tv4, tv1);
    tv3 = Fp4.cmov(tv2, tv3, isQR);
    tv4 = Fp4.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n9; i2--) {
      let tv52 = i2 - _2n5;
      tv52 = _2n5 << tv52 - _1n9;
      let tvv5 = Fp4.pow(tv4, tv52);
      const e1 = Fp4.eql(tvv5, Fp4.ONE);
      tv2 = Fp4.mul(tv3, tv1);
      tv1 = Fp4.mul(tv1, tv1);
      tvv5 = Fp4.mul(tv4, tv1);
      tv3 = Fp4.cmov(tv2, tv3, e1);
      tv4 = Fp4.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp4.ORDER % _4n3 === _3n4) {
    const c12 = (Fp4.ORDER - _3n4) / _4n3;
    const c22 = Fp4.sqrt(Fp4.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp4.sqr(v);
      const tv2 = Fp4.mul(u, v);
      tv1 = Fp4.mul(tv1, tv2);
      let y1 = Fp4.pow(tv1, c12);
      y1 = Fp4.mul(y1, tv2);
      const y2 = Fp4.mul(y1, c22);
      const tv3 = Fp4.mul(Fp4.sqr(y1), v);
      const isQR = Fp4.eql(tv3, u);
      let y = Fp4.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp4, opts) {
  validateField2(Fp4);
  const { A, B, Z } = opts;
  if (!Fp4.isValid(A) || !Fp4.isValid(B) || !Fp4.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp4, Z);
  if (!Fp4.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp4.sqr(u);
    tv1 = Fp4.mul(tv1, Z);
    tv2 = Fp4.sqr(tv1);
    tv2 = Fp4.add(tv2, tv1);
    tv3 = Fp4.add(tv2, Fp4.ONE);
    tv3 = Fp4.mul(tv3, B);
    tv4 = Fp4.cmov(Z, Fp4.neg(tv2), !Fp4.eql(tv2, Fp4.ZERO));
    tv4 = Fp4.mul(tv4, A);
    tv2 = Fp4.sqr(tv3);
    tv6 = Fp4.sqr(tv4);
    tv5 = Fp4.mul(tv6, A);
    tv2 = Fp4.add(tv2, tv5);
    tv2 = Fp4.mul(tv2, tv3);
    tv6 = Fp4.mul(tv6, tv4);
    tv5 = Fp4.mul(tv6, B);
    tv2 = Fp4.add(tv2, tv5);
    x = Fp4.mul(tv1, tv3);
    const { isValid, value: value2 } = sqrtRatio(tv2, tv6);
    y = Fp4.mul(tv1, u);
    y = Fp4.mul(y, value2);
    x = Fp4.cmov(x, tv3, isValid);
    y = Fp4.cmov(y, value2, isValid);
    const e1 = Fp4.isOdd(u) === Fp4.isOdd(y);
    y = Fp4.cmov(Fp4.neg(y), y, e1);
    const tv4_inv = FpInvertBatch2(Fp4, [tv4], true)[0];
    x = Fp4.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths(Fp4, Fn3) {
  return {
    secretKey: Fn3.BYTES,
    publicKey: 1 + Fp4.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp4.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn3.BYTES
  };
}
function ecdh(Point, ecdhOpts = {}) {
  const { Fn: Fn3 } = Point;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point.Fp, Fn3), { seed: getMinHashLength(Fn3.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn3, secretKey);
    } catch (error2) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point.fromBytes(publicKey);
    } catch (error2) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn3.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point.BASE.multiply(_normFnElement(Fn3, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point)
      return true;
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (Fn3.allowedLengths || secretKey === publicKey)
      return void 0;
    const l = ensureBytes2("key", item).length;
    return l === publicKey || l === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = _normFnElement(Fn3, secretKeyA);
    const b = Point.fromHex(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key2) => _normFnElement(Fn3, key2),
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
function ecdsa(Point, hash, ecdsaOpts = {}) {
  ahash(hash);
  _validateObject2(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
  const hmac2 = ecdsaOpts.hmac || ((key2, ...msgs) => hmac(hash, key2, concatBytes(...msgs)));
  const { Fp: Fp4, Fn: Fn3 } = Point;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn3;
  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n9;
    return number2 > HALF;
  }
  function validateRS(title, num) {
    if (!Fn3.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num;
  }
  function validateSigLength(bytes, format) {
    validateSigFormat(format);
    const size = lengths.signature;
    const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
    return _abytes2(bytes, sizer, `${format} signature`);
  }
  class Signature {
    constructor(r, s, recovery) {
      this.r = validateRS("r", r);
      this.s = validateRS("s", s);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes, format = defaultSigOpts_format) {
      validateSigLength(bytes, format);
      let recid;
      if (format === "der") {
        const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes));
        return new Signature(r2, s2);
      }
      if (format === "recovered") {
        recid = bytes[0];
        format = "compact";
        bytes = bytes.subarray(1);
      }
      const L = Fn3.BYTES;
      const r = bytes.subarray(0, L);
      const s = bytes.subarray(L, L * 2);
      return new Signature(Fn3.fromBytes(r), Fn3.fromBytes(s), recid);
    }
    static fromHex(hex2, format) {
      return this.fromBytes(hexToBytes(hex2), format);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const FIELD_ORDER = Fp4.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n5 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp4.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp4.toBytes(radj);
      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
      const ir = Fn3.inv(radj);
      const h = bits2int_modN(ensureBytes2("msgHash", messageHash));
      const u1 = Fn3.create(-h * ir);
      const u2 = Fn3.create(s * ir);
      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format = defaultSigOpts_format) {
      validateSigFormat(format);
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      const r = Fn3.toBytes(this.r);
      const s = Fn3.toBytes(this.s);
      if (format === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes(Uint8Array.of(this.recovery), r, s);
      }
      return concatBytes(r, s);
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex2) {
      return Signature.fromBytes(ensureBytes2("sig", hex2), "compact");
    }
    static fromDER(hex2) {
      return Signature.fromBytes(ensureBytes2("sig", hex2), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn3.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE2(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn3.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask2(fnBits);
  function int2octets(num) {
    aInRange2("num < 2^" + fnBits, num, _0n9, ORDER_MASK);
    return Fn3.toBytes(num);
  }
  function validateMsgAndHash(message, prehash) {
    _abytes2(message, void 0, "message");
    return prehash ? _abytes2(hash(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, privateKey, opts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = _normFnElement(Fn3, privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e3 = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes2("extraEntropy", e3));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn3.isValidNot0(k))
        return;
      const ik = Fn3.inv(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = Fn3.create(q.x);
      if (r === _0n9)
        return;
      const s = Fn3.create(ik * Fn3.create(m + r * d));
      if (s === _0n9)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n9);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn3.neg(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  function sign(message, secretKey, opts = {}) {
    message = ensureBytes2("message", message);
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn3.BYTES, hmac2);
    const sig = drbg(seed, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex3 = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex3 && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex3 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature(sg.r, sg.s);
    } else if (isHex3) {
      try {
        sig = Signature.fromBytes(ensureBytes2("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature.fromBytes(ensureBytes2("sig", sg), "compact");
        } catch (error2) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify(signature, message, publicKey, opts = {}) {
    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
    publicKey = ensureBytes2("publicKey", publicKey);
    message = validateMsgAndHash(ensureBytes2("message", message), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes2("sig", signature), format);
    if (sig === false)
      return false;
    try {
      const P = Point.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r, s } = sig;
      const h = bits2int_modN(message);
      const is2 = Fn3.inv(s);
      const u1 = Fn3.create(h * is2);
      const u2 = Fn3.create(r * is2);
      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn3.create(R.x);
      return v === r;
    } catch (e3) {
      return false;
    }
  }
  function recoverPublicKey(signature, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils,
    lengths,
    Point,
    sign,
    verify,
    recoverPublicKey,
    Signature,
    hash
  });
}
function weierstrassPoints(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const Point = weierstrassN(CURVE, curveOpts);
  return _weierstrass_new_output_to_legacy(c, Point);
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp4 = c.Fp;
  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
  const Fn3 = Field2(CURVE.n, {
    BITS: c.nBitLength,
    allowedLengths,
    modFromBytes: c.wrapPrivateKey
  });
  const curveOpts = {
    Fp: Fp4,
    Fn: Fn3,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _legacyHelperEquat(Fp4, a3, b) {
  function weierstrassEquation(x) {
    const x2 = Fp4.sqr(x);
    const x3 = Fp4.mul(x2, x);
    return Fp4.add(Fp4.add(x3, Fp4.mul(x, a3)), b);
  }
  return weierstrassEquation;
}
function _weierstrass_new_output_to_legacy(c, Point) {
  const { Fp: Fp4, Fn: Fn3 } = Point;
  function isWithinCurveOrder(num) {
    return inRange2(num, _1n9, Fn3.ORDER);
  }
  const weierstrassEquation = _legacyHelperEquat(Fp4, c.a, c.b);
  return Object.assign({}, {
    CURVE: c,
    Point,
    ProjectivePoint: Point,
    normPrivateKeyToScalar: (key2) => _normFnElement(Fn3, key2),
    weierstrassEquation,
    isWithinCurveOrder
  });
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
  const Point = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point,
    CURVE: Object.assign({}, c, nLength2(Point.Fn.ORDER, Point.Fn.BITS))
  });
}
function weierstrass(c) {
  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point, hash, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// node_modules/@noble/curves/esm/abstract/bls.js
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n6 = BigInt(2);
var _3n5 = BigInt(3);
function NAfDecomposition(a3) {
  const res = [];
  for (; a3 > _1n10; a3 >>= _1n10) {
    if ((a3 & _1n10) === _0n10)
      res.unshift(0);
    else if ((a3 & _3n5) === _3n5) {
      res.unshift(-1);
      a3 += _1n10;
    } else
      res.unshift(1);
  }
  return res;
}
function aNonEmpty(arr) {
  if (!Array.isArray(arr) || arr.length === 0)
    throw new Error("expected non-empty array");
}
function createBlsPairing(fields, G1, G2, params) {
  const { Fp2: Fp23, Fp12: Fp122 } = fields;
  const { twistType, ateLoopSize, xNegative, postPrecompute } = params;
  let lineFunction;
  if (twistType === "multiplicative") {
    lineFunction = (c0, c1, c2, f, Px, Py) => Fp122.mul014(f, c0, Fp23.mul(c1, Px), Fp23.mul(c2, Py));
  } else if (twistType === "divisive") {
    lineFunction = (c0, c1, c2, f, Px, Py) => Fp122.mul034(f, Fp23.mul(c2, Py), Fp23.mul(c1, Px), c0);
  } else
    throw new Error("bls: unknown twist type");
  const Fp2div2 = Fp23.div(Fp23.ONE, Fp23.mul(Fp23.ONE, _2n6));
  function pointDouble(ell, Rx, Ry, Rz) {
    const t0 = Fp23.sqr(Ry);
    const t1 = Fp23.sqr(Rz);
    const t22 = Fp23.mulByB(Fp23.mul(t1, _3n5));
    const t3 = Fp23.mul(t22, _3n5);
    const t4 = Fp23.sub(Fp23.sub(Fp23.sqr(Fp23.add(Ry, Rz)), t1), t0);
    const c0 = Fp23.sub(t22, t0);
    const c1 = Fp23.mul(Fp23.sqr(Rx), _3n5);
    const c2 = Fp23.neg(t4);
    ell.push([c0, c1, c2]);
    Rx = Fp23.mul(Fp23.mul(Fp23.mul(Fp23.sub(t0, t3), Rx), Ry), Fp2div2);
    Ry = Fp23.sub(Fp23.sqr(Fp23.mul(Fp23.add(t0, t3), Fp2div2)), Fp23.mul(Fp23.sqr(t22), _3n5));
    Rz = Fp23.mul(t0, t4);
    return { Rx, Ry, Rz };
  }
  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
    const t0 = Fp23.sub(Ry, Fp23.mul(Qy, Rz));
    const t1 = Fp23.sub(Rx, Fp23.mul(Qx, Rz));
    const c0 = Fp23.sub(Fp23.mul(t0, Qx), Fp23.mul(t1, Qy));
    const c1 = Fp23.neg(t0);
    const c2 = t1;
    ell.push([c0, c1, c2]);
    const t22 = Fp23.sqr(t1);
    const t3 = Fp23.mul(t22, t1);
    const t4 = Fp23.mul(t22, Rx);
    const t5 = Fp23.add(Fp23.sub(t3, Fp23.mul(t4, _2n6)), Fp23.mul(Fp23.sqr(t0), Rz));
    Rx = Fp23.mul(t1, t5);
    Ry = Fp23.sub(Fp23.mul(Fp23.sub(t4, t5), t0), Fp23.mul(t3, Ry));
    Rz = Fp23.mul(Rz, t3);
    return { Rx, Ry, Rz };
  }
  const ATE_NAF = NAfDecomposition(ateLoopSize);
  const calcPairingPrecomputes = memoized2((point) => {
    const p = point;
    const { x, y } = p.toAffine();
    const Qx = x, Qy = y, negQy = Fp23.neg(y);
    let Rx = Qx, Ry = Qy, Rz = Fp23.ONE;
    const ell = [];
    for (const bit of ATE_NAF) {
      const cur = [];
      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));
      if (bit)
        ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));
      ell.push(cur);
    }
    if (postPrecompute) {
      const last = ell[ell.length - 1];
      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));
    }
    return ell;
  });
  function millerLoopBatch(pairs, withFinalExponent = false) {
    let f12 = Fp122.ONE;
    if (pairs.length) {
      const ellLen = pairs[0][0].length;
      for (let i2 = 0; i2 < ellLen; i2++) {
        f12 = Fp122.sqr(f12);
        for (const [ell, Px, Py] of pairs) {
          for (const [c0, c1, c2] of ell[i2])
            f12 = lineFunction(c0, c1, c2, f12, Px, Py);
        }
      }
    }
    if (xNegative)
      f12 = Fp122.conjugate(f12);
    return withFinalExponent ? Fp122.finalExponentiate(f12) : f12;
  }
  function pairingBatch(pairs, withFinalExponent = true) {
    const res = [];
    normalizeZ2(G1, pairs.map(({ g1 }) => g1));
    normalizeZ2(G2, pairs.map(({ g2 }) => g2));
    for (const { g1, g2 } of pairs) {
      if (g1.is0() || g2.is0())
        throw new Error("pairing is not available for ZERO point");
      g1.assertValidity();
      g2.assertValidity();
      const Qa = g1.toAffine();
      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);
    }
    return millerLoopBatch(res, withFinalExponent);
  }
  function pairing(Q, P, withFinalExponent = true) {
    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);
  }
  return {
    Fp12: Fp122,
    // NOTE: we re-export Fp12 here because pairing results are Fp12!
    millerLoopBatch,
    pairing,
    pairingBatch,
    calcPairingPrecomputes
  };
}
function createBlsSig(blsPairing, PubCurve, SigCurve, SignatureCoder, isSigG1) {
  const { Fp12: Fp122, pairingBatch } = blsPairing;
  function normPub(point) {
    return point instanceof PubCurve.Point ? point : PubCurve.Point.fromHex(point);
  }
  function normSig(point) {
    return point instanceof SigCurve.Point ? point : SigCurve.Point.fromHex(point);
  }
  function amsg(m) {
    if (!(m instanceof SigCurve.Point))
      throw new Error(`expected valid message hashed to ${!isSigG1 ? "G2" : "G1"} curve`);
    return m;
  }
  const pair = !isSigG1 ? (a3, b) => ({ g1: a3, g2: b }) : (a3, b) => ({ g1: b, g2: a3 });
  return {
    // P = pk x G
    getPublicKey(secretKey) {
      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);
      return PubCurve.Point.BASE.multiply(sec);
    },
    // S = pk x H(m)
    sign(message, secretKey, unusedArg) {
      if (unusedArg != null)
        throw new Error("sign() expects 2 arguments");
      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);
      amsg(message).assertValidity();
      return message.multiply(sec);
    },
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(P, H(m)) == e(G, S)
    // e(S, G) == e(H(m), P)
    verify(signature, message, publicKey, unusedArg) {
      if (unusedArg != null)
        throw new Error("verify() expects 3 arguments");
      signature = normSig(signature);
      publicKey = normPub(publicKey);
      const P = publicKey.negate();
      const G = PubCurve.Point.BASE;
      const Hm = amsg(message);
      const S = signature;
      const exp = pairingBatch([pair(P, Hm), pair(G, S)]);
      return Fp122.eql(exp, Fp122.ONE);
    },
    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))
    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?
    verifyBatch(signature, messages, publicKeys) {
      aNonEmpty(messages);
      if (publicKeys.length !== messages.length)
        throw new Error("amount of public keys and messages should be equal");
      const sig = normSig(signature);
      const nMessages = messages;
      const nPublicKeys = publicKeys.map(normPub);
      const messagePubKeyMap = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < nPublicKeys.length; i2++) {
        const pub = nPublicKeys[i2];
        const msg = nMessages[i2];
        let keys = messagePubKeyMap.get(msg);
        if (keys === void 0) {
          keys = [];
          messagePubKeyMap.set(msg, keys);
        }
        keys.push(pub);
      }
      const paired = [];
      const G = PubCurve.Point.BASE;
      try {
        for (const [msg, keys] of messagePubKeyMap) {
          const groupPublicKey = keys.reduce((acc, msg2) => acc.add(msg2));
          paired.push(pair(groupPublicKey, msg));
        }
        paired.push(pair(G.negate(), sig));
        return Fp122.eql(pairingBatch(paired), Fp122.ONE);
      } catch {
        return false;
      }
    },
    // Adds a bunch of public key points together.
    // pk1 + pk2 + pk3 = pkA
    aggregatePublicKeys(publicKeys) {
      aNonEmpty(publicKeys);
      publicKeys = publicKeys.map((pub) => normPub(pub));
      const agg = publicKeys.reduce((sum, p) => sum.add(p), PubCurve.Point.ZERO);
      agg.assertValidity();
      return agg;
    },
    // Adds a bunch of signature points together.
    // pk1 + pk2 + pk3 = pkA
    aggregateSignatures(signatures) {
      aNonEmpty(signatures);
      signatures = signatures.map((sig) => normSig(sig));
      const agg = signatures.reduce((sum, s) => sum.add(s), SigCurve.Point.ZERO);
      agg.assertValidity();
      return agg;
    },
    hash(messageBytes, DST2) {
      abytes(messageBytes);
      const opts = DST2 ? { DST: DST2 } : void 0;
      return SigCurve.hashToCurve(messageBytes, opts);
    },
    Signature: SignatureCoder
  };
}
function bls(CURVE) {
  const { Fp: Fp4, Fr, Fp2: Fp23, Fp6: Fp62, Fp12: Fp122 } = CURVE.fields;
  const G1_ = weierstrassPoints(CURVE.G1);
  const G1 = Object.assign(G1_, createHasher2(G1_.Point, CURVE.G1.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G1.htfDefaults
  }));
  const G2_ = weierstrassPoints(CURVE.G2);
  const G2 = Object.assign(G2_, createHasher2(G2_.Point, CURVE.G2.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G2.htfDefaults
  }));
  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {
    ...CURVE.params,
    postPrecompute: CURVE.postPrecompute
  });
  const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;
  const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);
  const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);
  const rand = CURVE.randomBytes || randomBytes;
  const randomSecretKey = () => {
    const length = getMinHashLength(Fr.ORDER);
    return mapHashToField(rand(length), Fr.ORDER);
  };
  const utils = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey,
    calcPairingPrecomputes
  };
  const { ShortSignature } = CURVE.G1;
  const { Signature } = CURVE.G2;
  function normP1Hash(point, htfOpts) {
    return point instanceof G1.Point ? point : shortSignatures.hash(ensureBytes2("point", point), htfOpts?.DST);
  }
  function normP2Hash(point, htfOpts) {
    return point instanceof G2.Point ? point : longSignatures.hash(ensureBytes2("point", point), htfOpts?.DST);
  }
  function getPublicKey(privateKey) {
    return longSignatures.getPublicKey(privateKey).toBytes(true);
  }
  function getPublicKeyForShortSignatures(privateKey) {
    return shortSignatures.getPublicKey(privateKey).toBytes(true);
  }
  function sign(message, privateKey, htfOpts) {
    const Hm = normP2Hash(message, htfOpts);
    const S = longSignatures.sign(Hm, privateKey);
    return message instanceof G2.Point ? S : Signature.toBytes(S);
  }
  function signShortSignature(message, privateKey, htfOpts) {
    const Hm = normP1Hash(message, htfOpts);
    const S = shortSignatures.sign(Hm, privateKey);
    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);
  }
  function verify(signature, message, publicKey, htfOpts) {
    const Hm = normP2Hash(message, htfOpts);
    return longSignatures.verify(signature, Hm, publicKey);
  }
  function verifyShortSignature(signature, message, publicKey, htfOpts) {
    const Hm = normP1Hash(message, htfOpts);
    return shortSignatures.verify(signature, Hm, publicKey);
  }
  function aggregatePublicKeys(publicKeys) {
    const agg = longSignatures.aggregatePublicKeys(publicKeys);
    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);
  }
  function aggregateSignatures(signatures) {
    const agg = longSignatures.aggregateSignatures(signatures);
    return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);
  }
  function aggregateShortSignatures(signatures) {
    const agg = shortSignatures.aggregateSignatures(signatures);
    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);
  }
  function verifyBatch(signature, messages, publicKeys, htfOpts) {
    const Hm = messages.map((m) => normP2Hash(m, htfOpts));
    return longSignatures.verifyBatch(signature, Hm, publicKeys);
  }
  G1.Point.BASE.precompute(4);
  return {
    longSignatures,
    shortSignatures,
    millerLoopBatch,
    pairing,
    pairingBatch,
    verifyBatch,
    fields: {
      Fr,
      Fp: Fp4,
      Fp2: Fp23,
      Fp6: Fp62,
      Fp12: Fp122
    },
    params: {
      ateLoopSize: CURVE.params.ateLoopSize,
      twistType: CURVE.params.twistType,
      // deprecated
      r: CURVE.params.r,
      G1b: CURVE.G1.b,
      G2b: CURVE.G2.b
    },
    utils,
    // deprecated
    getPublicKey,
    getPublicKeyForShortSignatures,
    sign,
    signShortSignature,
    verify,
    verifyShortSignature,
    aggregatePublicKeys,
    aggregateSignatures,
    aggregateShortSignatures,
    G1,
    G2,
    Signature,
    ShortSignature
  };
}

// node_modules/@noble/curves/esm/abstract/tower.js
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n7 = BigInt(2);
var _3n6 = BigInt(3);
function calcFrobeniusCoefficients(Fp4, nonResidue, modulus, degree, num = 1, divisor) {
  const _divisor = BigInt(divisor === void 0 ? degree : divisor);
  const towerModulus = modulus ** BigInt(degree);
  const res = [];
  for (let i2 = 0; i2 < num; i2++) {
    const a3 = BigInt(i2 + 1);
    const powers2 = [];
    for (let j = 0, qPower = _1n11; j < degree; j++) {
      const power = (a3 * qPower - a3) / _divisor % towerModulus;
      powers2.push(Fp4.pow(nonResidue, power));
      qPower *= modulus;
    }
    res.push(powers2);
  }
  return res;
}
function psiFrobenius(Fp4, Fp23, base) {
  const PSI_X = Fp23.pow(base, (Fp4.ORDER - _1n11) / _3n6);
  const PSI_Y = Fp23.pow(base, (Fp4.ORDER - _1n11) / _2n7);
  function psi(x, y) {
    const x2 = Fp23.mul(Fp23.frobeniusMap(x, 1), PSI_X);
    const y2 = Fp23.mul(Fp23.frobeniusMap(y, 1), PSI_Y);
    return [x2, y2];
  }
  const PSI2_X = Fp23.pow(base, (Fp4.ORDER ** _2n7 - _1n11) / _3n6);
  const PSI2_Y = Fp23.pow(base, (Fp4.ORDER ** _2n7 - _1n11) / _2n7);
  if (!Fp23.eql(PSI2_Y, Fp23.neg(Fp23.ONE)))
    throw new Error("psiFrobenius: PSI2_Y!==-1");
  function psi2(x, y) {
    return [Fp23.mul(x, PSI2_X), Fp23.neg(y)];
  }
  const mapAffine = (fn) => (c, P) => {
    const affine = P.toAffine();
    const p = fn(affine.x, affine.y);
    return c.fromAffine({ x: p[0], y: p[1] });
  };
  const G2psi3 = mapAffine(psi);
  const G2psi22 = mapAffine(psi2);
  return { psi, psi2, G2psi: G2psi3, G2psi2: G2psi22, PSI_X, PSI_Y, PSI2_X, PSI2_Y };
}
var Fp2fromBigTuple = (Fp4, tuple2) => {
  if (tuple2.length !== 2)
    throw new Error("invalid tuple");
  const fps = tuple2.map((n2) => Fp4.create(n2));
  return { c0: fps[0], c1: fps[1] };
};
var _Field2 = class {
  constructor(Fp4, opts = {}) {
    this.MASK = _1n11;
    const ORDER = Fp4.ORDER;
    const FP2_ORDER = ORDER * ORDER;
    this.Fp = Fp4;
    this.ORDER = FP2_ORDER;
    this.BITS = bitLen2(FP2_ORDER);
    this.BYTES = Math.ceil(bitLen2(FP2_ORDER) / 8);
    this.isLE = Fp4.isLE;
    this.ZERO = { c0: Fp4.ZERO, c1: Fp4.ZERO };
    this.ONE = { c0: Fp4.ONE, c1: Fp4.ZERO };
    this.Fp_NONRESIDUE = Fp4.create(opts.NONRESIDUE || BigInt(-1));
    this.Fp_div2 = Fp4.div(Fp4.ONE, _2n7);
    this.NONRESIDUE = Fp2fromBigTuple(Fp4, opts.FP2_NONRESIDUE);
    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp4, this.Fp_NONRESIDUE, Fp4.ORDER, 2)[0];
    this.mulByB = opts.Fp2mulByB;
    Object.seal(this);
  }
  fromBigTuple(tuple2) {
    return Fp2fromBigTuple(this.Fp, tuple2);
  }
  create(num) {
    return num;
  }
  isValid({ c0, c1 }) {
    function isValidC(num, ORDER) {
      return typeof num === "bigint" && _0n11 <= num && num < ORDER;
    }
    return isValidC(c0, this.ORDER) && isValidC(c1, this.ORDER);
  }
  is0({ c0, c1 }) {
    return this.Fp.is0(c0) && this.Fp.is0(c1);
  }
  isValidNot0(num) {
    return !this.is0(num) && this.isValid(num);
  }
  eql({ c0, c1 }, { c0: r0, c1: r1 }) {
    return this.Fp.eql(c0, r0) && this.Fp.eql(c1, r1);
  }
  neg({ c0, c1 }) {
    return { c0: this.Fp.neg(c0), c1: this.Fp.neg(c1) };
  }
  pow(num, power) {
    return FpPow2(this, num, power);
  }
  invertBatch(nums) {
    return FpInvertBatch2(this, nums);
  }
  // Normalized
  add(f1, f2) {
    const { c0, c1 } = f1;
    const { c0: r0, c1: r1 } = f2;
    return {
      c0: this.Fp.add(c0, r0),
      c1: this.Fp.add(c1, r1)
    };
  }
  sub({ c0, c1 }, { c0: r0, c1: r1 }) {
    return {
      c0: this.Fp.sub(c0, r0),
      c1: this.Fp.sub(c1, r1)
    };
  }
  mul({ c0, c1 }, rhs) {
    const { Fp: Fp4 } = this;
    if (typeof rhs === "bigint")
      return { c0: Fp4.mul(c0, rhs), c1: Fp4.mul(c1, rhs) };
    const { c0: r0, c1: r1 } = rhs;
    let t1 = Fp4.mul(c0, r0);
    let t22 = Fp4.mul(c1, r1);
    const o0 = Fp4.sub(t1, t22);
    const o1 = Fp4.sub(Fp4.mul(Fp4.add(c0, c1), Fp4.add(r0, r1)), Fp4.add(t1, t22));
    return { c0: o0, c1: o1 };
  }
  sqr({ c0, c1 }) {
    const { Fp: Fp4 } = this;
    const a3 = Fp4.add(c0, c1);
    const b = Fp4.sub(c0, c1);
    const c = Fp4.add(c0, c0);
    return { c0: Fp4.mul(a3, b), c1: Fp4.mul(c, c1) };
  }
  // NonNormalized stuff
  addN(a3, b) {
    return this.add(a3, b);
  }
  subN(a3, b) {
    return this.sub(a3, b);
  }
  mulN(a3, b) {
    return this.mul(a3, b);
  }
  sqrN(a3) {
    return this.sqr(a3);
  }
  // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
  div(lhs, rhs) {
    const { Fp: Fp4 } = this;
    return this.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : this.inv(rhs));
  }
  inv({ c0: a3, c1: b }) {
    const { Fp: Fp4 } = this;
    const factor = Fp4.inv(Fp4.create(a3 * a3 + b * b));
    return { c0: Fp4.mul(factor, Fp4.create(a3)), c1: Fp4.mul(factor, Fp4.create(-b)) };
  }
  sqrt(num) {
    const { Fp: Fp4 } = this;
    const Fp23 = this;
    const { c0, c1 } = num;
    if (Fp4.is0(c1)) {
      if (FpLegendre2(Fp4, c0) === 1)
        return Fp23.create({ c0: Fp4.sqrt(c0), c1: Fp4.ZERO });
      else
        return Fp23.create({ c0: Fp4.ZERO, c1: Fp4.sqrt(Fp4.div(c0, this.Fp_NONRESIDUE)) });
    }
    const a3 = Fp4.sqrt(Fp4.sub(Fp4.sqr(c0), Fp4.mul(Fp4.sqr(c1), this.Fp_NONRESIDUE)));
    let d = Fp4.mul(Fp4.add(a3, c0), this.Fp_div2);
    const legendre = FpLegendre2(Fp4, d);
    if (legendre === -1)
      d = Fp4.sub(d, a3);
    const a0 = Fp4.sqrt(d);
    const candidateSqrt = Fp23.create({ c0: a0, c1: Fp4.div(Fp4.mul(c1, this.Fp_div2), a0) });
    if (!Fp23.eql(Fp23.sqr(candidateSqrt), num))
      throw new Error("Cannot find square root");
    const x1 = candidateSqrt;
    const x2 = Fp23.neg(x1);
    const { re: re1, im: im1 } = Fp23.reim(x1);
    const { re: re2, im: im2 } = Fp23.reim(x2);
    if (im1 > im2 || im1 === im2 && re1 > re2)
      return x1;
    return x2;
  }
  // Same as sgn0_m_eq_2 in RFC 9380
  isOdd(x) {
    const { re: x0, im: x1 } = this.reim(x);
    const sign_0 = x0 % _2n7;
    const zero_0 = x0 === _0n11;
    const sign_1 = x1 % _2n7;
    return BigInt(sign_0 || zero_0 && sign_1) == _1n11;
  }
  // Bytes util
  fromBytes(b) {
    const { Fp: Fp4 } = this;
    if (b.length !== this.BYTES)
      throw new Error("fromBytes invalid length=" + b.length);
    return { c0: Fp4.fromBytes(b.subarray(0, Fp4.BYTES)), c1: Fp4.fromBytes(b.subarray(Fp4.BYTES)) };
  }
  toBytes({ c0, c1 }) {
    return concatBytes(this.Fp.toBytes(c0), this.Fp.toBytes(c1));
  }
  cmov({ c0, c1 }, { c0: r0, c1: r1 }, c) {
    return {
      c0: this.Fp.cmov(c0, r0, c),
      c1: this.Fp.cmov(c1, r1, c)
    };
  }
  reim({ c0, c1 }) {
    return { re: c0, im: c1 };
  }
  Fp4Square(a3, b) {
    const Fp23 = this;
    const a22 = Fp23.sqr(a3);
    const b2 = Fp23.sqr(b);
    return {
      first: Fp23.add(Fp23.mulByNonresidue(b2), a22),
      // b * Nonresidue + a
      second: Fp23.sub(Fp23.sub(Fp23.sqr(Fp23.add(a3, b)), a22), b2)
      // (a + b) - a - b
    };
  }
  // multiply by u + 1
  mulByNonresidue({ c0, c1 }) {
    return this.mul({ c0, c1 }, this.NONRESIDUE);
  }
  frobeniusMap({ c0, c1 }, power) {
    return {
      c0,
      c1: this.Fp.mul(c1, this.FROBENIUS_COEFFICIENTS[power % 2])
    };
  }
};
var _Field6 = class {
  constructor(Fp23) {
    this.MASK = _1n11;
    this.Fp2 = Fp23;
    this.ORDER = Fp23.ORDER;
    this.BITS = 3 * Fp23.BITS;
    this.BYTES = 3 * Fp23.BYTES;
    this.isLE = Fp23.isLE;
    this.ZERO = { c0: Fp23.ZERO, c1: Fp23.ZERO, c2: Fp23.ZERO };
    this.ONE = { c0: Fp23.ONE, c1: Fp23.ZERO, c2: Fp23.ZERO };
    const { Fp: Fp4 } = Fp23;
    const frob = calcFrobeniusCoefficients(Fp23, Fp23.NONRESIDUE, Fp4.ORDER, 6, 2, 3);
    this.FROBENIUS_COEFFICIENTS_1 = frob[0];
    this.FROBENIUS_COEFFICIENTS_2 = frob[1];
    Object.seal(this);
  }
  add({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) {
    const { Fp2: Fp23 } = this;
    return {
      c0: Fp23.add(c0, r0),
      c1: Fp23.add(c1, r1),
      c2: Fp23.add(c2, r2)
    };
  }
  sub({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) {
    const { Fp2: Fp23 } = this;
    return {
      c0: Fp23.sub(c0, r0),
      c1: Fp23.sub(c1, r1),
      c2: Fp23.sub(c2, r2)
    };
  }
  mul({ c0, c1, c2 }, rhs) {
    const { Fp2: Fp23 } = this;
    if (typeof rhs === "bigint") {
      return {
        c0: Fp23.mul(c0, rhs),
        c1: Fp23.mul(c1, rhs),
        c2: Fp23.mul(c2, rhs)
      };
    }
    const { c0: r0, c1: r1, c2: r2 } = rhs;
    const t0 = Fp23.mul(c0, r0);
    const t1 = Fp23.mul(c1, r1);
    const t22 = Fp23.mul(c2, r2);
    return {
      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
      c0: Fp23.add(t0, Fp23.mulByNonresidue(Fp23.sub(Fp23.mul(Fp23.add(c1, c2), Fp23.add(r1, r2)), Fp23.add(t1, t22)))),
      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
      c1: Fp23.add(Fp23.sub(Fp23.mul(Fp23.add(c0, c1), Fp23.add(r0, r1)), Fp23.add(t0, t1)), Fp23.mulByNonresidue(t22)),
      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
      c2: Fp23.sub(Fp23.add(t1, Fp23.mul(Fp23.add(c0, c2), Fp23.add(r0, r2))), Fp23.add(t0, t22))
    };
  }
  sqr({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    let t0 = Fp23.sqr(c0);
    let t1 = Fp23.mul(Fp23.mul(c0, c1), _2n7);
    let t3 = Fp23.mul(Fp23.mul(c1, c2), _2n7);
    let t4 = Fp23.sqr(c2);
    return {
      c0: Fp23.add(Fp23.mulByNonresidue(t3), t0),
      // T3 * (u + 1) + T0
      c1: Fp23.add(Fp23.mulByNonresidue(t4), t1),
      // T4 * (u + 1) + T1
      // T1 + (c0 - c1 + c2) + T3 - T0 - T4
      c2: Fp23.sub(Fp23.sub(Fp23.add(Fp23.add(t1, Fp23.sqr(Fp23.add(Fp23.sub(c0, c1), c2))), t3), t0), t4)
    };
  }
  addN(a3, b) {
    return this.add(a3, b);
  }
  subN(a3, b) {
    return this.sub(a3, b);
  }
  mulN(a3, b) {
    return this.mul(a3, b);
  }
  sqrN(a3) {
    return this.sqr(a3);
  }
  create(num) {
    return num;
  }
  isValid({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    return Fp23.isValid(c0) && Fp23.isValid(c1) && Fp23.isValid(c2);
  }
  is0({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    return Fp23.is0(c0) && Fp23.is0(c1) && Fp23.is0(c2);
  }
  isValidNot0(num) {
    return !this.is0(num) && this.isValid(num);
  }
  neg({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    return { c0: Fp23.neg(c0), c1: Fp23.neg(c1), c2: Fp23.neg(c2) };
  }
  eql({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) {
    const { Fp2: Fp23 } = this;
    return Fp23.eql(c0, r0) && Fp23.eql(c1, r1) && Fp23.eql(c2, r2);
  }
  sqrt(_) {
    return notImplemented();
  }
  // Do we need division by bigint at all? Should be done via order:
  div(lhs, rhs) {
    const { Fp2: Fp23 } = this;
    const { Fp: Fp4 } = Fp23;
    return this.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : this.inv(rhs));
  }
  pow(num, power) {
    return FpPow2(this, num, power);
  }
  invertBatch(nums) {
    return FpInvertBatch2(this, nums);
  }
  inv({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    let t0 = Fp23.sub(Fp23.sqr(c0), Fp23.mulByNonresidue(Fp23.mul(c2, c1)));
    let t1 = Fp23.sub(Fp23.mulByNonresidue(Fp23.sqr(c2)), Fp23.mul(c0, c1));
    let t22 = Fp23.sub(Fp23.sqr(c1), Fp23.mul(c0, c2));
    let t4 = Fp23.inv(Fp23.add(Fp23.mulByNonresidue(Fp23.add(Fp23.mul(c2, t1), Fp23.mul(c1, t22))), Fp23.mul(c0, t0)));
    return { c0: Fp23.mul(t4, t0), c1: Fp23.mul(t4, t1), c2: Fp23.mul(t4, t22) };
  }
  // Bytes utils
  fromBytes(b) {
    const { Fp2: Fp23 } = this;
    if (b.length !== this.BYTES)
      throw new Error("fromBytes invalid length=" + b.length);
    const B2 = Fp23.BYTES;
    return {
      c0: Fp23.fromBytes(b.subarray(0, B2)),
      c1: Fp23.fromBytes(b.subarray(B2, B2 * 2)),
      c2: Fp23.fromBytes(b.subarray(2 * B2))
    };
  }
  toBytes({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    return concatBytes(Fp23.toBytes(c0), Fp23.toBytes(c1), Fp23.toBytes(c2));
  }
  cmov({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) {
    const { Fp2: Fp23 } = this;
    return {
      c0: Fp23.cmov(c0, r0, c),
      c1: Fp23.cmov(c1, r1, c),
      c2: Fp23.cmov(c2, r2, c)
    };
  }
  fromBigSix(t3) {
    const { Fp2: Fp23 } = this;
    if (!Array.isArray(t3) || t3.length !== 6)
      throw new Error("invalid Fp6 usage");
    return {
      c0: Fp23.fromBigTuple(t3.slice(0, 2)),
      c1: Fp23.fromBigTuple(t3.slice(2, 4)),
      c2: Fp23.fromBigTuple(t3.slice(4, 6))
    };
  }
  frobeniusMap({ c0, c1, c2 }, power) {
    const { Fp2: Fp23 } = this;
    return {
      c0: Fp23.frobeniusMap(c0, power),
      c1: Fp23.mul(Fp23.frobeniusMap(c1, power), this.FROBENIUS_COEFFICIENTS_1[power % 6]),
      c2: Fp23.mul(Fp23.frobeniusMap(c2, power), this.FROBENIUS_COEFFICIENTS_2[power % 6])
    };
  }
  mulByFp2({ c0, c1, c2 }, rhs) {
    const { Fp2: Fp23 } = this;
    return {
      c0: Fp23.mul(c0, rhs),
      c1: Fp23.mul(c1, rhs),
      c2: Fp23.mul(c2, rhs)
    };
  }
  mulByNonresidue({ c0, c1, c2 }) {
    const { Fp2: Fp23 } = this;
    return { c0: Fp23.mulByNonresidue(c2), c1: c0, c2: c1 };
  }
  // Sparse multiplication
  mul1({ c0, c1, c2 }, b1) {
    const { Fp2: Fp23 } = this;
    return {
      c0: Fp23.mulByNonresidue(Fp23.mul(c2, b1)),
      c1: Fp23.mul(c0, b1),
      c2: Fp23.mul(c1, b1)
    };
  }
  // Sparse multiplication
  mul01({ c0, c1, c2 }, b0, b1) {
    const { Fp2: Fp23 } = this;
    let t0 = Fp23.mul(c0, b0);
    let t1 = Fp23.mul(c1, b1);
    return {
      // ((c1 + c2) * b1 - T1) * (u + 1) + T0
      c0: Fp23.add(Fp23.mulByNonresidue(Fp23.sub(Fp23.mul(Fp23.add(c1, c2), b1), t1)), t0),
      // (b0 + b1) * (c0 + c1) - T0 - T1
      c1: Fp23.sub(Fp23.sub(Fp23.mul(Fp23.add(b0, b1), Fp23.add(c0, c1)), t0), t1),
      // (c0 + c2) * b0 - T0 + T1
      c2: Fp23.add(Fp23.sub(Fp23.mul(Fp23.add(c0, c2), b0), t0), t1)
    };
  }
};
var _Field12 = class {
  constructor(Fp62, opts) {
    this.MASK = _1n11;
    const { Fp2: Fp23 } = Fp62;
    const { Fp: Fp4 } = Fp23;
    this.Fp6 = Fp62;
    this.ORDER = Fp23.ORDER;
    this.BITS = 2 * Fp62.BITS;
    this.BYTES = 2 * Fp62.BYTES;
    this.isLE = Fp62.isLE;
    this.ZERO = { c0: Fp62.ZERO, c1: Fp62.ZERO };
    this.ONE = { c0: Fp62.ONE, c1: Fp62.ZERO };
    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp23, Fp23.NONRESIDUE, Fp4.ORDER, 12, 1, 6)[0];
    this.X_LEN = opts.X_LEN;
    this.finalExponentiate = opts.Fp12finalExponentiate;
  }
  create(num) {
    return num;
  }
  isValid({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return Fp62.isValid(c0) && Fp62.isValid(c1);
  }
  is0({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return Fp62.is0(c0) && Fp62.is0(c1);
  }
  isValidNot0(num) {
    return !this.is0(num) && this.isValid(num);
  }
  neg({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return { c0: Fp62.neg(c0), c1: Fp62.neg(c1) };
  }
  eql({ c0, c1 }, { c0: r0, c1: r1 }) {
    const { Fp6: Fp62 } = this;
    return Fp62.eql(c0, r0) && Fp62.eql(c1, r1);
  }
  sqrt(_) {
    notImplemented();
  }
  inv({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    let t3 = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));
    return { c0: Fp62.mul(c0, t3), c1: Fp62.neg(Fp62.mul(c1, t3)) };
  }
  div(lhs, rhs) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp23 } = Fp62;
    const { Fp: Fp4 } = Fp23;
    return this.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : this.inv(rhs));
  }
  pow(num, power) {
    return FpPow2(this, num, power);
  }
  invertBatch(nums) {
    return FpInvertBatch2(this, nums);
  }
  // Normalized
  add({ c0, c1 }, { c0: r0, c1: r1 }) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.add(c0, r0),
      c1: Fp62.add(c1, r1)
    };
  }
  sub({ c0, c1 }, { c0: r0, c1: r1 }) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.sub(c0, r0),
      c1: Fp62.sub(c1, r1)
    };
  }
  mul({ c0, c1 }, rhs) {
    const { Fp6: Fp62 } = this;
    if (typeof rhs === "bigint")
      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };
    let { c0: r0, c1: r1 } = rhs;
    let t1 = Fp62.mul(c0, r0);
    let t22 = Fp62.mul(c1, r1);
    return {
      c0: Fp62.add(t1, Fp62.mulByNonresidue(t22)),
      // T1 + T2 * v
      // (c0 + c1) * (r0 + r1) - (T1 + T2)
      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t22))
    };
  }
  sqr({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    let ab = Fp62.mul(c0, c1);
    return {
      // (c1 * v + c0) * (c0 + c1) - AB - AB * v
      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),
      c1: Fp62.add(ab, ab)
    };
  }
  // NonNormalized stuff
  addN(a3, b) {
    return this.add(a3, b);
  }
  subN(a3, b) {
    return this.sub(a3, b);
  }
  mulN(a3, b) {
    return this.mul(a3, b);
  }
  sqrN(a3) {
    return this.sqr(a3);
  }
  // Bytes utils
  fromBytes(b) {
    const { Fp6: Fp62 } = this;
    if (b.length !== this.BYTES)
      throw new Error("fromBytes invalid length=" + b.length);
    return {
      c0: Fp62.fromBytes(b.subarray(0, Fp62.BYTES)),
      c1: Fp62.fromBytes(b.subarray(Fp62.BYTES))
    };
  }
  toBytes({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return concatBytes(Fp62.toBytes(c0), Fp62.toBytes(c1));
  }
  cmov({ c0, c1 }, { c0: r0, c1: r1 }, c) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.cmov(c0, r0, c),
      c1: Fp62.cmov(c1, r1, c)
    };
  }
  // Utils
  // toString() {
  //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
  // },
  // fromTuple(c: [Fp6, Fp6]) {
  //   return new Fp12(...c);
  // }
  fromBigTwelve(t3) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.fromBigSix(t3.slice(0, 6)),
      c1: Fp62.fromBigSix(t3.slice(6, 12))
    };
  }
  // Raises to q**i -th power
  frobeniusMap(lhs, power) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp23 } = Fp62;
    const { c0, c1, c2 } = Fp62.frobeniusMap(lhs.c1, power);
    const coeff = this.FROBENIUS_COEFFICIENTS[power % 12];
    return {
      c0: Fp62.frobeniusMap(lhs.c0, power),
      c1: Fp62.create({
        c0: Fp23.mul(c0, coeff),
        c1: Fp23.mul(c1, coeff),
        c2: Fp23.mul(c2, coeff)
      })
    };
  }
  mulByFp2({ c0, c1 }, rhs) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.mulByFp2(c0, rhs),
      c1: Fp62.mulByFp2(c1, rhs)
    };
  }
  conjugate({ c0, c1 }) {
    return { c0, c1: this.Fp6.neg(c1) };
  }
  // Sparse multiplication
  mul014({ c0, c1 }, o0, o1, o4) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp23 } = Fp62;
    let t0 = Fp62.mul01(c0, o0, o1);
    let t1 = Fp62.mul1(c1, o4);
    return {
      c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),
      // T1 * v + T0
      // (c1 + c0) * [o0, o1+o4] - T0 - T1
      c1: Fp62.sub(Fp62.sub(Fp62.mul01(Fp62.add(c1, c0), o0, Fp23.add(o1, o4)), t0), t1)
    };
  }
  mul034({ c0, c1 }, o0, o3, o4) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp23 } = Fp62;
    const a3 = Fp62.create({
      c0: Fp23.mul(c0.c0, o0),
      c1: Fp23.mul(c0.c1, o0),
      c2: Fp23.mul(c0.c2, o0)
    });
    const b = Fp62.mul01(c1, o3, o4);
    const e3 = Fp62.mul01(Fp62.add(c0, c1), Fp23.add(o0, o3), o4);
    return {
      c0: Fp62.add(Fp62.mulByNonresidue(b), a3),
      c1: Fp62.sub(e3, Fp62.add(a3, b))
    };
  }
  // A cyclotomic group is a subgroup of Fp^n defined by
  //   G(p) = {  Fp : ^(p) = 1}
  // The result of any pairing is in a cyclotomic subgroup
  // https://eprint.iacr.org/2009/565.pdf
  // https://eprint.iacr.org/2010/354.pdf
  _cyclotomicSquare({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp23 } = Fp62;
    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;
    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;
    const { first: t3, second: t4 } = Fp23.Fp4Square(c0c0, c1c1);
    const { first: t5, second: t6 } = Fp23.Fp4Square(c1c0, c0c2);
    const { first: t7, second: t8 } = Fp23.Fp4Square(c0c1, c1c2);
    const t9 = Fp23.mulByNonresidue(t8);
    return {
      c0: Fp62.create({
        c0: Fp23.add(Fp23.mul(Fp23.sub(t3, c0c0), _2n7), t3),
        // 2 * (T3 - c0c0)  + T3
        c1: Fp23.add(Fp23.mul(Fp23.sub(t5, c0c1), _2n7), t5),
        // 2 * (T5 - c0c1)  + T5
        c2: Fp23.add(Fp23.mul(Fp23.sub(t7, c0c2), _2n7), t7)
      }),
      // 2 * (T7 - c0c2)  + T7
      c1: Fp62.create({
        c0: Fp23.add(Fp23.mul(Fp23.add(t9, c1c0), _2n7), t9),
        // 2 * (T9 + c1c0) + T9
        c1: Fp23.add(Fp23.mul(Fp23.add(t4, c1c1), _2n7), t4),
        // 2 * (T4 + c1c1) + T4
        c2: Fp23.add(Fp23.mul(Fp23.add(t6, c1c2), _2n7), t6)
      })
    };
  }
  // https://eprint.iacr.org/2009/565.pdf
  _cyclotomicExp(num, n2) {
    let z = this.ONE;
    for (let i2 = this.X_LEN - 1; i2 >= 0; i2--) {
      z = this._cyclotomicSquare(z);
      if (bitGet(n2, i2))
        z = this.mul(z, num);
    }
    return z;
  }
};
function tower12(opts) {
  const Fp4 = Field2(opts.ORDER);
  const Fp23 = new _Field2(Fp4, opts);
  const Fp62 = new _Field6(Fp23);
  const Fp122 = new _Field12(Fp62, opts);
  return { Fp: Fp4, Fp2: Fp23, Fp6: Fp62, Fp12: Fp122 };
}

// node_modules/@noble/curves/esm/bls12-381.js
var _0n12 = BigInt(0);
var _1n12 = BigInt(1);
var _2n8 = BigInt(2);
var _3n7 = BigInt(3);
var _4n4 = BigInt(4);
var BLS_X = BigInt("0xd201000000010000");
var BLS_X_LEN = bitLen2(BLS_X);
var bls12_381_CURVE_G1 = {
  p: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
  n: BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"),
  h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
  a: _0n12,
  b: _4n4,
  Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
  Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1")
};
var bls12_381_Fr = Field2(bls12_381_CURVE_G1.n, {
  modFromBytes: true,
  isLE: true
});
var { Fp: Fp2, Fp2: Fp22, Fp6, Fp12 } = tower12({
  ORDER: bls12_381_CURVE_G1.p,
  X_LEN: BLS_X_LEN,
  // Finite extension field over irreducible polynominal.
  // Fp(u) / (u - ) where  = -1
  FP2_NONRESIDUE: [_1n12, _1n12],
  Fp2mulByB: ({ c0, c1 }) => {
    const t0 = Fp2.mul(c0, _4n4);
    const t1 = Fp2.mul(c1, _4n4);
    return { c0: Fp2.sub(t0, t1), c1: Fp2.add(t0, t1) };
  },
  Fp12finalExponentiate: (num) => {
    const x = BLS_X;
    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);
    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
    const t22 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));
    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t22);
    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));
    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));
    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t22));
    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));
    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t22, t5), 2);
    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);
    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);
    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
  }
});
var { G2psi, G2psi2 } = psiFrobenius(Fp2, Fp22, Fp22.div(Fp22.ONE, Fp22.NONRESIDUE));
var htfDefaults = Object.freeze({
  DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  p: Fp2.ORDER,
  m: 2,
  k: 128,
  expand: "xmd",
  hash: sha256
});
var bls12_381_CURVE_G2 = {
  p: Fp22.ORDER,
  n: bls12_381_CURVE_G1.n,
  h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
  a: Fp22.ZERO,
  b: Fp22.fromBigTuple([_4n4, _4n4]),
  Gx: Fp22.fromBigTuple([
    BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),
    BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
  ]),
  Gy: Fp22.fromBigTuple([
    BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),
    BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")
  ])
};
var COMPZERO = setMask(Fp2.toBytes(_0n12), { infinity: true, compressed: true });
function parseMask(bytes) {
  bytes = bytes.slice();
  const mask = bytes[0] & 224;
  const compressed = !!(mask >> 7 & 1);
  const infinity = !!(mask >> 6 & 1);
  const sort = !!(mask >> 5 & 1);
  bytes[0] &= 31;
  return { compressed, infinity, sort, value: bytes };
}
function setMask(bytes, mask) {
  if (bytes[0] & 224)
    throw new Error("setMask: non-empty mask");
  if (mask.compressed)
    bytes[0] |= 128;
  if (mask.infinity)
    bytes[0] |= 64;
  if (mask.sort)
    bytes[0] |= 32;
  return bytes;
}
function pointG1ToBytes(_c, point, isComp) {
  const { BYTES: L, ORDER: P } = Fp2;
  const is0 = point.is0();
  const { x, y } = point.toAffine();
  if (isComp) {
    if (is0)
      return COMPZERO.slice();
    const sort = Boolean(y * _2n8 / P);
    return setMask(numberToBytesBE2(x, L), { compressed: true, sort });
  } else {
    if (is0) {
      return concatBytes(Uint8Array.of(64), new Uint8Array(2 * L - 1));
    } else {
      return concatBytes(numberToBytesBE2(x, L), numberToBytesBE2(y, L));
    }
  }
}
function signatureG1ToBytes(point) {
  point.assertValidity();
  const { BYTES: L, ORDER: P } = Fp2;
  const { x, y } = point.toAffine();
  if (point.is0())
    return COMPZERO.slice();
  const sort = Boolean(y * _2n8 / P);
  return setMask(numberToBytesBE2(x, L), { compressed: true, sort });
}
function pointG1FromBytes(bytes) {
  const { compressed, infinity, sort, value: value2 } = parseMask(bytes);
  const { BYTES: L, ORDER: P } = Fp2;
  if (value2.length === 48 && compressed) {
    const compressedValue = bytesToNumberBE2(value2);
    const x = Fp2.create(compressedValue & bitMask2(Fp2.BITS));
    if (infinity) {
      if (x !== _0n12)
        throw new Error("invalid G1 point: non-empty, at infinity, with compression");
      return { x: _0n12, y: _0n12 };
    }
    const right = Fp2.add(Fp2.pow(x, _3n7), Fp2.create(bls12_381_CURVE_G1.b));
    let y = Fp2.sqrt(right);
    if (!y)
      throw new Error("invalid G1 point: compressed point");
    if (y * _2n8 / P !== BigInt(sort))
      y = Fp2.neg(y);
    return { x: Fp2.create(x), y: Fp2.create(y) };
  } else if (value2.length === 96 && !compressed) {
    const x = bytesToNumberBE2(value2.subarray(0, L));
    const y = bytesToNumberBE2(value2.subarray(L));
    if (infinity) {
      if (x !== _0n12 || y !== _0n12)
        throw new Error("G1: non-empty point at infinity");
      return bls12_381.G1.Point.ZERO.toAffine();
    }
    return { x: Fp2.create(x), y: Fp2.create(y) };
  } else {
    throw new Error("invalid G1 point: expected 48/96 bytes");
  }
}
function signatureG1FromBytes(hex2) {
  const { infinity, sort, value: value2 } = parseMask(ensureBytes2("signatureHex", hex2, 48));
  const P = Fp2.ORDER;
  const Point = bls12_381.G1.Point;
  const compressedValue = bytesToNumberBE2(value2);
  if (infinity)
    return Point.ZERO;
  const x = Fp2.create(compressedValue & bitMask2(Fp2.BITS));
  const right = Fp2.add(Fp2.pow(x, _3n7), Fp2.create(bls12_381_CURVE_G1.b));
  let y = Fp2.sqrt(right);
  if (!y)
    throw new Error("invalid G1 point: compressed");
  const aflag = BigInt(sort);
  if (y * _2n8 / P !== aflag)
    y = Fp2.neg(y);
  const point = Point.fromAffine({ x, y });
  point.assertValidity();
  return point;
}
function pointG2ToBytes(_c, point, isComp) {
  const { BYTES: L, ORDER: P } = Fp2;
  const is0 = point.is0();
  const { x, y } = point.toAffine();
  if (isComp) {
    if (is0)
      return concatBytes(COMPZERO, numberToBytesBE2(_0n12, L));
    const flag = Boolean(y.c1 === _0n12 ? y.c0 * _2n8 / P : y.c1 * _2n8 / P);
    return concatBytes(setMask(numberToBytesBE2(x.c1, L), { compressed: true, sort: flag }), numberToBytesBE2(x.c0, L));
  } else {
    if (is0)
      return concatBytes(Uint8Array.of(64), new Uint8Array(4 * L - 1));
    const { re: x0, im: x1 } = Fp22.reim(x);
    const { re: y0, im: y1 } = Fp22.reim(y);
    return concatBytes(numberToBytesBE2(x1, L), numberToBytesBE2(x0, L), numberToBytesBE2(y1, L), numberToBytesBE2(y0, L));
  }
}
function signatureG2ToBytes(point) {
  point.assertValidity();
  const { BYTES: L } = Fp2;
  if (point.is0())
    return concatBytes(COMPZERO, numberToBytesBE2(_0n12, L));
  const { x, y } = point.toAffine();
  const { re: x0, im: x1 } = Fp22.reim(x);
  const { re: y0, im: y1 } = Fp22.reim(y);
  const tmp = y1 > _0n12 ? y1 * _2n8 : y0 * _2n8;
  const sort = Boolean(tmp / Fp2.ORDER & _1n12);
  const z2 = x0;
  return concatBytes(setMask(numberToBytesBE2(x1, L), { sort, compressed: true }), numberToBytesBE2(z2, L));
}
function pointG2FromBytes(bytes) {
  const { BYTES: L, ORDER: P } = Fp2;
  const { compressed, infinity, sort, value: value2 } = parseMask(bytes);
  if (!compressed && !infinity && sort || // 00100000
  !compressed && infinity && sort || // 01100000
  sort && infinity && compressed) {
    throw new Error("invalid encoding flag: " + (bytes[0] & 224));
  }
  const slc = (b, from, to) => bytesToNumberBE2(b.slice(from, to));
  if (value2.length === 96 && compressed) {
    if (infinity) {
      if (value2.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {
        throw new Error("invalid G2 point: compressed");
      }
      return { x: Fp22.ZERO, y: Fp22.ZERO };
    }
    const x_1 = slc(value2, 0, L);
    const x_0 = slc(value2, L, 2 * L);
    const x = Fp22.create({ c0: Fp2.create(x_0), c1: Fp2.create(x_1) });
    const right = Fp22.add(Fp22.pow(x, _3n7), bls12_381_CURVE_G2.b);
    let y = Fp22.sqrt(right);
    const Y_bit = y.c1 === _0n12 ? y.c0 * _2n8 / P : y.c1 * _2n8 / P ? _1n12 : _0n12;
    y = sort && Y_bit > 0 ? y : Fp22.neg(y);
    return { x, y };
  } else if (value2.length === 192 && !compressed) {
    if (infinity) {
      if (value2.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {
        throw new Error("invalid G2 point: uncompressed");
      }
      return { x: Fp22.ZERO, y: Fp22.ZERO };
    }
    const x1 = slc(value2, 0 * L, 1 * L);
    const x0 = slc(value2, 1 * L, 2 * L);
    const y1 = slc(value2, 2 * L, 3 * L);
    const y0 = slc(value2, 3 * L, 4 * L);
    return { x: Fp22.fromBigTuple([x0, x1]), y: Fp22.fromBigTuple([y0, y1]) };
  } else {
    throw new Error("invalid G2 point: expected 96/192 bytes");
  }
}
function signatureG2FromBytes(hex2) {
  const { ORDER: P } = Fp2;
  const { infinity, sort, value: value2 } = parseMask(ensureBytes2("signatureHex", hex2));
  const Point = bls12_381.G2.Point;
  const half = value2.length / 2;
  if (half !== 48 && half !== 96)
    throw new Error("invalid compressed signature length, expected 96/192 bytes");
  const z1 = bytesToNumberBE2(value2.slice(0, half));
  const z2 = bytesToNumberBE2(value2.slice(half));
  if (infinity)
    return Point.ZERO;
  const x1 = Fp2.create(z1 & bitMask2(Fp2.BITS));
  const x2 = Fp2.create(z2);
  const x = Fp22.create({ c0: x2, c1: x1 });
  const y2 = Fp22.add(Fp22.pow(x, _3n7), bls12_381_CURVE_G2.b);
  let y = Fp22.sqrt(y2);
  if (!y)
    throw new Error("Failed to find a square root");
  const { re: y0, im: y1 } = Fp22.reim(y);
  const aflag1 = BigInt(sort);
  const isGreater = y1 > _0n12 && y1 * _2n8 / P !== aflag1;
  const is0 = y1 === _0n12 && y0 * _2n8 / P !== aflag1;
  if (isGreater || is0)
    y = Fp22.neg(y);
  const point = Point.fromAffine({ x, y });
  point.assertValidity();
  return point;
}
var bls12_381 = bls({
  // Fields
  fields: {
    Fp: Fp2,
    Fp2: Fp22,
    Fp6,
    Fp12,
    Fr: bls12_381_Fr
  },
  // G1: y = x + 4
  G1: {
    ...bls12_381_CURVE_G1,
    Fp: Fp2,
    htfDefaults: { ...htfDefaults, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    isTorsionFree: (c, point) => {
      const beta = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
      const phi = new c(Fp2.mul(point.X, beta), point.Y, point.Z);
      const xP = point.multiplyUnsafe(BLS_X).negate();
      const u2P = xP.multiplyUnsafe(BLS_X);
      return u2P.equals(phi);
    },
    // Clear cofactor of G1
    // https://eprint.iacr.org/2019/403
    clearCofactor: (_c, point) => {
      return point.multiplyUnsafe(BLS_X).add(point);
    },
    mapToCurve: mapToG1,
    fromBytes: pointG1FromBytes,
    toBytes: pointG1ToBytes,
    ShortSignature: {
      fromBytes(bytes) {
        abytes(bytes);
        return signatureG1FromBytes(bytes);
      },
      fromHex(hex2) {
        return signatureG1FromBytes(hex2);
      },
      toBytes(point) {
        return signatureG1ToBytes(point);
      },
      toRawBytes(point) {
        return signatureG1ToBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG1ToBytes(point));
      }
    }
  },
  G2: {
    ...bls12_381_CURVE_G2,
    Fp: Fp22,
    // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor
    // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12
    hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
    htfDefaults: { ...htfDefaults },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    mapToCurve: mapToG2,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    // Older version: https://eprint.iacr.org/2019/814.pdf
    isTorsionFree: (c, P) => {
      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P));
    },
    // Maps the point into the prime-order subgroup G2.
    // clear_cofactor_bls12381_g2 from RFC 9380.
    // https://eprint.iacr.org/2017/419.pdf
    // prettier-ignore
    clearCofactor: (c, P) => {
      const x = BLS_X;
      let t1 = P.multiplyUnsafe(x).negate();
      let t22 = G2psi(c, P);
      let t3 = P.double();
      t3 = G2psi2(c, t3);
      t3 = t3.subtract(t22);
      t22 = t1.add(t22);
      t22 = t22.multiplyUnsafe(x).negate();
      t3 = t3.add(t22);
      t3 = t3.subtract(t1);
      const Q = t3.subtract(P);
      return Q;
    },
    fromBytes: pointG2FromBytes,
    toBytes: pointG2ToBytes,
    Signature: {
      fromBytes(bytes) {
        abytes(bytes);
        return signatureG2FromBytes(bytes);
      },
      fromHex(hex2) {
        return signatureG2FromBytes(hex2);
      },
      toBytes(point) {
        return signatureG2ToBytes(point);
      },
      toRawBytes(point) {
        return signatureG2ToBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG2ToBytes(point));
      }
    }
  },
  params: {
    ateLoopSize: BLS_X,
    // The BLS parameter x for BLS12-381
    r: bls12_381_CURVE_G1.n,
    // order; z  z + 1; CURVE.n from other curves
    xNegative: true,
    twistType: "multiplicative"
  },
  htfDefaults,
  hash: sha256
});
var isogenyMapG2 = isogenyMap(Fp22, [
  // xNum
  [
    [
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"
    ],
    [
      "0x0",
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"
    ],
    [
      "0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1",
      "0x0"
    ]
  ],
  // xDen
  [
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"
    ],
    [
      "0xc",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ],
  // yNum
  [
    [
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706",
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"
    ],
    [
      "0x0",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"
    ],
    [
      "0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10",
      "0x0"
    ]
  ],
  // yDen
  [
    [
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"
    ],
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"
    ],
    [
      "0x12",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ]
].map((i2) => i2.map((pair) => Fp22.fromBigTuple(pair.map(BigInt)))));
var isogenyMapG1 = isogenyMap(Fp2, [
  // xNum
  [
    "0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7",
    "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb",
    "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0",
    "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861",
    "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9",
    "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983",
    "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84",
    "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e",
    "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317",
    "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e",
    "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b",
    "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"
  ],
  // xDen
  [
    "0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c",
    "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff",
    "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19",
    "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8",
    "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e",
    "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5",
    "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a",
    "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e",
    "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641",
    "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33",
    "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696",
    "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6",
    "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb",
    "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb",
    "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0",
    "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2",
    "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29",
    "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587",
    "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30",
    "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132",
    "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e",
    "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8",
    "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133",
    "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b",
    "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"
  ],
  // yDen
  [
    "0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1",
    "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d",
    "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2",
    "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416",
    "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d",
    "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac",
    "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c",
    "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9",
    "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a",
    "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55",
    "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8",
    "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092",
    "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc",
    "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7",
    "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j))));
var G1_SWU = mapToCurveSimpleSWU(Fp2, {
  A: Fp2.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
  B: Fp2.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
  Z: Fp2.create(BigInt(11))
});
var G2_SWU = mapToCurveSimpleSWU(Fp22, {
  A: Fp22.create({ c0: Fp2.create(_0n12), c1: Fp2.create(BigInt(240)) }),
  // A' = 240 * I
  B: Fp22.create({ c0: Fp2.create(BigInt(1012)), c1: Fp2.create(BigInt(1012)) }),
  // B' = 1012 * (1 + I)
  Z: Fp22.create({ c0: Fp2.create(BigInt(-2)), c1: Fp2.create(BigInt(-1)) })
  // Z: -(2 + I)
});
function mapToG1(scalars) {
  const { x, y } = G1_SWU(Fp2.create(scalars[0]));
  return isogenyMapG1(x, y);
}
function mapToG2(scalars) {
  const { x, y } = G2_SWU(Fp22.fromBigTuple(scalars));
  return isogenyMapG2(x, y);
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX2 = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX2 = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var MAX_SUI_NS_NAME_LENGTH2 = 235;
function isValidSuiNSName2(name2) {
  if (name2.length > MAX_SUI_NS_NAME_LENGTH2) {
    return false;
  }
  if (name2.includes("@")) {
    return SUI_NS_NAME_REGEX2.test(name2);
  }
  return SUI_NS_DOMAIN_REGEX2.test(name2);
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/utils/move-registry.js
var NAME_PATTERN2 = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var VERSION_REGEX2 = /^\d+$/;
var MAX_APP_SIZE2 = 64;
var NAME_SEPARATOR3 = "/";
var isValidNamedPackage2 = (name2) => {
  const parts = name2.split(NAME_SEPARATOR3);
  if (parts.length < 2 || parts.length > 3)
    return false;
  const [org, app, version] = parts;
  if (version !== void 0 && !VERSION_REGEX2.test(version))
    return false;
  if (!isValidSuiNSName2(org))
    return false;
  return NAME_PATTERN2.test(app) && app.length < MAX_APP_SIZE2;
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var SUI_ADDRESS_LENGTH2 = 32;
function isValidSuiAddress2(value2) {
  return isHex2(value2) && getHexByteLength2(value2) === SUI_ADDRESS_LENGTH2;
}
function isValidSuiObjectId2(value2) {
  return isValidSuiAddress2(value2);
}
function parseTypeTag2(type2) {
  if (!type2.includes("::"))
    return type2;
  return parseStructTag2(type2);
}
function parseStructTag2(type2) {
  const [address, module2] = type2.split("::");
  const isMvrPackage = isValidNamedPackage2(address);
  const rest = type2.slice(address.length + module2.length + 4);
  const name2 = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters2(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag2(typeParam.trim())
  ) : [];
  return {
    address: isMvrPackage ? address : normalizeSuiAddress2(address),
    module: module2,
    name: name2,
    typeParams
  };
}
function normalizeStructTag2(type2) {
  const { address, module: module2, name: name2, typeParams } = typeof type2 === "string" ? parseStructTag2(type2) : type2;
  const formattedTypeParams = typeParams?.length > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag2(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module2}::${name2}${formattedTypeParams}`;
}
function normalizeSuiAddress2(value2, forceAdd0x = false) {
  let address = value2.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH2 * 2, "0")}`;
}
function isHex2(value2) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value2) && value2.length % 2 === 0;
}
function getHexByteLength2(value2) {
  return /^(0x|0X)/.test(value2) ? (value2.length - 2) / 2 : value2.length / 2;
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX2 = /^vector<(.+)>$/;
var STRUCT_REGEX2 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer2 = class {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX2);
    if (vectorMatch) {
      return {
        vector: TypeTagSerializer2.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX2);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress2(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer2.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters2(str).map(
      (tok) => TypeTagSerializer2.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag2) {
    if ("bool" in tag2) {
      return "bool";
    }
    if ("u8" in tag2) {
      return "u8";
    }
    if ("u16" in tag2) {
      return "u16";
    }
    if ("u32" in tag2) {
      return "u32";
    }
    if ("u64" in tag2) {
      return "u64";
    }
    if ("u128" in tag2) {
      return "u128";
    }
    if ("u256" in tag2) {
      return "u256";
    }
    if ("address" in tag2) {
      return "address";
    }
    if ("signer" in tag2) {
      return "signer";
    }
    if ("vector" in tag2) {
      return `vector<${TypeTagSerializer2.tagToString(tag2.vector)}>`;
    }
    if ("struct" in tag2) {
      const struct = tag2.struct;
      const typeParams = struct.typeParams.map(TypeTagSerializer2.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u642(options) {
  return bcs2.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum2(type2) {
  return bcs2.enum("Option", {
    None: null,
    Some: type2
  });
}
var Address2 = bcs2.bytes(SUI_ADDRESS_LENGTH2).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex2(val);
    if (!address || !isValidSuiAddress2(normalizeSuiAddress2(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex2(normalizeSuiAddress2(val)) : val,
  output: (val) => normalizeSuiAddress2(toHex2(val))
});
var ObjectDigest2 = bcs2.vector(bcs2.u8()).transform({
  name: "ObjectDigest",
  input: (value2) => fromBase582(value2),
  output: (value2) => toBase582(new Uint8Array(value2)),
  validate: (value2) => {
    if (fromBase582(value2).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef2 = bcs2.struct("SuiObjectRef", {
  objectId: Address2,
  version: bcs2.u64(),
  digest: ObjectDigest2
});
var SharedObjectRef2 = bcs2.struct("SharedObjectRef", {
  objectId: Address2,
  initialSharedVersion: bcs2.u64(),
  mutable: bcs2.bool()
});
var ObjectArg4 = bcs2.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef2,
  SharedObject: SharedObjectRef2,
  Receiving: SuiObjectRef2
});
var Owner2 = bcs2.enum("Owner", {
  AddressOwner: Address2,
  ObjectOwner: Address2,
  Shared: bcs2.struct("Shared", {
    initialSharedVersion: bcs2.u64()
  }),
  Immutable: null,
  ConsensusV2: bcs2.struct("ConsensusV2", {
    authenticator: bcs2.enum("Authenticator", {
      SingleOwner: Address2
    }),
    startVersion: bcs2.u64()
  })
});
var CallArg3 = bcs2.enum("CallArg", {
  Pure: bcs2.struct("Pure", {
    bytes: bcs2.vector(bcs2.u8()).transform({
      input: (val) => typeof val === "string" ? fromBase642(val) : val,
      output: (val) => toBase642(new Uint8Array(val))
    })
  }),
  Object: ObjectArg4
});
var InnerTypeTag2 = bcs2.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs2.lazy(() => InnerTypeTag2),
  struct: bcs2.lazy(() => StructTag3),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag3 = InnerTypeTag2.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer2.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer2.tagToString(typeTag)
});
var Argument3 = bcs2.enum("Argument", {
  GasCoin: null,
  Input: bcs2.u16(),
  Result: bcs2.u16(),
  NestedResult: bcs2.tuple([bcs2.u16(), bcs2.u16()])
});
var ProgrammableMoveCall3 = bcs2.struct("ProgrammableMoveCall", {
  package: Address2,
  module: bcs2.string(),
  function: bcs2.string(),
  typeArguments: bcs2.vector(TypeTag3),
  arguments: bcs2.vector(Argument3)
});
var Command3 = bcs2.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall3,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs2.struct("TransferObjects", {
    objects: bcs2.vector(Argument3),
    address: Argument3
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs2.struct("SplitCoins", {
    coin: Argument3,
    amounts: bcs2.vector(Argument3)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs2.struct("MergeCoins", {
    destination: Argument3,
    sources: bcs2.vector(Argument3)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs2.struct("Publish", {
    modules: bcs2.vector(
      bcs2.vector(bcs2.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase642(val) : val,
        output: (val) => toBase642(new Uint8Array(val))
      })
    ),
    dependencies: bcs2.vector(Address2)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs2.struct("MakeMoveVec", {
    type: optionEnum2(TypeTag3).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => val.Some ?? null
    }),
    elements: bcs2.vector(Argument3)
  }),
  Upgrade: bcs2.struct("Upgrade", {
    modules: bcs2.vector(
      bcs2.vector(bcs2.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase642(val) : val,
        output: (val) => toBase642(new Uint8Array(val))
      })
    ),
    dependencies: bcs2.vector(Address2),
    package: Address2,
    ticket: Argument3
  })
});
var ProgrammableTransaction2 = bcs2.struct("ProgrammableTransaction", {
  inputs: bcs2.vector(CallArg3),
  commands: bcs2.vector(Command3)
});
var TransactionKind2 = bcs2.enum("TransactionKind", {
  ProgrammableTransaction: ProgrammableTransaction2,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration5 = bcs2.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u642()
});
var StructTag3 = bcs2.struct("StructTag", {
  address: Address2,
  module: bcs2.string(),
  name: bcs2.string(),
  typeParams: bcs2.vector(InnerTypeTag2)
});
var GasData3 = bcs2.struct("GasData", {
  payment: bcs2.vector(SuiObjectRef2),
  owner: Address2,
  price: bcs2.u64(),
  budget: bcs2.u64()
});
var TransactionDataV12 = bcs2.struct("TransactionDataV1", {
  kind: TransactionKind2,
  sender: Address2,
  gasData: GasData3,
  expiration: TransactionExpiration5
});
var TransactionData2 = bcs2.enum("TransactionData", {
  V1: TransactionDataV12
});
var IntentScope2 = bcs2.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion2 = bcs2.enum("IntentVersion", {
  V0: null
});
var AppId2 = bcs2.enum("AppId", {
  Sui: null
});
var Intent2 = bcs2.struct("Intent", {
  scope: IntentScope2,
  version: IntentVersion2,
  appId: AppId2
});
function IntentMessage2(T) {
  return bcs2.struct(`IntentMessage<${T.name}>`, {
    intent: Intent2,
    value: T
  });
}
var CompressedSignature2 = bcs2.enum("CompressedSignature", {
  ED25519: bcs2.fixedArray(64, bcs2.u8()),
  Secp256k1: bcs2.fixedArray(64, bcs2.u8()),
  Secp256r1: bcs2.fixedArray(64, bcs2.u8()),
  ZkLogin: bcs2.vector(bcs2.u8())
});
var PublicKey3 = bcs2.enum("PublicKey", {
  ED25519: bcs2.fixedArray(32, bcs2.u8()),
  Secp256k1: bcs2.fixedArray(33, bcs2.u8()),
  Secp256r1: bcs2.fixedArray(33, bcs2.u8()),
  ZkLogin: bcs2.vector(bcs2.u8())
});
var MultiSigPkMap2 = bcs2.struct("MultiSigPkMap", {
  pubKey: PublicKey3,
  weight: bcs2.u8()
});
var MultiSigPublicKey2 = bcs2.struct("MultiSigPublicKey", {
  pk_map: bcs2.vector(MultiSigPkMap2),
  threshold: bcs2.u16()
});
var MultiSig2 = bcs2.struct("MultiSig", {
  sigs: bcs2.vector(CompressedSignature2),
  bitmap: bcs2.u16(),
  multisig_pk: MultiSigPublicKey2
});
var base64String2 = bcs2.vector(bcs2.u8()).transform({
  input: (val) => typeof val === "string" ? fromBase642(val) : val,
  output: (val) => toBase642(new Uint8Array(val))
});
var SenderSignedTransaction2 = bcs2.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage2(TransactionData2),
  txSignatures: bcs2.vector(base64String2)
});
var SenderSignedData2 = bcs2.vector(SenderSignedTransaction2, {
  name: "SenderSignedData"
});
var PasskeyAuthenticator2 = bcs2.struct("PasskeyAuthenticator", {
  authenticatorData: bcs2.vector(bcs2.u8()),
  clientDataJson: bcs2.string(),
  userSignature: bcs2.vector(bcs2.u8())
});

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError2 = bcs2.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs2.struct("UnableToFetchPackage", { packageId: Address2 }),
  NotAPackage: bcs2.struct("NotAPackage", { objectId: Address2 }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs2.struct("DigestDoesNotMatch", { digest: bcs2.vector(bcs2.u8()) }),
  UnknownUpgradePolicy: bcs2.struct("UnknownUpgradePolicy", { policy: bcs2.u8() }),
  PackageIDDoesNotMatch: bcs2.struct("PackageIDDoesNotMatch", {
    packageId: Address2,
    ticketId: Address2
  })
});
var ModuleId2 = bcs2.struct("ModuleId", {
  address: Address2,
  name: bcs2.string()
});
var MoveLocation2 = bcs2.struct("MoveLocation", {
  module: ModuleId2,
  function: bcs2.u16(),
  instruction: bcs2.u16(),
  functionName: bcs2.option(bcs2.string())
});
var CommandArgumentError2 = bcs2.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs2.struct("IndexOutOfBounds", { idx: bcs2.u16() }),
  SecondaryIndexOutOfBounds: bcs2.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs2.u16(),
    secondaryIdx: bcs2.u16()
  }),
  InvalidResultArity: bcs2.struct("InvalidResultArity", { resultIdx: bcs2.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError2 = bcs2.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus2 = bcs2.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs2.struct("MoveObjectTooBig", {
    objectSize: bcs2.u64(),
    maxObjectSize: bcs2.u64()
  }),
  MovePackageTooBig: bcs2.struct("MovePackageTooBig", {
    objectSize: bcs2.u64(),
    maxObjectSize: bcs2.u64()
  }),
  CircularObjectOwnership: bcs2.struct("CircularObjectOwnership", { object: Address2 }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs2.option(MoveLocation2),
  MoveAbort: bcs2.tuple([MoveLocation2, bcs2.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs2.struct("CommandArgumentError", {
    argIdx: bcs2.u16(),
    kind: CommandArgumentError2
  }),
  TypeArgumentError: bcs2.struct("TypeArgumentError", {
    argumentIdx: bcs2.u16(),
    kind: TypeArgumentError2
  }),
  UnusedValueWithoutDrop: bcs2.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs2.u16(),
    secondaryIdx: bcs2.u16()
  }),
  InvalidPublicFunctionReturnType: bcs2.struct("InvalidPublicFunctionReturnType", {
    idx: bcs2.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs2.struct("EffectsTooLarge", { currentSize: bcs2.u64(), maxSize: bcs2.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs2.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError2 }),
  WrittenObjectsTooLarge: bcs2.struct("WrittenObjectsTooLarge", {
    currentSize: bcs2.u64(),
    maxSize: bcs2.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: bcs2.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: bcs2.vector(Address2)
    }
  ),
  AddressDeniedForCoin: bcs2.struct("AddressDeniedForCoin", {
    address: Address2,
    coinType: bcs2.string()
  }),
  CoinTypeGlobalPause: bcs2.struct("CoinTypeGlobalPause", { coinType: bcs2.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus2 = bcs2.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs2.struct("ExecutionFailed", {
    error: ExecutionFailureStatus2,
    command: bcs2.option(bcs2.u64())
  })
});
var GasCostSummary2 = bcs2.struct("GasCostSummary", {
  computationCost: bcs2.u64(),
  storageCost: bcs2.u64(),
  storageRebate: bcs2.u64(),
  nonRefundableStorageFee: bcs2.u64()
});
var TransactionEffectsV12 = bcs2.struct("TransactionEffectsV1", {
  status: ExecutionStatus2,
  executedEpoch: bcs2.u64(),
  gasUsed: GasCostSummary2,
  modifiedAtVersions: bcs2.vector(bcs2.tuple([Address2, bcs2.u64()])),
  sharedObjects: bcs2.vector(SuiObjectRef2),
  transactionDigest: ObjectDigest2,
  created: bcs2.vector(bcs2.tuple([SuiObjectRef2, Owner2])),
  mutated: bcs2.vector(bcs2.tuple([SuiObjectRef2, Owner2])),
  unwrapped: bcs2.vector(bcs2.tuple([SuiObjectRef2, Owner2])),
  deleted: bcs2.vector(SuiObjectRef2),
  unwrappedThenDeleted: bcs2.vector(SuiObjectRef2),
  wrapped: bcs2.vector(SuiObjectRef2),
  gasObject: bcs2.tuple([SuiObjectRef2, Owner2]),
  eventsDigest: bcs2.option(ObjectDigest2),
  dependencies: bcs2.vector(ObjectDigest2)
});
var VersionDigest2 = bcs2.tuple([bcs2.u64(), ObjectDigest2]);
var ObjectIn2 = bcs2.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs2.tuple([VersionDigest2, Owner2])
});
var ObjectOut2 = bcs2.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs2.tuple([ObjectDigest2, Owner2]),
  PackageWrite: VersionDigest2
});
var IDOperation2 = bcs2.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange2 = bcs2.struct("EffectsObjectChange", {
  inputState: ObjectIn2,
  outputState: ObjectOut2,
  idOperation: IDOperation2
});
var UnchangedSharedKind2 = bcs2.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest2,
  MutateDeleted: bcs2.u64(),
  ReadDeleted: bcs2.u64(),
  Cancelled: bcs2.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV22 = bcs2.struct("TransactionEffectsV2", {
  status: ExecutionStatus2,
  executedEpoch: bcs2.u64(),
  gasUsed: GasCostSummary2,
  transactionDigest: ObjectDigest2,
  gasObjectIndex: bcs2.option(bcs2.u32()),
  eventsDigest: bcs2.option(ObjectDigest2),
  dependencies: bcs2.vector(ObjectDigest2),
  lamportVersion: bcs2.u64(),
  changedObjects: bcs2.vector(bcs2.tuple([Address2, EffectsObjectChange2])),
  unchangedSharedObjects: bcs2.vector(bcs2.tuple([Address2, UnchangedSharedKind2])),
  auxDataDigest: bcs2.option(ObjectDigest2)
});
var TransactionEffects2 = bcs2.enum("TransactionEffects", {
  V1: TransactionEffectsV12,
  V2: TransactionEffectsV22
});

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs2 = {
  ...bcs2,
  U8: bcs2.u8(),
  U16: bcs2.u16(),
  U32: bcs2.u32(),
  U64: bcs2.u64(),
  U128: bcs2.u128(),
  U256: bcs2.u256(),
  ULEB128: bcs2.uleb128(),
  Bool: bcs2.bool(),
  String: bcs2.string(),
  Address: Address2,
  AppId: AppId2,
  Argument: Argument3,
  CallArg: CallArg3,
  Command: Command3,
  CompressedSignature: CompressedSignature2,
  GasData: GasData3,
  Intent: Intent2,
  IntentMessage: IntentMessage2,
  IntentScope: IntentScope2,
  IntentVersion: IntentVersion2,
  MultiSig: MultiSig2,
  MultiSigPkMap: MultiSigPkMap2,
  MultiSigPublicKey: MultiSigPublicKey2,
  ObjectArg: ObjectArg4,
  ObjectDigest: ObjectDigest2,
  Owner: Owner2,
  PasskeyAuthenticator: PasskeyAuthenticator2,
  ProgrammableMoveCall: ProgrammableMoveCall3,
  ProgrammableTransaction: ProgrammableTransaction2,
  PublicKey: PublicKey3,
  SenderSignedData: SenderSignedData2,
  SenderSignedTransaction: SenderSignedTransaction2,
  SharedObjectRef: SharedObjectRef2,
  StructTag: StructTag3,
  SuiObjectRef: SuiObjectRef2,
  TransactionData: TransactionData2,
  TransactionDataV1: TransactionDataV12,
  TransactionEffects: TransactionEffects2,
  TransactionExpiration: TransactionExpiration5,
  TransactionKind: TransactionKind2,
  TypeTag: TypeTag3
};

// node_modules/@mysten/seal/dist/esm/bcs.js
var IBEEncryptions = suiBcs2.enum("IBEEncryptions", {
  BonehFranklinBLS12381: suiBcs2.struct("BonehFranklinBLS12381", {
    nonce: suiBcs2.bytes(96),
    encryptedShares: suiBcs2.vector(suiBcs2.bytes(32)),
    encryptedRandomness: suiBcs2.bytes(32)
  })
});
var Ciphertext = suiBcs2.enum("Ciphertext", {
  Aes256Gcm: suiBcs2.struct("Aes256Gcm", {
    blob: suiBcs2.vector(suiBcs2.U8),
    aad: suiBcs2.option(suiBcs2.vector(suiBcs2.U8))
  }),
  Hmac256Ctr: suiBcs2.struct("Hmac256Ctr", {
    blob: suiBcs2.vector(suiBcs2.U8),
    aad: suiBcs2.option(suiBcs2.vector(suiBcs2.U8)),
    mac: suiBcs2.bytes(32)
  }),
  Plain: suiBcs2.struct("Plain", {})
});
var EncryptedObject = suiBcs2.struct("EncryptedObject", {
  version: suiBcs2.U8,
  packageId: suiBcs2.Address,
  id: suiBcs2.vector(suiBcs2.U8).transform({
    output: (val) => toHex2(new Uint8Array(val)),
    input: (val) => fromHex2(val)
  }),
  services: suiBcs2.vector(suiBcs2.tuple([suiBcs2.Address, suiBcs2.U8])),
  threshold: suiBcs2.U8,
  encryptedShares: IBEEncryptions,
  ciphertext: Ciphertext
});
var KeyServerMove = suiBcs2.struct("KeyServer", {
  id: suiBcs2.Address,
  name: suiBcs2.string(),
  url: suiBcs2.string(),
  keyType: suiBcs2.u8(),
  pk: suiBcs2.vector(suiBcs2.u8())
});

// node_modules/@mysten/seal/dist/esm/error.js
var __typeError11 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck11 = (obj, member, msg) => member.has(obj) || __typeError11("Cannot " + msg);
var __privateAdd11 = (obj, member, value2) => member.has(obj) ? __typeError11("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateMethod6 = (obj, member, method) => (__accessCheck11(obj, member, "access private method"), method);
var _SealAPIError_static;
var generate_fn;
var SealError = class extends Error {
};
var UserError = class extends SealError {
};
var _SealAPIError = class _SealAPIError2 extends SealError {
  constructor(message, requestId, status) {
    super(message);
    this.requestId = requestId;
    this.status = status;
  }
  static async assertResponse(response, requestId) {
    var _a;
    if (response.ok) {
      return;
    }
    let errorInstance;
    try {
      const text = await response.text();
      const error2 = JSON.parse(text)["error"];
      const message = JSON.parse(text)["message"];
      errorInstance = __privateMethod6(_a = _SealAPIError2, _SealAPIError_static, generate_fn).call(_a, error2, message, requestId);
    } catch (e3) {
      errorInstance = new GeneralError(response.statusText, requestId, response.status);
    }
    throw errorInstance;
  }
};
_SealAPIError_static = /* @__PURE__ */ new WeakSet();
generate_fn = function(error2, message, requestId, status) {
  switch (error2) {
    case "InvalidPTB":
      return new InvalidPTBError(requestId, message);
    case "InvalidPackage":
      return new InvalidPackageError(requestId);
    case "NoAccess":
      return new NoAccessError(requestId);
    case "InvalidCertificate":
      return new ExpiredSessionKeyError(requestId);
    case "OldPackageVersion":
      return new OldPackageError(requestId);
    case "InvalidSignature":
      return new InvalidUserSignatureError(requestId);
    case "InvalidSessionSignature":
      return new InvalidSessionKeySignatureError(requestId);
    case "InvalidSDKVersion":
      return new InvalidSDKVersionError(requestId);
    case "DeprecatedSDKVersion":
      return new DeprecatedSDKVersionError(requestId);
    case "Failure":
      return new InternalError(requestId);
    default:
      return new GeneralError(message, requestId, status);
  }
};
__privateAdd11(_SealAPIError, _SealAPIError_static);
var SealAPIError = _SealAPIError;
var InvalidPTBError = class extends SealAPIError {
  constructor(requestId, message) {
    super("PTB does not conform to the expected format " + message, requestId);
  }
};
var InvalidPackageError = class extends SealAPIError {
  constructor(requestId) {
    super("Package ID used in PTB is invalid", requestId);
  }
};
var OldPackageError = class extends SealAPIError {
  constructor(requestId) {
    super("PTB must call the latest version of the package", requestId);
  }
};
var InvalidUserSignatureError = class extends SealAPIError {
  constructor(requestId) {
    super("User signature on the session key is invalid", requestId);
  }
};
var InvalidSessionKeySignatureError = class extends SealAPIError {
  constructor(requestId) {
    super("Session key signature is invalid", requestId);
  }
};
var InvalidSDKVersionError = class extends SealAPIError {
  constructor(requestId) {
    super("SDK version is invalid", requestId);
  }
};
var DeprecatedSDKVersionError = class extends SealAPIError {
  constructor(requestId) {
    super("SDK version is deprecated", requestId);
  }
};
var NoAccessError = class extends SealAPIError {
  constructor(requestId) {
    super("User does not have access to one or more of the requested keys", requestId);
  }
};
var ExpiredSessionKeyError = class extends SealAPIError {
  constructor(requestId) {
    super("Session key has expired", requestId);
  }
};
var InternalError = class extends SealAPIError {
  constructor(requestId) {
    super("Internal server error, caller should retry", requestId);
  }
};
var GeneralError = class extends SealAPIError {
};
var InvalidPersonalMessageSignatureError = class extends UserError {
};
var InvalidGetObjectError = class extends UserError {
};
var UnsupportedFeatureError = class extends UserError {
};
var UnsupportedNetworkError = class extends UserError {
};
var InvalidKeyServerError = class extends UserError {
};
var InvalidKeyServerVersionError = class extends UserError {
};
var InvalidCiphertextError = class extends UserError {
};
var InvalidThresholdError = class extends UserError {
};
var InconsistentKeyServersError = class extends UserError {
};
var DecryptionError = class extends UserError {
};
var InvalidClientOptionsError = class extends UserError {
};
var TooManyFailedFetchKeyRequestsError = class extends UserError {
};
function toMajorityError(errors) {
  let maxCount = 0;
  let majorityError = errors[0];
  const counts = /* @__PURE__ */ new Map();
  for (const error2 of errors) {
    const errorName = error2.constructor.name;
    const newCount = (counts.get(errorName) || 0) + 1;
    counts.set(errorName, newCount);
    if (newCount > maxCount) {
      maxCount = newCount;
      majorityError = error2;
    }
  }
  return majorityError;
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/utils/dynamic-fields.js
function deriveDynamicFieldID2(parentId, typeTag, key2) {
  const address = suiBcs2.Address.serialize(parentId).toBytes();
  const tag2 = suiBcs2.TypeTag.serialize(typeTag).toBytes();
  const keyLength = suiBcs2.u64().serialize(key2.length).toBytes();
  const hash = blake2b2.create({
    dkLen: 32
  });
  hash.update(new Uint8Array([240]));
  hash.update(address);
  hash.update(keyLength);
  hash.update(key2);
  hash.update(tag2);
  return `0x${toHex2(hash.digest().slice(0, 32))}`;
}

// node_modules/@mysten/seal/dist/esm/utils.js
function xor(a3, b) {
  if (a3.length !== b.length) {
    throw new Error("Invalid input");
  }
  return xorUnchecked(a3, b);
}
function xorUnchecked(a3, b) {
  return a3.map((ai, i2) => ai ^ b[i2]);
}
function createFullId(packageId, innerId) {
  if (!isValidSuiObjectId2(packageId)) {
    throw new UserError(`Invalid package ID ${packageId}`);
  }
  const fullId = flatten([fromHex2(packageId), fromHex2(innerId)]);
  return toHex2(fullId);
}
function flatten(arrays) {
  const length = arrays.reduce((sum, arr) => sum + arr.length, 0);
  const result = new Uint8Array(length);
  arrays.reduce((offset, array2) => {
    result.set(array2, offset);
    return offset + array2.length;
  }, 0);
  return result;
}
function count(array2, value2) {
  return array2.reduce((count2, item) => item === value2 ? count2 + 1 : count2, 0);
}
var Version = class {
  constructor(version) {
    const parts = version.split(".").map(Number);
    if (parts.length !== 3 || parts.some((part) => isNaN(part) || !Number.isInteger(part) || part < 0)) {
      throw new UserError(`Invalid version format: ${version}`);
    }
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts[2];
  }
  // Compare this version with another version. True if this version is older than the other version.
  older_than(other) {
    if (this.major !== other.major) {
      return this.major < other.major;
    } else if (this.minor !== other.minor) {
      return this.minor < other.minor;
    }
    return this.patch < other.patch;
  }
};

// node_modules/@mysten/seal/dist/esm/bls12381.js
var _G1Element = class _G1Element2 {
  constructor(point) {
    this.point = point;
  }
  static generator() {
    return new _G1Element2(bls12_381.G1.ProjectivePoint.BASE);
  }
  static fromBytes(bytes) {
    return new _G1Element2(bls12_381.G1.ProjectivePoint.fromHex(toHex2(bytes)));
  }
  toBytes() {
    return this.point.toRawBytes();
  }
  multiply(scalar) {
    return new _G1Element2(this.point.multiply(scalar.scalar));
  }
  add(other) {
    return new _G1Element2(this.point.add(other.point));
  }
  subtract(other) {
    return new _G1Element2(this.point.subtract(other.point));
  }
  static hashToCurve(data) {
    return new _G1Element2(
      bls12_381.G1.ProjectivePoint.fromAffine(bls12_381.G1.hashToCurve(data).toAffine())
    );
  }
  pairing(other) {
    return new GTElement(bls12_381.pairing(this.point, other.point));
  }
};
_G1Element.SIZE = 48;
var G1Element = _G1Element;
var _G2Element = class _G2Element2 {
  constructor(point) {
    this.point = point;
  }
  static generator() {
    return new _G2Element2(bls12_381.G2.ProjectivePoint.BASE);
  }
  static fromBytes(bytes) {
    return new _G2Element2(bls12_381.G2.ProjectivePoint.fromHex(toHex2(bytes)));
  }
  toBytes() {
    return this.point.toRawBytes();
  }
  multiply(scalar) {
    return new _G2Element2(this.point.multiply(scalar.scalar));
  }
  add(other) {
    return new _G2Element2(this.point.add(other.point));
  }
  hashToCurve(data) {
    return new _G2Element2(
      bls12_381.G2.ProjectivePoint.fromAffine(bls12_381.G2.hashToCurve(data).toAffine())
    );
  }
};
_G2Element.SIZE = 96;
var G2Element = _G2Element;
var _GTElement = class _GTElement2 {
  constructor(element) {
    this.element = element;
  }
  toBytes() {
    const P = [0, 3, 1, 4, 2, 5];
    const PAIR_SIZE = _GTElement2.SIZE / P.length;
    const bytes = bls12_381.fields.Fp12.toBytes(this.element);
    return flatten(P.map((p) => bytes.subarray(p * PAIR_SIZE, (p + 1) * PAIR_SIZE)));
  }
  equals(other) {
    return bls12_381.fields.Fp12.eql(this.element, other.element);
  }
};
_GTElement.SIZE = 576;
var GTElement = _GTElement;
var _Scalar = class _Scalar2 {
  constructor(scalar) {
    this.scalar = scalar;
  }
  static random() {
    return _Scalar2.fromBytes(bls12_381.utils.randomPrivateKey());
  }
  toBytes() {
    return new Uint8Array(bls12_381.fields.Fr.toBytes(this.scalar));
  }
  static fromBytes(bytes) {
    return new _Scalar2(bls12_381.fields.Fr.fromBytes(bytes));
  }
  static fromNumber(num) {
    return new _Scalar2(BigInt(num));
  }
};
_Scalar.SIZE = 32;
var Scalar = _Scalar;

// node_modules/@noble/hashes/esm/sha3.js
var _0n13 = BigInt(0);
var _1n13 = BigInt(1);
var _2n9 = BigInt(2);
var _7n3 = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R = _1n13, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t3 = _0n13;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n13 ^ (R >> _7n3) * _0x71n) % _256n;
    if (R & _2n9)
      t3 ^= _1n13 << (_1n13 << /* @__PURE__ */ BigInt(j)) - _1n13;
  }
  _SHA3_IOTA.push(t3);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t3 = 0; t3 < 24; t3++) {
      const shift = SHA3_ROTL[t3];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t3];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
var Keccak = class extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
var sha3_256 = /* @__PURE__ */ (() => gen(6, 136, 256 / 8))();

// node_modules/@mysten/seal/dist/esm/kdf.js
var DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-00");
var KDF_DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-H2-00");
var DERIVE_KEY_DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-H3-00");
function hashToG1(id) {
  return G1Element.hashToCurve(flatten([DST, id]));
}
function kdf(element, nonce, id, objectId, index) {
  const hash = sha3_256.create();
  hash.update(KDF_DST);
  hash.update(element.toBytes());
  hash.update(nonce.toBytes());
  hash.update(hashToG1(id).toBytes());
  hash.update(fromHex2(objectId));
  hash.update(new Uint8Array([index]));
  return hash.digest();
}
var KeyPurpose = /* @__PURE__ */ ((KeyPurpose2) => {
  KeyPurpose2[KeyPurpose2["EncryptedRandomness"] = 0] = "EncryptedRandomness";
  KeyPurpose2[KeyPurpose2["DEM"] = 1] = "DEM";
  return KeyPurpose2;
})(KeyPurpose || {});
function tag(purpose) {
  switch (purpose) {
    case 0:
      return new Uint8Array([0]);
    case 1:
      return new Uint8Array([1]);
  }
}
function deriveKey(purpose, baseKey, encryptedShares, threshold, keyServers) {
  const hash = sha3_256.create();
  hash.update(DERIVE_KEY_DST);
  hash.update(baseKey);
  hash.update(tag(purpose));
  hash.update(new Uint8Array([threshold]));
  encryptedShares.forEach((share) => hash.update(share));
  keyServers.forEach((keyServer) => hash.update(fromHex2(keyServer)));
  return hash.digest();
}

// node_modules/@mysten/seal/dist/esm/ibe.js
var DST_POP = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-POP-00");
var IBEServers = class {
  constructor(objectIds) {
    this.objectIds = objectIds;
  }
  /**
   * The number of key servers.
   */
  size() {
    return this.objectIds.length;
  }
};
var BonehFranklinBLS12381Services = class extends IBEServers {
  constructor(services) {
    super(services.map((service) => service.objectId));
    this.publicKeys = services.map((service) => G2Element.fromBytes(service.pk));
  }
  encryptBatched(id, msgAndIndices, baseKey, threshold) {
    if (this.publicKeys.length === 0 || this.publicKeys.length !== msgAndIndices.length) {
      throw new Error("Invalid public keys");
    }
    const [r, nonce, keys] = encapBatched(this.publicKeys, id);
    const encryptedShares = msgAndIndices.map(
      ({ msg, index }, i2) => xor(msg, kdf(keys[i2], nonce, id, this.objectIds[i2], index))
    );
    const randomnessKey = deriveKey(
      KeyPurpose.EncryptedRandomness,
      baseKey,
      encryptedShares,
      threshold,
      this.objectIds
    );
    const encryptedRandomness = xor(randomnessKey, r.toBytes());
    return {
      BonehFranklinBLS12381: {
        nonce: nonce.toBytes(),
        encryptedShares,
        encryptedRandomness
      },
      $kind: "BonehFranklinBLS12381"
    };
  }
  /**
   * Returns true if the user secret key is valid for the given public key and id.
   * @param user_secret_key - The user secret key.
   * @param id - The identity.
   * @param public_key - The public key.
   * @returns True if the user secret key is valid for the given public key and id.
   */
  static verifyUserSecretKey(userSecretKey, id, publicKey) {
    const lhs = userSecretKey.pairing(G2Element.generator());
    const rhs = hashToG1(fromHex2(id)).pairing(publicKey);
    return lhs.equals(rhs);
  }
  /**
   * Identity-based decryption.
   *
   * @param nonce The encryption nonce.
   * @param sk The user secret key.
   * @param ciphertext The encrypted message.
   * @param info An info parameter also included in the KDF.
   * @returns The decrypted message.
   */
  static decrypt(nonce, sk, ciphertext, id, [objectId, index]) {
    return xor(ciphertext, kdf(decap(nonce, sk), nonce, id, objectId, index));
  }
};
function encapBatched(publicKeys, id) {
  if (publicKeys.length === 0) {
    throw new Error("No public keys provided");
  }
  const r = Scalar.random();
  const nonce = G2Element.generator().multiply(r);
  const gid = hashToG1(id).multiply(r);
  return [r, nonce, publicKeys.map((public_key) => gid.pairing(public_key))];
}
function decap(nonce, usk) {
  return usk.pairing(nonce);
}

// node_modules/@mysten/seal/dist/esm/version.js
var PACKAGE_VERSION2 = "0.4.5";

// node_modules/@mysten/seal/dist/esm/key-server.js
var KeyServerType = /* @__PURE__ */ ((KeyServerType2) => {
  KeyServerType2[KeyServerType2["BonehFranklinBLS12381"] = 0] = "BonehFranklinBLS12381";
  return KeyServerType2;
})(KeyServerType || {});
var SERVER_VERSION_REQUIREMENT = new Version("0.2.0");
function getAllowlistedKeyServers(network) {
  if (network === "testnet") {
    return [
      "0xb35a7228d8cf224ad1e828c0217c95a5153bafc2906d6f9c178197dce26fbcf8",
      "0x2d6cde8a9d9a65bde3b0a346566945a63b4bfb70e9a06c41bdb70807e2502b06"
    ];
  } else {
    throw new UnsupportedNetworkError(`Unsupported network ${network}`);
  }
}
async function retrieveKeyServers({
  objectIds,
  client
}) {
  return await Promise.all(
    objectIds.map(async (objectId) => {
      let res;
      try {
        res = await client.core.getObject({
          objectId
        });
      } catch (e3) {
        throw new InvalidGetObjectError(`KeyServer ${objectId} not found; ${e3.message}`);
      }
      const ks = KeyServerMove.parse(res.object.content);
      if (ks.keyType !== 0) {
        throw new UnsupportedFeatureError(`Unsupported key type ${ks.keyType}`);
      }
      return {
        objectId,
        name: ks.name,
        url: ks.url,
        keyType: 0,
        pk: new Uint8Array(ks.pk)
      };
    })
  );
}
async function verifyKeyServer(server, timeout) {
  const requestId = crypto.randomUUID();
  const response = await fetch(server.url + "/v1/service", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Request-Id": requestId,
      "Client-Sdk-Type": "typescript",
      "Client-Sdk-Version": PACKAGE_VERSION2
    },
    signal: AbortSignal.timeout(timeout)
  });
  await SealAPIError.assertResponse(response, requestId);
  verifyKeyServerVersion(response);
  const serviceResponse = await response.json();
  if (serviceResponse.service_id !== server.objectId) {
    return false;
  }
  const fullMsg = flatten([DST_POP, server.pk, fromHex2(server.objectId)]);
  return bls12_381.verifyShortSignature(fromBase642(serviceResponse.pop), fullMsg, server.pk);
}
function verifyKeyServerVersion(response) {
  const keyServerVersion = response.headers.get("X-KeyServer-Version");
  if (keyServerVersion == null) {
    throw new InvalidKeyServerVersionError("Key server version not found");
  }
  if (new Version(keyServerVersion).older_than(SERVER_VERSION_REQUIREMENT)) {
    throw new InvalidKeyServerVersionError(
      `Key server version ${keyServerVersion} is not supported`
    );
  }
}
var BonehFranklinBLS12381DerivedKey = class {
  constructor(key2) {
    this.key = key2;
    this.representation = toHex2(key2.toBytes());
  }
  toString() {
    return this.representation;
  }
};

// node_modules/shamir-secret-sharing/esm/csprng.js
function getRandomBytes(numBytes) {
  return crypto.getRandomValues(new Uint8Array(numBytes));
}

// node_modules/shamir-secret-sharing/esm/index.js
var LOG_TABLE = new Uint8Array([
  0,
  255,
  200,
  8,
  145,
  16,
  208,
  54,
  90,
  62,
  216,
  67,
  153,
  119,
  254,
  24,
  35,
  32,
  7,
  112,
  161,
  108,
  12,
  127,
  98,
  139,
  64,
  70,
  199,
  75,
  224,
  14,
  235,
  22,
  232,
  173,
  207,
  205,
  57,
  83,
  106,
  39,
  53,
  147,
  212,
  78,
  72,
  195,
  43,
  121,
  84,
  40,
  9,
  120,
  15,
  33,
  144,
  135,
  20,
  42,
  169,
  156,
  214,
  116,
  180,
  124,
  222,
  237,
  177,
  134,
  118,
  164,
  152,
  226,
  150,
  143,
  2,
  50,
  28,
  193,
  51,
  238,
  239,
  129,
  253,
  48,
  92,
  19,
  157,
  41,
  23,
  196,
  17,
  68,
  140,
  128,
  243,
  115,
  66,
  30,
  29,
  181,
  240,
  18,
  209,
  91,
  65,
  162,
  215,
  44,
  233,
  213,
  89,
  203,
  80,
  168,
  220,
  252,
  242,
  86,
  114,
  166,
  101,
  47,
  159,
  155,
  61,
  186,
  125,
  194,
  69,
  130,
  167,
  87,
  182,
  163,
  122,
  117,
  79,
  174,
  63,
  55,
  109,
  71,
  97,
  190,
  171,
  211,
  95,
  176,
  88,
  175,
  202,
  94,
  250,
  133,
  228,
  77,
  138,
  5,
  251,
  96,
  183,
  123,
  184,
  38,
  74,
  103,
  198,
  26,
  248,
  105,
  37,
  179,
  219,
  189,
  102,
  221,
  241,
  210,
  223,
  3,
  141,
  52,
  217,
  146,
  13,
  99,
  85,
  170,
  73,
  236,
  188,
  149,
  60,
  132,
  11,
  245,
  230,
  231,
  229,
  172,
  126,
  110,
  185,
  249,
  218,
  142,
  154,
  201,
  36,
  225,
  10,
  21,
  107,
  58,
  160,
  81,
  244,
  234,
  178,
  151,
  158,
  93,
  34,
  136,
  148,
  206,
  25,
  1,
  113,
  76,
  165,
  227,
  197,
  49,
  187,
  204,
  31,
  45,
  59,
  82,
  111,
  246,
  46,
  137,
  247,
  192,
  104,
  27,
  100,
  4,
  6,
  191,
  131,
  56
]);
var EXP_TABLE = new Uint8Array([
  1,
  229,
  76,
  181,
  251,
  159,
  252,
  18,
  3,
  52,
  212,
  196,
  22,
  186,
  31,
  54,
  5,
  92,
  103,
  87,
  58,
  213,
  33,
  90,
  15,
  228,
  169,
  249,
  78,
  100,
  99,
  238,
  17,
  55,
  224,
  16,
  210,
  172,
  165,
  41,
  51,
  89,
  59,
  48,
  109,
  239,
  244,
  123,
  85,
  235,
  77,
  80,
  183,
  42,
  7,
  141,
  255,
  38,
  215,
  240,
  194,
  126,
  9,
  140,
  26,
  106,
  98,
  11,
  93,
  130,
  27,
  143,
  46,
  190,
  166,
  29,
  231,
  157,
  45,
  138,
  114,
  217,
  241,
  39,
  50,
  188,
  119,
  133,
  150,
  112,
  8,
  105,
  86,
  223,
  153,
  148,
  161,
  144,
  24,
  187,
  250,
  122,
  176,
  167,
  248,
  171,
  40,
  214,
  21,
  142,
  203,
  242,
  19,
  230,
  120,
  97,
  63,
  137,
  70,
  13,
  53,
  49,
  136,
  163,
  65,
  128,
  202,
  23,
  95,
  83,
  131,
  254,
  195,
  155,
  69,
  57,
  225,
  245,
  158,
  25,
  94,
  182,
  207,
  75,
  56,
  4,
  185,
  43,
  226,
  193,
  74,
  221,
  72,
  12,
  208,
  125,
  61,
  88,
  222,
  124,
  216,
  20,
  107,
  135,
  71,
  232,
  121,
  132,
  115,
  60,
  189,
  146,
  201,
  35,
  139,
  151,
  149,
  68,
  220,
  173,
  64,
  101,
  134,
  162,
  164,
  204,
  127,
  236,
  192,
  175,
  145,
  253,
  247,
  79,
  129,
  47,
  91,
  234,
  168,
  28,
  2,
  209,
  152,
  113,
  237,
  37,
  227,
  36,
  6,
  104,
  179,
  147,
  44,
  111,
  62,
  108,
  10,
  184,
  206,
  174,
  116,
  177,
  66,
  180,
  30,
  211,
  73,
  233,
  156,
  200,
  198,
  199,
  34,
  110,
  219,
  32,
  191,
  67,
  81,
  82,
  102,
  178,
  118,
  96,
  218,
  197,
  243,
  246,
  170,
  205,
  154,
  160,
  117,
  84,
  14,
  1
]);
function add2(a3, b) {
  if (!Number.isInteger(a3) || a3 < 0 || a3 > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  return a3 ^ b;
}
function div(a3, b) {
  if (!Number.isInteger(a3) || a3 < 0 || a3 > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (b === 0) {
    throw new Error("cannot divide by zero");
  }
  const logA = LOG_TABLE[a3];
  const logB = LOG_TABLE[b];
  const diff2 = (logA - logB + 255) % 255;
  const result = EXP_TABLE[diff2];
  return a3 === 0 ? 0 : result;
}
function mult(a3, b) {
  if (!Number.isInteger(a3) || a3 < 0 || a3 > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  const logA = LOG_TABLE[a3];
  const logB = LOG_TABLE[b];
  const sum = (logA + logB) % 255;
  const result = EXP_TABLE[sum];
  return a3 === 0 || b === 0 ? 0 : result;
}
function interpolatePolynomial(xSamples, ySamples, x) {
  if (xSamples.length !== ySamples.length) {
    throw new Error("sample length mistmatch");
  }
  const limit = xSamples.length;
  let basis = 0;
  let result = 0;
  for (let i2 = 0; i2 < limit; i2++) {
    basis = 1;
    for (let j = 0; j < limit; ++j) {
      if (i2 === j) {
        continue;
      }
      const num = add2(x, xSamples[j]);
      const denom = add2(xSamples[i2], xSamples[j]);
      const term = div(num, denom);
      basis = mult(basis, term);
    }
    result = add2(result, mult(ySamples[i2], basis));
  }
  return result;
}
function evaluate(coefficients, x, degree) {
  if (x === 0) {
    throw new Error("cannot evaluate secret polynomial at zero");
  }
  let result = coefficients[degree];
  for (let i2 = degree - 1; i2 >= 0; i2--) {
    const coefficient = coefficients[i2];
    result = add2(mult(result, x), coefficient);
  }
  return result;
}
function getRandomByte() {
  return getRandomBytes(1)[0];
}
function getNonZeroRandomByte() {
  while (true) {
    const byte = getRandomByte();
    if (byte > 0) {
      return byte;
    }
  }
}
function newCoefficients(intercept, degree) {
  const coefficients = new Uint8Array(degree + 1);
  coefficients[0] = intercept;
  for (let i2 = 1; i2 <= degree; i2++) {
    const coefficientTMinus1 = i2 === degree;
    coefficients[i2] = coefficientTMinus1 ? getNonZeroRandomByte() : getRandomByte();
  }
  return coefficients;
}
function newCoordinates() {
  const coordinates = new Uint8Array(255);
  for (let i2 = 0; i2 < 255; i2++) {
    coordinates[i2] = i2 + 1;
  }
  const randomIndices = getRandomBytes(255);
  for (let i2 = 0; i2 < 255; i2++) {
    const j = randomIndices[i2] % 255;
    const temp = coordinates[i2];
    coordinates[i2] = coordinates[j];
    coordinates[j] = temp;
  }
  return coordinates;
}
var AssertArgument = {
  instanceOf(object2, constructor, message) {
    if (object2.constructor !== constructor) {
      throw new TypeError(message);
    }
  },
  inRange(n2, start, until, message) {
    if (!(start < until && n2 >= start && n2 < until)) {
      throw new RangeError(message);
    }
  },
  greaterThanOrEqualTo(a3, b, message) {
    if (a3 < b) {
      throw new Error(message);
    }
  },
  equalTo(a3, b, message) {
    if (a3 !== b) {
      throw new Error(message);
    }
  }
};
async function split2(secret, shares, threshold) {
  AssertArgument.instanceOf(secret, Uint8Array, "secret must be a Uint8Array");
  AssertArgument.greaterThanOrEqualTo(secret.byteLength, 1, "secret cannot be empty");
  AssertArgument.instanceOf(shares, Number, "shares must be a number");
  AssertArgument.inRange(shares, 2, 256, "shares must be at least 2 and at most 255");
  AssertArgument.instanceOf(threshold, Number, "threshold must be a number");
  AssertArgument.inRange(threshold, 2, 256, "threshold must be at least 2 and at most 255");
  AssertArgument.greaterThanOrEqualTo(shares, threshold, "shares cannot be less than threshold");
  const result = [];
  const secretLength = secret.byteLength;
  const xCoordinates = newCoordinates();
  for (let i2 = 0; i2 < shares; i2++) {
    const share = new Uint8Array(secretLength + 1);
    share[secretLength] = xCoordinates[i2];
    result.push(share);
  }
  const degree = threshold - 1;
  for (let i2 = 0; i2 < secretLength; i2++) {
    const byte = secret[i2];
    const coefficients = newCoefficients(byte, degree);
    for (let j = 0; j < shares; ++j) {
      const x = xCoordinates[j];
      const y = evaluate(coefficients, x, degree);
      result[j][i2] = y;
    }
  }
  return result;
}
async function combine(shares) {
  AssertArgument.instanceOf(shares, Array, "shares must be an Array");
  AssertArgument.inRange(shares.length, 2, 256, "shares must have at least 2 and at most 255 elements");
  const share1 = shares[0];
  AssertArgument.instanceOf(share1, Uint8Array, "each share must be a Uint8Array");
  for (const share of shares) {
    AssertArgument.instanceOf(share, Uint8Array, "each share must be a Uint8Array");
    AssertArgument.greaterThanOrEqualTo(share.byteLength, 2, "each share must be at least 2 bytes");
    AssertArgument.equalTo(share.byteLength, share1.byteLength, "all shares must have the same byte length");
  }
  const sharesLength = shares.length;
  const shareLength = share1.byteLength;
  const secretLength = shareLength - 1;
  const secret = new Uint8Array(secretLength);
  const xSamples = new Uint8Array(sharesLength);
  const ySamples = new Uint8Array(sharesLength);
  const samples = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < sharesLength; i2++) {
    const share = shares[i2];
    const sample = share[shareLength - 1];
    if (samples.has(sample)) {
      throw new Error("shares must contain unique values but a duplicate was found");
    }
    samples.add(sample);
    xSamples[i2] = sample;
  }
  for (let i2 = 0; i2 < secretLength; i2++) {
    for (let j = 0; j < sharesLength; ++j) {
      ySamples[j] = shares[j][i2];
    }
    secret[i2] = interpolatePolynomial(xSamples, ySamples, 0);
  }
  return secret;
}

// node_modules/@noble/curves/esm/abstract/utils.js
var equalBytes3 = equalBytes2;

// node_modules/@mysten/seal/dist/esm/dem.js
var iv = Uint8Array.from([
  138,
  55,
  153,
  253,
  198,
  46,
  121,
  219,
  160,
  128,
  89,
  7,
  214,
  156,
  148,
  220
]);
async function generateAesKey() {
  const key2 = await crypto.subtle.generateKey(
    {
      name: "AES-GCM",
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
  return await crypto.subtle.exportKey("raw", key2).then((keyData) => new Uint8Array(keyData));
}
var AesGcm256 = class {
  constructor(msg, aad) {
    this.plaintext = msg;
    this.aad = aad;
  }
  generateKey() {
    return generateAesKey();
  }
  async encrypt(key2) {
    const aesCryptoKey = await crypto.subtle.importKey("raw", key2, "AES-GCM", false, ["encrypt"]);
    const blob = new Uint8Array(
      await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv,
          additionalData: this.aad
        },
        aesCryptoKey,
        this.plaintext
      )
    );
    return {
      Aes256Gcm: {
        blob,
        aad: this.aad ?? []
      }
    };
  }
  static async decrypt(key2, ciphertext) {
    if (!("Aes256Gcm" in ciphertext)) {
      throw new InvalidCiphertextError(`Invalid ciphertext ${ciphertext}`);
    }
    try {
      const aesCryptoKey = await crypto.subtle.importKey("raw", key2, "AES-GCM", false, ["decrypt"]);
      return new Uint8Array(
        await crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv,
            additionalData: new Uint8Array(ciphertext.Aes256Gcm.aad ?? [])
          },
          aesCryptoKey,
          new Uint8Array(ciphertext.Aes256Gcm.blob)
        )
      );
    } catch (e3) {
      throw new DecryptionError(`Decryption failed`);
    }
  }
};
var Hmac256Ctr = class {
  constructor(msg, aad) {
    this.plaintext = msg;
    this.aad = aad;
  }
  generateKey() {
    return generateAesKey();
  }
  async encrypt(key2) {
    const blob = Hmac256Ctr.encryptInCtrMode(key2, this.plaintext);
    const mac = Hmac256Ctr.computeMac(key2, this.aad, blob);
    return {
      Hmac256Ctr: {
        blob,
        mac,
        aad: this.aad ?? []
      }
    };
  }
  static async decrypt(key2, ciphertext) {
    if (!("Hmac256Ctr" in ciphertext)) {
      throw new InvalidCiphertextError(`Invalid ciphertext ${ciphertext}`);
    }
    const aad = new Uint8Array(ciphertext.Hmac256Ctr.aad ?? []);
    const blob = new Uint8Array(ciphertext.Hmac256Ctr.blob);
    const mac = Hmac256Ctr.computeMac(key2, aad, blob);
    if (!equalBytes3(mac, new Uint8Array(ciphertext.Hmac256Ctr.mac))) {
      throw new DecryptionError(`Invalid MAC ${mac}`);
    }
    return Hmac256Ctr.encryptInCtrMode(key2, blob);
  }
  static computeMac(key2, aad, ciphertext) {
    const macInput = flatten([MacKeyTag, toBytes2(aad.length), aad, ciphertext]);
    const mac = hmac(sha3_256, key2, macInput);
    return mac;
  }
  static encryptInCtrMode(key2, msg) {
    const blockSize = 32;
    const result = new Uint8Array(msg.length);
    for (let i2 = 0; i2 * blockSize < msg.length; i2++) {
      const block2 = msg.subarray(i2 * blockSize, (i2 + 1) * blockSize);
      const mask = hmac(sha3_256, key2, flatten([EncryptionKeyTag, toBytes2(i2)]));
      const encryptedBlock = xorUnchecked(block2, mask);
      result.set(encryptedBlock, i2 * blockSize);
    }
    return result;
  }
};
function toBytes2(n2) {
  return bcs2.u64().serialize(n2).toBytes();
}
var EncryptionKeyTag = new TextEncoder().encode("HMAC-CTR-ENC");
var MacKeyTag = new TextEncoder().encode("HMAC-CTR-MAC");

// node_modules/@mysten/seal/dist/esm/decrypt.js
async function decrypt({ encryptedObject, keys }) {
  if (!encryptedObject.encryptedShares.BonehFranklinBLS12381) {
    throw new UnsupportedFeatureError("Encryption mode not supported");
  }
  const fullId = createFullId(encryptedObject.packageId, encryptedObject.id);
  const inKeystore = encryptedObject.services.map((_, i2) => i2).filter((i2) => keys.has(`${fullId}:${encryptedObject.services[i2][0]}`));
  if (inKeystore.length < encryptedObject.threshold) {
    throw new Error("Not enough shares. Please fetch more keys.");
  }
  const encryptedShares = encryptedObject.encryptedShares.BonehFranklinBLS12381.encryptedShares;
  if (encryptedShares.length !== encryptedObject.services.length) {
    throw new InvalidCiphertextError(
      `Mismatched shares ${encryptedShares.length} and services ${encryptedObject.services.length}`
    );
  }
  const nonce = G2Element.fromBytes(encryptedObject.encryptedShares.BonehFranklinBLS12381.nonce);
  const shares = inKeystore.map((i2) => {
    const [objectId, index] = encryptedObject.services[i2];
    const share = BonehFranklinBLS12381Services.decrypt(
      nonce,
      keys.get(`${fullId}:${objectId}`),
      encryptedShares[i2],
      fromHex2(fullId),
      [objectId, index]
    );
    return { index, share };
  });
  const baseKey = await combine2(shares);
  const demKey = deriveKey(
    KeyPurpose.DEM,
    baseKey,
    encryptedObject.encryptedShares.BonehFranklinBLS12381.encryptedShares,
    encryptedObject.threshold,
    encryptedObject.services.map(([objectId, _]) => objectId)
  );
  if (encryptedObject.ciphertext.Aes256Gcm) {
    return AesGcm256.decrypt(demKey, encryptedObject.ciphertext);
  } else if (encryptedObject.ciphertext.Hmac256Ctr) {
    return Hmac256Ctr.decrypt(demKey, encryptedObject.ciphertext);
  } else if (encryptedObject.ciphertext.Plain) {
    return demKey;
  } else {
    throw new InvalidCiphertextError("Invalid ciphertext type");
  }
}
async function combine2(shares) {
  if (shares.length === 0) {
    throw new Error("Invalid shares length");
  } else if (shares.length === 1) {
    return Promise.resolve(shares[0].share);
  }
  return combine(
    shares.map(({ index, share }) => flatten([share, new Uint8Array([index])]))
  );
}

// node_modules/@mysten/seal/dist/esm/encrypt.js
var MAX_U8 = 255;
async function encrypt({
  keyServers,
  kemType,
  threshold,
  packageId,
  id,
  encryptionInput
}) {
  if (keyServers.length < threshold || threshold === 0 || keyServers.length > MAX_U8 || threshold > MAX_U8 || !isValidSuiObjectId2(packageId)) {
    throw new UserError(
      `Invalid key servers or threshold ${threshold} for ${keyServers.length} key servers for package ${packageId}`
    );
  }
  const baseKey = await encryptionInput.generateKey();
  const shares = await split3(baseKey, keyServers.length, threshold);
  const fullId = createFullId(packageId, id);
  const encryptedShares = encryptBatched(
    keyServers,
    kemType,
    fromHex2(fullId),
    shares.map(({ share, index }) => ({
      msg: share,
      index
    })),
    baseKey,
    threshold
  );
  const demKey = deriveKey(
    KeyPurpose.DEM,
    baseKey,
    encryptedShares.BonehFranklinBLS12381.encryptedShares,
    threshold,
    keyServers.map(({ objectId }) => objectId)
  );
  const ciphertext = await encryptionInput.encrypt(demKey);
  const services = keyServers.map(({ objectId }, i2) => [
    objectId,
    shares[i2].index
  ]);
  return {
    encryptedObject: EncryptedObject.serialize({
      version: 0,
      packageId,
      id,
      services,
      threshold,
      encryptedShares,
      ciphertext
    }).toBytes(),
    key: demKey
  };
}
var KemType = /* @__PURE__ */ ((KemType2) => {
  KemType2[KemType2["BonehFranklinBLS12381DemCCA"] = 0] = "BonehFranklinBLS12381DemCCA";
  return KemType2;
})(KemType || {});
var DemType = /* @__PURE__ */ ((DemType2) => {
  DemType2[DemType2["AesGcm256"] = 0] = "AesGcm256";
  DemType2[DemType2["Hmac256Ctr"] = 1] = "Hmac256Ctr";
  return DemType2;
})(DemType || {});
function encryptBatched(keyServers, kemType, id, msgs, baseKey, threshold) {
  switch (kemType) {
    case 0:
      return new BonehFranklinBLS12381Services(keyServers).encryptBatched(
        id,
        msgs,
        baseKey,
        threshold
      );
  }
}
async function split3(secret, n2, threshold) {
  if (n2 === 0 || threshold === 0 || threshold > n2) {
    throw new Error("Invalid threshold or number of shares");
  } else if (threshold === 1) {
    const share = secret;
    const result = [];
    for (let index = 1; index <= n2; index++) {
      result.push({ share, index });
    }
    return Promise.resolve(result);
  }
  return split2(secret, n2, threshold).then(
    (share) => share.map((s) => ({
      share: s.subarray(0, s.length - 1),
      // split() returns the share index in the last byte. See https://github.com/privy-io/shamir-secret-sharing/blob/b59534d03e66d44ae36fc074aaf0684aa39c7505/src/index.ts#L247.
      index: s[s.length - 1]
    }))
  );
}

// node_modules/@mysten/seal/dist/esm/elgamal.js
function elgamalDecrypt(sk, [c0, c1]) {
  return decrypt2(Scalar.fromBytes(sk), [
    G1Element.fromBytes(c0),
    G1Element.fromBytes(c1)
  ]).toBytes();
}
function decrypt2(sk, [c0, c1]) {
  return c1.subtract(c0.multiply(sk));
}
function generateSecretKey() {
  return Scalar.random().toBytes();
}
function toPublicKey(sk) {
  return G1Element.generator().multiply(Scalar.fromBytes(sk)).toBytes();
}
function toVerificationKey(sk) {
  return G2Element.generator().multiply(Scalar.fromBytes(sk)).toBytes();
}

// node_modules/@mysten/seal/dist/esm/keys.js
async function fetchKeysForAllIds(url, requestSig, txBytes, encKey, certificate, timeout, signal) {
  const encKeyPk = toPublicKey(encKey);
  const encVerificationKey = toVerificationKey(encKey);
  const body = {
    ptb: toBase642(txBytes.slice(1)),
    // removes the byte of the transaction type version
    enc_key: toBase642(encKeyPk),
    enc_verification_key: toBase642(encVerificationKey),
    request_signature: requestSig,
    // already b64
    certificate
  };
  const timeoutSignal = AbortSignal.timeout(timeout);
  const combinedSignal = signal ? AbortSignal.any([signal, timeoutSignal]) : timeoutSignal;
  const requestId = crypto.randomUUID();
  const response = await fetch(url + "/v1/fetch_key", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Request-Id": requestId,
      "Client-Sdk-Type": "typescript",
      "Client-Sdk-Version": PACKAGE_VERSION2
    },
    body: JSON.stringify(body),
    signal: combinedSignal
  });
  await SealAPIError.assertResponse(response, requestId);
  const resp = await response.json();
  verifyKeyServerVersion(response);
  return resp.decryption_keys.map((dk) => ({
    fullId: toHex2(dk.id),
    key: elgamalDecrypt(encKey, dk.encrypted_key.map(fromBase642))
  }));
}

// node_modules/@mysten/seal/dist/esm/client.js
var __typeError12 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck12 = (obj, member, msg) => member.has(obj) || __typeError12("Cannot " + msg);
var __privateGet11 = (obj, member, getter) => (__accessCheck12(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd12 = (obj, member, value2) => member.has(obj) ? __typeError12("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet11 = (obj, member, value2, setter) => (__accessCheck12(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod7 = (obj, member, method) => (__accessCheck12(obj, member, "access private method"), method);
var _suiClient;
var _weights;
var _keyServers;
var _verifyKeyServers;
var _cachedKeys;
var _timeout;
var _totalWeight;
var _SealClient_instances;
var createEncryptionInput_fn;
var weight_fn;
var validateEncryptionServices_fn;
var getWeightedKeyServers_fn;
var loadKeyServers_fn;
var _SealClient = class _SealClient2 {
  constructor(options) {
    __privateAdd12(this, _SealClient_instances);
    __privateAdd12(this, _suiClient);
    __privateAdd12(this, _weights);
    __privateAdd12(this, _keyServers, null);
    __privateAdd12(this, _verifyKeyServers);
    __privateAdd12(this, _cachedKeys, /* @__PURE__ */ new Map());
    __privateAdd12(this, _timeout);
    __privateAdd12(this, _totalWeight);
    __privateSet11(this, _suiClient, options.suiClient);
    if (new Set(options.serverObjectIds.map(([objectId, _]) => objectId)).size !== options.serverObjectIds.length) {
      throw new InvalidClientOptionsError("Duplicate object IDs");
    }
    __privateSet11(this, _weights, new Map(options.serverObjectIds));
    __privateSet11(this, _totalWeight, options.serverObjectIds.map(([_, weight]) => weight).reduce((sum, term) => sum + term, 0));
    __privateSet11(this, _verifyKeyServers, options.verifyKeyServers ?? true);
    __privateSet11(this, _timeout, options.timeout ?? 1e4);
  }
  static experimental_asClientExtension(options) {
    return {
      name: "seal",
      register: (client) => {
        return new _SealClient2({
          suiClient: client,
          ...options
        });
      }
    };
  }
  /**
   * Return an encrypted message under the identity.
   *
   * @param kemType - The type of KEM to use.
   * @param demType - The type of DEM to use.
   * @param threshold - The threshold for the TSS encryption.
   * @param packageId - the packageId namespace.
   * @param id - the identity to use.
   * @param data - the data to encrypt.
   * @param aad - optional additional authenticated data.
   * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
   * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
   */
  async encrypt({
    kemType = KemType.BonehFranklinBLS12381DemCCA,
    demType = DemType.AesGcm256,
    threshold,
    packageId,
    id,
    data,
    aad = new Uint8Array()
  }) {
    return encrypt({
      keyServers: await __privateMethod7(this, _SealClient_instances, getWeightedKeyServers_fn).call(this),
      kemType,
      threshold,
      packageId,
      id,
      encryptionInput: __privateMethod7(this, _SealClient_instances, createEncryptionInput_fn).call(this, demType, data, aad)
    });
  }
  /**
   * Decrypt the given encrypted bytes using cached keys.
   * Calls fetchKeys in case one or more of the required keys is not cached yet.
   * The function throws an error if the client's key servers are not a subset of
   * the encrypted object's key servers or if the threshold cannot be met.
   *
   * @param data - The encrypted bytes to decrypt.
   * @param sessionKey - The session key to use.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @returns - The decrypted plaintext corresponding to ciphertext.
   */
  async decrypt({
    data,
    sessionKey,
    txBytes
  }) {
    const encryptedObject = EncryptedObject.parse(data);
    __privateMethod7(this, _SealClient_instances, validateEncryptionServices_fn).call(this, encryptedObject.services.map((s) => s[0]), encryptedObject.threshold);
    await this.fetchKeys({
      ids: [encryptedObject.id],
      txBytes,
      sessionKey,
      threshold: encryptedObject.threshold
    });
    return decrypt({ encryptedObject, keys: __privateGet11(this, _cachedKeys) });
  }
  async getKeyServers() {
    if (!__privateGet11(this, _keyServers)) {
      __privateSet11(this, _keyServers, __privateMethod7(this, _SealClient_instances, loadKeyServers_fn).call(this).catch((error2) => {
        __privateSet11(this, _keyServers, null);
        throw error2;
      }));
    }
    return __privateGet11(this, _keyServers);
  }
  /**
   * Fetch keys from the key servers and update the cache.
   *
   * It is recommended to call this function once for all ids of all encrypted objects if
   * there are multiple, then call decrypt for each object. This avoids calling fetchKey
   * individually for each decrypt.
   *
   * @param ids - The ids of the encrypted objects.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
   */
  async fetchKeys({
    ids,
    txBytes,
    sessionKey,
    threshold
  }) {
    if (threshold > __privateGet11(this, _totalWeight) || threshold < 1) {
      throw new InvalidThresholdError(
        `Invalid threshold ${threshold} servers with weights ${__privateGet11(this, _weights)}`
      );
    }
    const keyServers = await this.getKeyServers();
    const fullIds = ids.map((id) => createFullId(sessionKey.getPackageId(), id));
    let completedWeight = 0;
    const remainingKeyServers = [];
    let remainingKeyServersWeight = 0;
    for (const objectId of keyServers.keys()) {
      if (fullIds.every((fullId) => __privateGet11(this, _cachedKeys).has(`${fullId}:${objectId}`))) {
        completedWeight += __privateMethod7(this, _SealClient_instances, weight_fn).call(this, objectId);
      } else {
        remainingKeyServers.push(objectId);
        remainingKeyServersWeight += __privateMethod7(this, _SealClient_instances, weight_fn).call(this, objectId);
      }
    }
    if (completedWeight >= threshold) {
      return;
    }
    for (const objectId of remainingKeyServers) {
      const server = keyServers.get(objectId);
      if (server.keyType !== KeyServerType.BonehFranklinBLS12381) {
        throw new InvalidKeyServerError(
          `Server ${server.objectId} has invalid key type: ${server.keyType}`
        );
      }
    }
    const cert = await sessionKey.getCertificate();
    const signedRequest = await sessionKey.createRequestParams(txBytes);
    const controller = new AbortController();
    const errors = [];
    const keyFetches = remainingKeyServers.map(async (objectId) => {
      const server = keyServers.get(objectId);
      try {
        const allKeys = await fetchKeysForAllIds(
          server.url,
          signedRequest.requestSignature,
          txBytes,
          signedRequest.decryptionKey,
          cert,
          __privateGet11(this, _timeout),
          controller.signal
        );
        for (const { fullId, key: key2 } of allKeys) {
          const keyElement = G1Element.fromBytes(key2);
          if (!BonehFranklinBLS12381Services.verifyUserSecretKey(
            keyElement,
            fullId,
            G2Element.fromBytes(server.pk)
          )) {
            console.warn("Received invalid key from key server " + server.objectId);
            continue;
          }
          __privateGet11(this, _cachedKeys).set(`${fullId}:${server.objectId}`, keyElement);
        }
        if (fullIds.every((fullId) => __privateGet11(this, _cachedKeys).has(`${fullId}:${server.objectId}`))) {
          completedWeight += __privateMethod7(this, _SealClient_instances, weight_fn).call(this, objectId);
          if (completedWeight >= threshold) {
            controller.abort();
          }
        }
      } catch (error2) {
        if (!controller.signal.aborted) {
          errors.push(error2);
        }
      } finally {
        remainingKeyServersWeight -= __privateMethod7(this, _SealClient_instances, weight_fn).call(this, objectId);
        if (remainingKeyServersWeight < threshold - completedWeight) {
          controller.abort(new TooManyFailedFetchKeyRequestsError());
        }
      }
    });
    await Promise.allSettled(keyFetches);
    if (completedWeight < threshold) {
      throw toMajorityError(errors);
    }
  }
  /**
   * Get derived keys from the given services.
   *
   * @param id - The id of the encrypted object.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold.
   * @returns - Derived keys for the given services that are in the cache as a "service object ID" -> derived key map. If the call is succesful, exactly threshold keys will be returned.
   */
  async getDerivedKeys({
    kemType = KemType.BonehFranklinBLS12381DemCCA,
    id,
    txBytes,
    sessionKey,
    threshold
  }) {
    switch (kemType) {
      case KemType.BonehFranklinBLS12381DemCCA:
        const keyServers = await this.getKeyServers();
        if (threshold > __privateGet11(this, _totalWeight)) {
          throw new InvalidThresholdError(
            `Invalid threshold ${threshold} for ${__privateGet11(this, _totalWeight)} servers`
          );
        }
        await this.fetchKeys({
          ids: [id],
          txBytes,
          sessionKey,
          threshold
        });
        const fullId = createFullId(sessionKey.getPackageId(), id);
        const derivedKeys = /* @__PURE__ */ new Map();
        let weight = 0;
        for (const objectId of keyServers.keys()) {
          const cachedKey = __privateGet11(this, _cachedKeys).get(`${fullId}:${objectId}`);
          if (cachedKey) {
            derivedKeys.set(objectId, new BonehFranklinBLS12381DerivedKey(cachedKey));
            weight += __privateMethod7(this, _SealClient_instances, weight_fn).call(this, objectId);
            if (weight >= threshold) {
              break;
            }
          }
        }
        return derivedKeys;
    }
  }
};
_suiClient = /* @__PURE__ */ new WeakMap();
_weights = /* @__PURE__ */ new WeakMap();
_keyServers = /* @__PURE__ */ new WeakMap();
_verifyKeyServers = /* @__PURE__ */ new WeakMap();
_cachedKeys = /* @__PURE__ */ new WeakMap();
_timeout = /* @__PURE__ */ new WeakMap();
_totalWeight = /* @__PURE__ */ new WeakMap();
_SealClient_instances = /* @__PURE__ */ new WeakSet();
createEncryptionInput_fn = function(type2, data, aad) {
  switch (type2) {
    case DemType.AesGcm256:
      return new AesGcm256(data, aad);
    case DemType.Hmac256Ctr:
      return new Hmac256Ctr(data, aad);
  }
};
weight_fn = function(objectId) {
  return __privateGet11(this, _weights).get(objectId) ?? 0;
};
validateEncryptionServices_fn = function(services, threshold) {
  if (services.some((objectId) => {
    const countInClient = __privateMethod7(this, _SealClient_instances, weight_fn).call(this, objectId);
    return countInClient > 0 && countInClient !== count(services, objectId);
  })) {
    throw new InconsistentKeyServersError(
      `Client's key servers must be a subset of the encrypted object's key servers`
    );
  }
  if (threshold > __privateGet11(this, _totalWeight)) {
    throw new InvalidThresholdError(
      `Invalid threshold ${threshold} for ${__privateGet11(this, _totalWeight)} servers`
    );
  }
};
getWeightedKeyServers_fn = async function() {
  const keyServers = await this.getKeyServers();
  const keyServersWithMultiplicity = [];
  for (const [objectId, weight] of __privateGet11(this, _weights)) {
    const keyServer = keyServers.get(objectId);
    for (let i2 = 0; i2 < weight; i2++) {
      keyServersWithMultiplicity.push(keyServer);
    }
  }
  return keyServersWithMultiplicity;
};
loadKeyServers_fn = async function() {
  const keyServers = await retrieveKeyServers({
    objectIds: [...__privateGet11(this, _weights)].map(([objectId]) => objectId),
    client: __privateGet11(this, _suiClient)
  });
  if (keyServers.length === 0) {
    throw new InvalidKeyServerError("No key servers found");
  }
  if (__privateGet11(this, _verifyKeyServers)) {
    await Promise.all(
      keyServers.map(async (server) => {
        if (!await verifyKeyServer(server, __privateGet11(this, _timeout))) {
          throw new InvalidKeyServerError(`Key server ${server.objectId} is not valid`);
        }
      })
    );
  }
  return new Map(keyServers.map((server) => [server.objectId, server]));
};
var SealClient = _SealClient;

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n14 = BigInt(0);
var _1n14 = BigInt(1);
var _2n10 = BigInt(2);
var _8n5 = BigInt(8);
function isEdValidXY2(Fp4, CURVE, x, y) {
  const x2 = Fp4.sqr(x);
  const y2 = Fp4.sqr(y);
  const left = Fp4.add(Fp4.mul(CURVE.a, x2), y2);
  const right = Fp4.add(Fp4.ONE, Fp4.mul(CURVE.d, Fp4.mul(x2, y2)));
  return Fp4.eql(left, right);
}
function edwards2(params, extraOpts = {}) {
  const validated = _createCurveFields2("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp: Fp4, Fn: Fn3 } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor } = CURVE;
  _validateObject2(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n10 << BigInt(Fn3.BYTES * 8) - _1n14;
  const modP = (n2) => Fp4.create(n2);
  const uvRatio3 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp4.sqrt(Fp4.div(u, v)) };
    } catch (e3) {
      return { isValid: false, value: _0n14 };
    }
  });
  if (!isEdValidXY2(Fp4, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min = banZero ? _1n14 : _0n14;
    aInRange2("coordinate " + title, n2, min, MASK);
    return n2;
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized2((p, iz) => {
    const { X, Y, Z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n5 : Fp4.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp4.mul(Z, iz);
    if (is0)
      return { x: _0n14, y: _1n14 };
    if (zz !== _1n14)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized2((p) => {
    const { a: a3, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a3);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point(x, y, _1n14, modP(x * y));
    }
    // Uses algo from RFC8032 5.1.3.
    static fromBytes(bytes, zip215 = false) {
      const len = Fp4.BYTES;
      const { a: a3, d } = CURVE;
      bytes = copyBytes(_abytes2(bytes, len, "point"));
      _abool2(zip215, "zip215");
      const normed = copyBytes(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE2(normed);
      const max2 = zip215 ? MASK : Fp4.ORDER;
      aInRange2("point.y", y, _0n14, max2);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n14);
      const v = modP(d * y2 - a3);
      let { isValid, value: x } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n14) === _1n14;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n14 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromHex(bytes, zip215 = false) {
      return Point.fromBytes(ensureBytes2("point", bytes), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n10);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a3 } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n10 * modP(Z1 * Z1));
      const D = modP(a3 * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a: a3, d } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a3 * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      if (!Fn3.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p, f } = wnaf.cached(this, scalar, (p2) => normalizeZ2(Point, p2));
      return normalizeZ2(Point, [p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      if (!Fn3.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n14)
        return Point.ZERO;
      if (this.is0() || scalar === _1n14)
        return this;
      return wnaf.unsafe(this, scalar, (p) => normalizeZ2(Point, p), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE.n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n14)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp4.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n14 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ2(Point, points);
    }
    static msm(points, scalars) {
      return pippenger2(Point, Fn3, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    toRawBytes() {
      return this.toBytes();
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n14, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n14, _1n14, _1n14, _0n14);
  Point.Fp = Fp4;
  Point.Fn = Fn3;
  const wnaf = new wNAF2(Point, Fn3.BITS);
  Point.BASE.precompute(8);
  return Point;
}
var PrimeEdwardsPoint2 = class {
  constructor(ep) {
    this.ep = ep;
  }
  // Static methods that must be implemented by subclasses
  static fromBytes(_bytes3) {
    notImplemented();
  }
  static fromHex(_hex) {
    notImplemented();
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  // Common implementations
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
  /** @deprecated use `toBytes` */
  toRawBytes() {
    return this.toBytes();
  }
};
function eddsa2(Point, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject2(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp: Fp4, Fn: Fn3 } = Point;
  const randomBytes2 = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes3 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    _abool2(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash) {
    return Fn3.create(bytesToNumberLE2(hash));
  }
  function getPrivateScalar(key2) {
    const len = lengths.secretKey;
    key2 = ensureBytes2("private key", key2, len);
    const hashed = ensureBytes2("hashed private key", cHash(key2), 2 * len);
    const head = adjustScalarBytes3(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
  }
  function sign(msg, secretKey, options = {}) {
    msg = ensureBytes2("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = BASE.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = Fn3.create(r + k * scalar);
    if (!Fn3.isValid(s))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes(R, Fn3.toBytes(s));
    return _abytes2(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = lengths.signature;
    sig = ensureBytes2("signature", sig, len);
    msg = ensureBytes2("message", msg);
    publicKey = ensureBytes2("publicKey", publicKey, lengths.publicKey);
    if (zip215 !== void 0)
      _abool2(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r = sig.subarray(0, mid);
    const s = bytesToNumberLE2(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point.fromBytes(publicKey, zip215);
      R = Point.fromBytes(r, zip215);
      SB = BASE.multiplyUnsafe(s);
    } catch (error2) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size = Fp4.BYTES;
  const lengths = {
    secretKey: _size,
    publicKey: _size,
    signature: 2 * _size,
    seed: _size
  };
  function randomSecretKey(seed = randomBytes2(lengths.seed)) {
    return _abytes2(seed, lengths.seed, "seed");
  }
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isValidSecretKey(key2) {
    return isBytes(key2) && key2.length === Fn3.BYTES;
  }
  function isValidPublicKey(key2, zip215) {
    try {
      return !!Point.fromBytes(key2, zip215);
    } catch (error2) {
      return false;
    }
  }
  const utils = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */
    toMontgomery(publicKey) {
      const { y } = Point.fromBytes(publicKey);
      const size = lengths.publicKey;
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp4.div(_1n14 + y, _1n14 - y) : Fp4.div(y - _1n14, y + _1n14);
      return Fp4.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size = lengths.secretKey;
      _abytes2(secretKey, size);
      const hashed = cHash(secretKey.subarray(0, size));
      return adjustScalarBytes3(hashed).subarray(0, size);
    },
    /** @deprecated */
    randomPrivateKey: randomSecretKey,
    /** @deprecated */
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({
    keygen,
    getPublicKey,
    sign,
    verify,
    utils,
    Point,
    lengths
  });
}
function _eddsa_legacy_opts_to_new2(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp4 = c.Fp;
  const Fn3 = Field2(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp4, Fn: Fn3, uvRatio: c.uvRatio };
  const eddsaOpts = {
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy2(c, eddsa3) {
  const Point = eddsa3.Point;
  const legacy = Object.assign({}, eddsa3, {
    ExtendedPoint: Point,
    CURVE: c,
    nBitLength: Point.Fn.BITS,
    nByteLength: Point.Fn.BYTES
  });
  return legacy;
}
function twistedEdwards2(c) {
  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new2(c);
  const Point = edwards2(CURVE, curveOpts);
  const EDDSA = eddsa2(Point, hash, eddsaOpts);
  return _eddsa_new_output_to_legacy2(c, EDDSA);
}

// node_modules/@noble/curves/esm/ed25519.js
var _0n15 = /* @__PURE__ */ BigInt(0);
var _1n15 = BigInt(1);
var _2n11 = BigInt(2);
var _3n8 = BigInt(3);
var _5n4 = BigInt(5);
var _8n6 = BigInt(8);
var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var ed25519_CURVE2 = /* @__PURE__ */ (() => ({
  p: ed25519_CURVE_p,
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n6,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
}))();
function ed25519_pow_2_252_32(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE_p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow22(b2, _2n11, P) * b2 % P;
  const b5 = pow22(b4, _1n15, P) * x % P;
  const b10 = pow22(b5, _5n4, P) * b5 % P;
  const b20 = pow22(b10, _10n, P) * b10 % P;
  const b40 = pow22(b20, _20n, P) * b20 % P;
  const b80 = pow22(b40, _40n, P) * b40 % P;
  const b160 = pow22(b80, _80n, P) * b80 % P;
  const b240 = pow22(b160, _80n, P) * b80 % P;
  const b250 = pow22(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow22(b250, _2n11, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes2(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M12 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio2(u, v) {
  const P = ed25519_CURVE_p;
  const v3 = mod2(v * v * v, P);
  const v7 = mod2(v3 * v3 * v, P);
  const pow = ed25519_pow_2_252_32(u * v7).pow_p_5_8;
  let x = mod2(u * v3 * pow, P);
  const vx2 = mod2(v * x * x, P);
  const root1 = x;
  const root2 = mod2(x * ED25519_SQRT_M12, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u, P);
  const noRoot = vx2 === mod2(-u * ED25519_SQRT_M12, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE2(x, P))
    x = mod2(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp3 = /* @__PURE__ */ (() => Field2(ed25519_CURVE2.p, { isLE: true }))();
var Fn2 = /* @__PURE__ */ (() => Field2(ed25519_CURVE2.n, { isLE: true }))();
var ed25519Defaults2 = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE2,
  Fp: Fp3,
  hash: sha512,
  adjustScalarBytes: adjustScalarBytes2,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio: uvRatio2
}))();
var ed255192 = /* @__PURE__ */ (() => twistedEdwards2(ed25519Defaults2))();
var SQRT_M12 = ED25519_SQRT_M12;
var SQRT_AD_MINUS_ONE2 = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D2 = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ2 = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ2 = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt2 = (number2) => uvRatio2(_1n15, number2);
var MAX_255B2 = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE2 = (bytes) => ed255192.Point.Fp.create(bytesToNumberLE2(bytes) & MAX_255B2);
function calcElligatorRistrettoMap2(r0) {
  const { d } = ed25519_CURVE2;
  const P = ed25519_CURVE_p;
  const mod3 = (n2) => Fp3.create(n2);
  const r = mod3(SQRT_M12 * r0 * r0);
  const Ns = mod3((r + _1n15) * ONE_MINUS_D_SQ2);
  let c = BigInt(-1);
  const D = mod3((c - d * r) * mod3(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio2(Ns, D);
  let s_ = mod3(s * r0);
  if (!isNegativeLE2(s_, P))
    s_ = mod3(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod3(c * (r - _1n15) * D_MINUS_ONE_SQ2 - D);
  const s2 = s * s;
  const W0 = mod3((s + s) * D);
  const W1 = mod3(Nt * SQRT_AD_MINUS_ONE2);
  const W2 = mod3(_1n15 - s2);
  const W3 = mod3(_1n15 + s2);
  return new ed255192.Point(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
}
function ristretto255_map2(bytes) {
  abytes(bytes, 64);
  const r1 = bytes255ToNumberLE2(bytes.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap2(r1);
  const r2 = bytes255ToNumberLE2(bytes.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap2(r2);
  return new _RistrettoPoint2(R1.add(R2));
}
var _RistrettoPoint2 = class extends PrimeEdwardsPoint2 {
  constructor(ep) {
    super(ep);
  }
  static fromAffine(ap) {
    return new _RistrettoPoint2(ed255192.Point.fromAffine(ap));
  }
  assertSame(other) {
    if (!(other instanceof _RistrettoPoint2))
      throw new Error("RistrettoPoint expected");
  }
  init(ep) {
    return new _RistrettoPoint2(ep);
  }
  /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
  static hashToCurve(hex2) {
    return ristretto255_map2(ensureBytes2("ristrettoHash", hex2, 64));
  }
  static fromBytes(bytes) {
    abytes(bytes, 32);
    const { a: a3, d } = ed25519_CURVE2;
    const P = ed25519_CURVE_p;
    const mod3 = (n2) => Fp3.create(n2);
    const s = bytes255ToNumberLE2(bytes);
    if (!equalBytes2(Fp3.toBytes(s), bytes) || isNegativeLE2(s, P))
      throw new Error("invalid ristretto255 encoding 1");
    const s2 = mod3(s * s);
    const u1 = mod3(_1n15 + a3 * s2);
    const u2 = mod3(_1n15 - a3 * s2);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u2 * u2);
    const v = mod3(a3 * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt2(mod3(v * u2_2));
    const Dx = mod3(I * u2);
    const Dy = mod3(I * Dx * v);
    let x = mod3((s + s) * Dx);
    if (isNegativeLE2(x, P))
      x = mod3(-x);
    const y = mod3(u1 * Dy);
    const t3 = mod3(x * y);
    if (!isValid || isNegativeLE2(t3, P) || y === _0n15)
      throw new Error("invalid ristretto255 encoding 2");
    return new _RistrettoPoint2(new ed255192.Point(x, y, _1n15, t3));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex2) {
    return _RistrettoPoint2.fromBytes(ensureBytes2("ristrettoHex", hex2, 32));
  }
  static msm(points, scalars) {
    return pippenger2(_RistrettoPoint2, ed255192.Point.Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { X, Y, Z, T } = this.ep;
    const P = ed25519_CURVE_p;
    const mod3 = (n2) => Fp3.create(n2);
    const u1 = mod3(mod3(Z + Y) * mod3(Z - Y));
    const u2 = mod3(X * Y);
    const u2sq = mod3(u2 * u2);
    const { value: invsqrt } = invertSqrt2(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D2 = mod3(invsqrt * u2);
    const zInv = mod3(D1 * D2 * T);
    let D;
    if (isNegativeLE2(T * zInv, P)) {
      let _x = mod3(Y * SQRT_M12);
      let _y = mod3(X * SQRT_M12);
      X = _x;
      Y = _y;
      D = mod3(D1 * INVSQRT_A_MINUS_D2);
    } else {
      D = D2;
    }
    if (isNegativeLE2(X * zInv, P))
      Y = mod3(-Y);
    let s = mod3((Z - Y) * D);
    if (isNegativeLE2(s, P))
      s = mod3(-s);
    return Fp3.toBytes(s);
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    this.assertSame(other);
    const { X: X1, Y: Y1 } = this.ep;
    const { X: X2, Y: Y2 } = other.ep;
    const mod3 = (n2) => Fp3.create(n2);
    const one = mod3(X1 * Y2) === mod3(Y1 * X2);
    const two = mod3(Y1 * Y2) === mod3(X1 * X2);
    return one || two;
  }
  is0() {
    return this.equals(_RistrettoPoint2.ZERO);
  }
};
_RistrettoPoint2.BASE = /* @__PURE__ */ (() => new _RistrettoPoint2(ed255192.Point.BASE))();
_RistrettoPoint2.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint2(ed255192.Point.ZERO))();
_RistrettoPoint2.Fp = /* @__PURE__ */ (() => Fp3)();
_RistrettoPoint2.Fn = /* @__PURE__ */ (() => Fn2)();

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent2(scope, message) {
  return suiBcs2.IntentMessage(suiBcs2.fixedArray(message.length, suiBcs2.u8())).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG2 = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE2 = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
};
var SIGNATURE_FLAG_TO_SCHEME2 = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, hash });
  return { ...create(defHash), create };
}

// node_modules/@noble/curves/esm/nist.js
var p256_CURVE = {
  p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  h: BigInt(1),
  a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
  b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
};
var p384_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  h: BigInt(1),
  a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
  b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
};
var p521_CURVE = {
  p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  h: BigInt(1),
  a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
  b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};
var Fp256 = Field2(p256_CURVE.p);
var Fp384 = Field2(p384_CURVE.p);
var Fp521 = Field2(p521_CURVE.p);
var p256 = createCurve({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha256);
var p384 = createCurve({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha384);
var p521 = createCurve({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha512);

// node_modules/@noble/curves/esm/p256.js
var secp256r1 = p256;

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual2(a3, b) {
  if (a3 === b)
    return true;
  if (a3.length !== b.length) {
    return false;
  }
  for (let i2 = 0; i2 < a3.length; i2++) {
    if (a3[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
var PublicKey4 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual2(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase642(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toBase642(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent2(intent, bytes);
    const digest = blake2b2(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs2.vector(suiBcs2.u8()).serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return this.toSuiAddress() === address;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress2(
      bytesToHex(blake2b2(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
    );
  }
};
function parseSerializedKeypairSignature2(serializedSignature) {
  const bytes = fromBase642(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME2[bytes[0]];
  switch (signatureScheme) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE2[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/keypairs/passkey/publickey.js
var PASSKEY_PUBLIC_KEY_SIZE = 33;
var PASSKEY_SIGNATURE_SIZE = 64;
var SECP256R1_SPKI_HEADER = new Uint8Array([
  48,
  89,
  // SEQUENCE, length 89
  48,
  19,
  // SEQUENCE, length 19
  6,
  7,
  // OID, length 7
  42,
  134,
  72,
  206,
  61,
  2,
  1,
  // OID: 1.2.840.10045.2.1 (ecPublicKey)
  6,
  8,
  // OID, length 8
  42,
  134,
  72,
  206,
  61,
  3,
  1,
  7,
  // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)
  3,
  66,
  // BIT STRING, length 66
  0
  // no unused bits
]);
var PasskeyPublicKey = class extends PublicKey4 {
  /**
   * Create a new PasskeyPublicKey object
   * @param value passkey public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase642(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two passkey public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG2["Passkey"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    const parsed = parseSerializedPasskeySignature(signature);
    const clientDataJSON = JSON.parse(parsed.clientDataJson);
    if (clientDataJSON.type !== "webauthn.get") {
      return false;
    }
    const parsedChallenge = fromBase642(
      clientDataJSON.challenge.replace(/-/g, "+").replace(/_/g, "/")
    );
    if (!bytesEqual2(message, parsedChallenge)) {
      return false;
    }
    const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);
    if (!bytesEqual2(this.toRawBytes(), pk)) {
      return false;
    }
    const payload = new Uint8Array([...parsed.authenticatorData, ...sha2562(parsed.clientDataJson)]);
    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);
    return secp256r1.verify(sig, sha2562(payload), pk);
  }
};
PasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;
function parseSerializedPasskeySignature(signature) {
  const bytes = typeof signature === "string" ? fromBase642(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG2.Passkey) {
    throw new Error("Invalid signature scheme");
  }
  const dec = PasskeyAuthenticator2.parse(bytes.slice(1));
  return {
    signatureScheme: "Passkey",
    serializedSignature: toBase642(bytes),
    signature: bytes,
    authenticatorData: dec.authenticatorData,
    clientDataJson: dec.clientDataJson,
    userSignature: new Uint8Array(dec.userSignature),
    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))
  };
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError13 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck13 = (obj, member, msg) => member.has(obj) || __typeError13("Cannot " + msg);
var __privateGet12 = (obj, member, getter) => (__accessCheck13(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd13 = (obj, member, value2) => member.has(obj) ? __typeError13("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet12 = (obj, member, value2, setter) => (__accessCheck13(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _prefix2;
var _cache3;
var _ClientCache3 = class _ClientCache4 {
  constructor({ prefix, cache } = {}) {
    __privateAdd13(this, _prefix2);
    __privateAdd13(this, _cache3);
    __privateSet12(this, _prefix2, prefix ?? []);
    __privateSet12(this, _cache3, cache ?? /* @__PURE__ */ new Map());
  }
  read(key2, load) {
    const cacheKey = [__privateGet12(this, _prefix2), ...key2].join(":");
    if (__privateGet12(this, _cache3).has(cacheKey)) {
      return __privateGet12(this, _cache3).get(cacheKey);
    }
    const result = load();
    __privateGet12(this, _cache3).set(cacheKey, result);
    if (typeof result === "object" && result !== null && "then" in result) {
      return Promise.resolve(result).then((v) => {
        __privateGet12(this, _cache3).set(cacheKey, v);
        return v;
      }).catch((err) => {
        __privateGet12(this, _cache3).delete(cacheKey);
        throw err;
      });
    }
    return result;
  }
  clear(prefix) {
    const prefixKey = [...__privateGet12(this, _prefix2), ...prefix ?? []].join(":");
    if (!prefixKey) {
      __privateGet12(this, _cache3).clear();
      return;
    }
    for (const key2 of __privateGet12(this, _cache3).keys()) {
      if (key2.startsWith(prefixKey)) {
        __privateGet12(this, _cache3).delete(key2);
      }
    }
  }
  scope(prefix) {
    return new _ClientCache4({
      prefix: [...__privateGet12(this, _prefix2), ...Array.isArray(prefix) ? prefix : [prefix]],
      cache: __privateGet12(this, _cache3)
    });
  }
};
_prefix2 = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
var ClientCache2 = _ClientCache3;

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient2 = class {
  constructor({ network }) {
    this.cache = new ClientCache2();
    this.network = network;
  }
  $extend(...registrations) {
    return Object.create(
      this,
      Object.fromEntries(
        registrations.map((registration) => {
          if ("experimental_asClientExtension" in registration) {
            const { name: name2, register } = registration.experimental_asClientExtension();
            return [name2, { value: register(this) }];
          }
          return [registration.name, { value: registration.register(this) }];
        })
      )
    );
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/experimental/core.js
var Experimental_CoreClient2 = class extends Experimental_BaseClient2 {
  constructor() {
    super(...arguments);
    this.core = this;
  }
  async getObject(options) {
    const { objectId } = options;
    const {
      objects: [result]
    } = await this.getObjects({ objectIds: [objectId], signal: options.signal });
    if (result instanceof Error) {
      throw result;
    }
    return { object: result };
  }
  async getDynamicField(options) {
    const fieldId = deriveDynamicFieldID2(
      options.parentId,
      TypeTagSerializer2.parseFromStr(options.name.type),
      options.name.bcs
    );
    const {
      objects: [fieldObject]
    } = await this.getObjects({
      objectIds: [fieldId],
      signal: options.signal
    });
    if (fieldObject instanceof Error) {
      throw fieldObject;
    }
    const fieldType = parseStructTag2(fieldObject.type);
    return {
      dynamicField: {
        id: fieldObject.id,
        digest: fieldObject.digest,
        version: fieldObject.version,
        type: fieldObject.type,
        name: {
          type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag2(fieldType.typeParams[0]),
          bcs: options.name.bcs
        },
        value: {
          type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag2(fieldType.typeParams[1]),
          bcs: fieldObject.content.slice(SUI_ADDRESS_LENGTH2 + options.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    ...input
  }) {
    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
    const abortPromise = new Promise((_, reject) => {
      abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
    });
    abortPromise.catch(() => {
    });
    while (true) {
      abortSignal.throwIfAborted();
      try {
        return await this.getTransaction({
          ...input,
          signal: abortSignal
        });
      } catch (e3) {
        await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
      }
    }
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum2(options) {
  const unionOptions = Object.entries(options).map(([key2, value2]) => object({ [key2]: value2 }));
  return pipe(
    union(unionOptions),
    transform((value2) => ({
      ...value2,
      $kind: Object.keys(value2)[0]
    }))
  );
}
var SuiAddress2 = pipe(
  string(),
  transform((value2) => normalizeSuiAddress2(value2)),
  check(isValidSuiAddress2)
);
var ObjectID2 = SuiAddress2;
var BCSBytes2 = string();
var JsonU642 = pipe(
  union([string(), pipe(number(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRef2 = object({
  objectId: SuiAddress2,
  version: JsonU642,
  digest: string()
});
var Argument4 = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number(), integer()) }),
    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
  ]),
  transform((value2) => ({
    ...value2,
    $kind: Object.keys(value2)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasData4 = object({
  budget: nullable(JsonU642),
  price: nullable(JsonU642),
  owner: nullable(SuiAddress2),
  payment: nullable(array(ObjectRef2))
});
var StructTag4 = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBody = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBody))
    })
  }),
  object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignature = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBody
});
var ProgrammableMoveCall4 = object({
  package: ObjectID2,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument4),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignature)))
});
var $Intent3 = object({
  name: string(),
  inputs: record(string(), union([Argument4, array(Argument4)])),
  data: record(string(), unknown())
});
var Command4 = safeEnum2({
  MoveCall: ProgrammableMoveCall4,
  TransferObjects: object({
    objects: array(Argument4),
    address: Argument4
  }),
  SplitCoins: object({
    coin: Argument4,
    amounts: array(Argument4)
  }),
  MergeCoins: object({
    destination: Argument4,
    sources: array(Argument4)
  }),
  Publish: object({
    modules: array(BCSBytes2),
    dependencies: array(ObjectID2)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument4)
  }),
  Upgrade: object({
    modules: array(BCSBytes2),
    dependencies: array(ObjectID2),
    package: ObjectID2,
    ticket: Argument4
  }),
  $Intent: $Intent3
});
var ObjectArg5 = safeEnum2({
  ImmOrOwnedObject: ObjectRef2,
  SharedObject: object({
    objectId: ObjectID2,
    // snake case in rust
    initialSharedVersion: JsonU642,
    mutable: boolean()
  }),
  Receiving: ObjectRef2
});
var CallArg4 = safeEnum2({
  Object: ObjectArg5,
  Pure: object({
    bytes: BCSBytes2
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID2,
    version: optional(nullable(JsonU642)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU642))
  })
});
var NormalizedCallArg3 = safeEnum2({
  Object: ObjectArg5,
  Pure: object({
    bytes: BCSBytes2
  })
});
var TransactionExpiration6 = safeEnum2({
  None: literal(true),
  Epoch: JsonU642
});
var TransactionData3 = object({
  version: literal(2),
  sender: nullish(SuiAddress2),
  expiration: nullish(TransactionExpiration6),
  gasData: GasData4,
  inputs: array(CallArg4),
  commands: array(Command4)
});

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef3 = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number(), integer()), string(), bigint()])
});
var ObjectArg6 = safeEnum2({
  ImmOrOwned: ObjectRef3,
  Shared: object({
    objectId: ObjectID2,
    initialSharedVersion: JsonU642,
    mutable: boolean()
  }),
  Receiving: ObjectRef3
});
var NormalizedCallArg4 = safeEnum2({
  Object: ObjectArg6,
  Pure: array(pipe(number(), integer()))
});
var TransactionInput2 = union([
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration7 = union([
  object({ Epoch: pipe(number(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint2 = pipe(
  union([number(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val))
      return false;
    try {
      BigInt(val);
      return true;
    } catch {
      return false;
    }
  })
);
var TypeTag4 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag4) }),
  object({ struct: lazy(() => StructTag5) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag5 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag4)
});
var GasConfig2 = object({
  budget: optional(StringEncodedBigint2),
  price: optional(StringEncodedBigint2),
  payment: optional(array(ObjectRef3)),
  owner: optional(string())
});
var TransactionArgumentTypes2 = [
  TransactionInput2,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number(), integer()),
    resultIndex: pipe(number(), integer())
  })
];
var TransactionArgument2 = union([...TransactionArgumentTypes2]);
var MoveCallTransaction2 = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument2)
});
var TransferObjectsTransaction2 = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument2),
  address: TransactionArgument2
});
var SplitCoinsTransaction2 = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument2,
  amounts: array(TransactionArgument2)
});
var MergeCoinsTransaction2 = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument2,
  sources: array(TransactionArgument2)
});
var MakeMoveVecTransaction2 = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag4 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument2)
});
var PublishTransaction2 = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction2 = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument2
});
var TransactionTypes2 = [
  MoveCallTransaction2,
  TransferObjectsTransaction2,
  SplitCoinsTransaction2,
  MergeCoinsTransaction2,
  PublishTransaction2,
  UpgradeTransaction2,
  MakeMoveVecTransaction2
];
var TransactionType2 = union([...TransactionTypes2]);
var SerializedTransactionDataV12 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration7),
  gasConfig: GasConfig2,
  inputs: array(TransactionInput2),
  transactions: array(TransactionType2)
});
function transactionDataFromV12(data) {
  return parse2(TransactionData3, {
    version: 2,
    sender: data.sender ?? null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: data.gasConfig.owner ?? null,
      budget: data.gasConfig.budget?.toString() ?? null,
      price: data.gasConfig.price?.toString() ?? null,
      payment: data.gasConfig.payment?.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      })) ?? null
    },
    inputs: data.inputs.map((input) => {
      if (input.kind === "Input") {
        if (is(NormalizedCallArg4, input.value)) {
          const value2 = parse2(NormalizedCallArg4, input.value);
          if (value2.Object) {
            if (value2.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value2.Object.ImmOrOwned.objectId,
                    version: String(value2.Object.ImmOrOwned.version),
                    digest: value2.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value2.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: value2.Object.Shared.mutable ?? null,
                    initialSharedVersion: value2.Object.Shared.initialSharedVersion,
                    objectId: value2.Object.Shared.objectId
                  }
                }
              };
            }
            if (value2.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value2.Object.Receiving.digest,
                    version: String(value2.Object.Receiving.version),
                    objectId: value2.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase642(new Uint8Array(value2.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer2.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument2(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument2(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument2(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod3, fn] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod3,
              function: fn,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument2(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod3) => toBase642(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument2(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument2(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument2(arg)),
              address: parseV1TransactionArgument2(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod3) => toBase642(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument2(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument2(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData2(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e3) => e3.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b2(dataWithTag, { dkLen: 32 });
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress2(address) {
  return normalizeSuiAddress2(address).replace("0x", "");
}
var TransactionDataBuilder2 = class {
  constructor(clone) {
    this.version = 2;
    this.sender = clone?.sender ?? null;
    this.expiration = clone?.expiration ?? null;
    this.inputs = clone?.inputs ?? [];
    this.commands = clone?.commands ?? [];
    this.gasData = clone?.gasData ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs2.TransactionKind.parse(bytes);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return TransactionDataBuilder2.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes) {
    const rawData = suiBcs2.TransactionData.parse(bytes);
    const data = rawData?.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return TransactionDataBuilder2.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new TransactionDataBuilder2(parse2(TransactionData3, data));
    } else {
      return new TransactionDataBuilder2(parse2(TransactionData3, transactionDataFromV12(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData2("TransactionData", bytes);
    return toBase582(hash);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value2) {
    this.gasData = value2;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs2.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = overrides?.expiration ?? this.expiration;
    const sender = overrides?.sender ?? this.sender;
    const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress2(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress2(this.gasData.owner ?? sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs2.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type2, arg) {
    const index = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index, type: type2, $kind: "Input" };
  }
  getInputUses(index, fn) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index) {
        fn(arg, command);
      }
      return arg;
    });
  }
  mapCommandArguments(index, fn) {
    const command = this.commands[index];
    switch (command.$kind) {
      case "MoveCall":
        command.MoveCall.arguments = command.MoveCall.arguments.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "TransferObjects":
        command.TransferObjects.objects = command.TransferObjects.objects.map(
          (arg) => fn(arg, command, index)
        );
        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);
        break;
      case "SplitCoins":
        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);
        command.SplitCoins.amounts = command.SplitCoins.amounts.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "MergeCoins":
        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);
        command.MergeCoins.sources = command.MergeCoins.sources.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "MakeMoveVec":
        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "Upgrade":
        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);
        break;
      case "$Intent":
        const inputs = command.$Intent.inputs;
        command.$Intent.inputs = {};
        for (const [key2, value2] of Object.entries(inputs)) {
          command.$Intent.inputs[key2] = Array.isArray(value2) ? value2.map((arg) => fn(arg, command, index)) : fn(value2, command, index);
        }
        break;
      case "Publish":
        break;
      default:
        throw new Error(`Unexpected transaction kind: ${command.$kind}`);
    }
  }
  mapArguments(fn) {
    for (const commandIndex of this.commands.keys()) {
      this.mapCommandArguments(commandIndex, fn);
    }
  }
  replaceCommand(index, replacement, resultIndex = index) {
    if (!Array.isArray(replacement)) {
      this.commands[index] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg, _command, commandIndex) => {
        if (commandIndex < index + replacement.length) {
          return arg;
        }
        switch (arg.$kind) {
          case "Result":
            if (arg.Result === index) {
              arg.Result = resultIndex;
            }
            if (arg.Result > index) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] === index) {
              arg.NestedResult[0] = resultIndex;
            }
            if (arg.NestedResult[0] > index) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return TransactionDataBuilder2.getDigestFromBytes(bytes);
  }
  snapshot() {
    return parse2(TransactionData3, this);
  }
  shallowClone() {
    return new TransactionDataBuilder2({
      version: this.version,
      sender: this.sender,
      expiration: this.expiration,
      gasData: {
        ...this.gasData
      },
      inputs: [...this.inputs],
      commands: [...this.commands]
    });
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/experimental/transports/utils.js
function parseTransactionBcs2(bytes) {
  return {
    ...TransactionDataBuilder2.fromBytes(bytes).snapshot(),
    bcs: bytes
  };
}
function parseTransactionEffectsBcs2(effects) {
  const parsed = suiBcs2.TransactionEffects.parse(effects);
  switch (parsed.$kind) {
    case "V1":
      return parseTransactionEffectsV12({ bytes: effects, effects: parsed.V1 });
    case "V2":
      return parseTransactionEffectsV22({ bytes: effects, effects: parsed.V2 });
    default:
      throw new Error(
        `Unknown transaction effects version: ${parsed.$kind}`
      );
  }
}
function parseTransactionEffectsV12(_) {
  throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV22({
  bytes,
  effects
}) {
  const changedObjects = effects.changedObjects.map(
    ([id, change]) => {
      return {
        id,
        inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: change.inputState.Exist?.[0][0] ?? null,
        inputDigest: change.inputState.Exist?.[0][1] ?? null,
        inputOwner: change.inputState.Exist?.[1] ?? null,
        outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
        outputVersion: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
        outputDigest: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[1] : change.outputState.ObjectWrite?.[0] ?? null,
        outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
        idOperation: change.idOperation.$kind
      };
    }
  );
  return {
    bcs: bytes,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.$kind === "Success" ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: add command
      error: effects.status.Failed.error.$kind
    },
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
    eventsDigest: effects.eventsDigest,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion,
    changedObjects,
    unchangedSharedObjects: effects.unchangedSharedObjects.map(
      ([objectId, object2]) => {
        return {
          kind: object2.$kind,
          objectId,
          version: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[0] : object2[object2.$kind],
          digest: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[1] : null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxDataDigest
  };
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/graphql/generated/queries.js
var ZkLoginIntentScope2 = /* @__PURE__ */ ((ZkLoginIntentScope22) => {
  ZkLoginIntentScope22["PersonalMessage"] = "PERSONAL_MESSAGE";
  ZkLoginIntentScope22["TransactionData"] = "TRANSACTION_DATA";
  return ZkLoginIntentScope22;
})(ZkLoginIntentScope2 || {});
var TypedDocumentString2 = class extends String {
  constructor(value2, __meta__) {
    super(value2);
    this.value = value2;
    this.__meta__ = __meta__;
  }
  toString() {
    return this.value;
  }
};
var Object_Owner_FieldsFragmentDoc2 = new TypedDocumentString2(`
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusV2 {
    authenticator {
      ... on Address {
        address
      }
    }
  }
}
    `, { "fragmentName": "OBJECT_OWNER_FIELDS" });
var Object_FieldsFragmentDoc2 = new TypedDocumentString2(`
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusV2 {
    authenticator {
      ... on Address {
        address
      }
    }
  }
}`, { "fragmentName": "OBJECT_FIELDS" });
var Move_Object_FieldsFragmentDoc2 = new TypedDocumentString2(`
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusV2 {
    authenticator {
      ... on Address {
        address
      }
    }
  }
}`, { "fragmentName": "MOVE_OBJECT_FIELDS" });
var Transaction_FieldsFragmentDoc2 = new TypedDocumentString2(`
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedSharedObjects {
      nodes {
        __typename
        ... on SharedObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}
    `, { "fragmentName": "TRANSACTION_FIELDS" });
var GetAllBalancesDocument2 = new TypedDocumentString2(`
    query getAllBalances($owner: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $owner) {
    balances(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinType {
          repr
        }
        coinObjectCount
        totalBalance
      }
    }
  }
}
    `);
var GetBalanceDocument2 = new TypedDocumentString2(`
    query getBalance($owner: SuiAddress!, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    balance(type: $type) {
      coinType {
        repr
      }
      coinObjectCount
      totalBalance
    }
  }
}
    `);
var GetCoinsDocument2 = new TypedDocumentString2(`
    query getCoins($owner: SuiAddress!, $first: Int, $cursor: String, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    address
    coins(first: $first, after: $cursor, type: $type) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinBalance
        owner {
          ...OBJECT_OWNER_FIELDS
        }
        contents {
          bcs
          type {
            repr
          }
        }
        address
        version
        digest
      }
    }
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusV2 {
    authenticator {
      ... on Address {
        address
      }
    }
  }
}`);
var GetDynamicFieldsDocument2 = new TypedDocumentString2(`
    query getDynamicFields($parentId: SuiAddress!, $first: Int, $cursor: String) {
  owner(address: $parentId) {
    dynamicFields(first: $first, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name {
          bcs
          type {
            repr
          }
        }
        value {
          __typename
          ... on MoveValue {
            type {
              repr
            }
          }
          ... on MoveObject {
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}
    `);
var GetReferenceGasPriceDocument2 = new TypedDocumentString2(`
    query getReferenceGasPrice {
  epoch {
    referenceGasPrice
  }
}
    `);
var GetOwnedObjectsDocument2 = new TypedDocumentString2(`
    query getOwnedObjects($owner: SuiAddress!, $limit: Int, $cursor: String, $filter: ObjectFilter) {
  address(address: $owner) {
    objects(first: $limit, after: $cursor, filter: $filter) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        ...MOVE_OBJECT_FIELDS
      }
    }
  }
}
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusV2 {
    authenticator {
      ... on Address {
        address
      }
    }
  }
}`);
var MultiGetObjectsDocument2 = new TypedDocumentString2(`
    query multiGetObjects($objectIds: [SuiAddress!]!, $limit: Int, $cursor: String) {
  objects(first: $limit, after: $cursor, filter: {objectIds: $objectIds}) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      ...OBJECT_FIELDS
    }
  }
}
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusV2 {
    authenticator {
      ... on Address {
        address
      }
    }
  }
}`);
var DryRunTransactionBlockDocument = new TypedDocumentString2(`
    query dryRunTransactionBlock($txBytes: String!) {
  dryRunTransactionBlock(txBytes: $txBytes) {
    error
    transaction {
      ...TRANSACTION_FIELDS
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedSharedObjects {
      nodes {
        __typename
        ... on SharedObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}`);
var ExecuteTransactionBlockDocument = new TypedDocumentString2(`
    mutation executeTransactionBlock($txBytes: String!, $signatures: [String!]!) {
  executeTransactionBlock(txBytes: $txBytes, signatures: $signatures) {
    errors
    effects {
      transactionBlock {
        ...TRANSACTION_FIELDS
      }
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedSharedObjects {
      nodes {
        __typename
        ... on SharedObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}`);
var GetTransactionBlockDocument2 = new TypedDocumentString2(`
    query getTransactionBlock($digest: String!) {
  transactionBlock(digest: $digest) {
    ...TRANSACTION_FIELDS
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedSharedObjects {
      nodes {
        __typename
        ... on SharedObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}`);
var VerifyZkLoginSignatureDocument2 = new TypedDocumentString2(`
    query verifyZkLoginSignature($bytes: Base64!, $signature: Base64!, $intentScope: ZkLoginIntentScope!, $author: SuiAddress!) {
  verifyZkloginSignature(
    bytes: $bytes
    signature: $signature
    intentScope: $intentScope
    author: $author
  ) {
    success
    errors
  }
}
    `);

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError2 = class extends Error {
};
var ObjectError2 = class extends SuiClientError2 {
  constructor(code, message) {
    super(message);
    this.code = code;
  }
  static fromResponse(response, objectId) {
    switch (response.code) {
      case "notExists":
        return new ObjectError2(response.code, `Object ${response.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new ObjectError2(
          response.code,
          `Dynamic field not found for object ${response.parent_object_id}`
        );
      case "deleted":
        return new ObjectError2(response.code, `Object ${response.object_id} has been deleted`);
      case "displayError":
        return new ObjectError2(response.code, `Display error: ${response.error}`);
      case "unknown":
      default:
        return new ObjectError2(
          response.code,
          `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`
        );
    }
  }
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/experimental/transports/graphql.js
var __typeError14 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck14 = (obj, member, msg) => member.has(obj) || __typeError14("Cannot " + msg);
var __privateGet13 = (obj, member, getter) => (__accessCheck14(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd14 = (obj, member, value2) => member.has(obj) ? __typeError14("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet13 = (obj, member, value2, setter) => (__accessCheck14(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod8 = (obj, member, method) => (__accessCheck14(obj, member, "access private method"), method);
var _graphqlClient2;
var _GraphQLTransport_instances;
var graphqlQuery_fn2;
var GraphQLTransport = class extends Experimental_CoreClient2 {
  constructor(graphqlClient) {
    super({ network: graphqlClient.network });
    __privateAdd14(this, _GraphQLTransport_instances);
    __privateAdd14(this, _graphqlClient2);
    __privateSet13(this, _graphqlClient2, graphqlClient);
  }
  async getObjects(options) {
    const objects = [];
    let hasNextPage = true;
    let cursor = null;
    while (hasNextPage) {
      const objectsPage = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
        query: MultiGetObjectsDocument2,
        variables: {
          objectIds: options.objectIds,
          cursor
        }
      }, (result) => result.objects);
      objects.push(...objectsPage.nodes);
      hasNextPage = objectsPage.pageInfo.hasNextPage;
      cursor = objectsPage.pageInfo.endCursor ?? null;
    }
    return {
      objects: options.objectIds.map((id) => normalizeSuiAddress2(id)).map(
        (id) => objects.find((obj) => obj.address === id) ?? new ObjectError2("notFound", `Object ${id} not found`)
      ).map((obj) => {
        if (obj instanceof ObjectError2) {
          return obj;
        }
        return {
          id: obj.address,
          version: obj.version,
          digest: obj.digest,
          owner: mapOwner2(obj.owner),
          type: obj.asMoveObject?.contents?.type?.repr,
          content: fromBase642(obj.asMoveObject?.contents?.bcs)
        };
      })
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetOwnedObjectsDocument2,
      variables: {
        owner: options.address,
        limit: options.limit,
        cursor: options.cursor,
        filter: options.type ? { type: options.type } : void 0
      }
    }, (result) => result.address?.objects);
    return {
      objects: objects.nodes.map((obj) => ({
        id: obj.address,
        version: obj.version,
        digest: obj.digest,
        owner: mapOwner2(obj.owner),
        type: obj.contents?.type?.repr,
        content: fromBase642(obj.contents?.bcs)
      })),
      hasNextPage: objects.pageInfo.hasNextPage,
      cursor: objects.pageInfo.endCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetCoinsDocument2,
      variables: {
        owner: options.address,
        cursor: options.cursor,
        first: options.limit,
        type: options.coinType
      }
    }, (result) => result.address?.coins);
    return {
      cursor: coins.pageInfo.endCursor ?? null,
      hasNextPage: coins.pageInfo.hasNextPage,
      objects: coins.nodes.map((coin) => ({
        id: coin.address,
        version: coin.version,
        digest: coin.digest,
        owner: mapOwner2(coin.owner),
        type: coin.contents?.type?.repr,
        balance: coin.coinBalance,
        content: fromBase642(coin.contents?.bcs)
      }))
    };
  }
  async getBalance(options) {
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetBalanceDocument2,
      variables: { owner: options.address, type: options.coinType }
    }, (result2) => result2.address?.balance);
    return {
      balance: {
        coinType: result.coinType.repr,
        balance: result.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetAllBalancesDocument2,
      variables: { owner: options.address }
    }, (result) => result.address?.balances);
    return {
      cursor: balances.pageInfo.endCursor ?? null,
      hasNextPage: balances.pageInfo.hasNextPage,
      balances: balances.nodes.map((balance) => ({
        coinType: balance.coinType.repr,
        balance: balance.totalBalance
      }))
    };
  }
  async getTransaction(options) {
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetTransactionBlockDocument2,
      variables: { digest: options.digest }
    }, (result2) => result2.transactionBlock);
    return {
      transaction: parseTransaction3(result)
    };
  }
  async executeTransaction(options) {
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: ExecuteTransactionBlockDocument,
      variables: { txBytes: toBase642(options.transaction), signatures: options.signatures }
    }, (result2) => result2.executeTransactionBlock);
    if (result.errors) {
      if (result.errors.length === 1) {
        throw new Error(result.errors[0]);
      }
      throw new AggregateError(result.errors.map((error2) => new Error(error2)));
    }
    return {
      transaction: parseTransaction3(result.effects.transactionBlock)
    };
  }
  async dryRunTransaction(options) {
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: DryRunTransactionBlockDocument,
      variables: { txBytes: toBase642(options.transaction) }
    }, (result2) => result2.dryRunTransactionBlock);
    if (result.error) {
      throw new Error(result.error);
    }
    return {
      transaction: parseTransaction3(result.transaction)
    };
  }
  async getReferenceGasPrice() {
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetReferenceGasPriceDocument2
    }, (result2) => result2.epoch?.referenceGasPrice);
    return {
      referenceGasPrice: result.referenceGasPrice
    };
  }
  async getDynamicFields(options) {
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: GetDynamicFieldsDocument2,
      variables: { parentId: options.parentId }
    }, (result2) => result2.owner?.dynamicFields);
    return {
      dynamicFields: result.nodes.map((dynamicField) => {
        const valueType = dynamicField.value?.__typename === "MoveObject" ? dynamicField.value.contents?.type?.repr : dynamicField.value?.type.repr;
        return {
          id: deriveDynamicFieldID2(
            options.parentId,
            dynamicField.name?.type.repr,
            dynamicField.name?.bcs
          ),
          type: normalizeStructTag2(
            dynamicField.value?.__typename === "MoveObject" ? `0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${dynamicField.name?.type.repr}>,0x2::object::ID>` : `0x2::dynamic_field::Field<${dynamicField.name?.type.repr},${valueType}>`
          ),
          name: {
            type: dynamicField.name?.type.repr,
            bcs: fromBase642(dynamicField.name?.bcs)
          },
          valueType
        };
      }),
      cursor: result.pageInfo.endCursor ?? null,
      hasNextPage: result.pageInfo.hasNextPage
    };
  }
  async verifyZkLoginSignature(options) {
    const intentScope = options.intentScope === "TransactionData" ? ZkLoginIntentScope2.TransactionData : ZkLoginIntentScope2.PersonalMessage;
    const result = await __privateMethod8(this, _GraphQLTransport_instances, graphqlQuery_fn2).call(this, {
      query: VerifyZkLoginSignatureDocument2,
      variables: {
        bytes: options.bytes,
        signature: options.signature,
        intentScope,
        author: options.author
      }
    }, (result2) => result2.verifyZkloginSignature);
    return {
      success: result.success,
      errors: result.errors
    };
  }
  resolveTransactionPlugin() {
    throw new Error("GraphQL client does not support transaction resolution yet");
  }
};
_graphqlClient2 = /* @__PURE__ */ new WeakMap();
_GraphQLTransport_instances = /* @__PURE__ */ new WeakSet();
graphqlQuery_fn2 = async function(options, getData) {
  const { data, errors } = await __privateGet13(this, _graphqlClient2).query(options);
  handleGraphQLErrors2(errors);
  const extractedData = data && (getData ? getData(data) : data);
  if (extractedData == null) {
    throw new Error("Missing response data");
  }
  return extractedData;
};
function handleGraphQLErrors2(errors) {
  if (!errors || errors.length === 0)
    return;
  const errorInstances = errors.map((error2) => new GraphQLResponseError2(error2));
  if (errorInstances.length === 1) {
    throw errorInstances[0];
  }
  throw new AggregateError(errorInstances);
}
var GraphQLResponseError2 = class extends Error {
  constructor(error2) {
    super(error2.message);
    this.locations = error2.locations;
  }
};
function mapOwner2(owner) {
  switch (owner.__typename) {
    case "AddressOwner":
      return { $kind: "AddressOwner", AddressOwner: owner.owner?.asAddress?.address };
    case "ConsensusV2":
      return { $kind: "ConsensusV2", ConsensusV2: owner.authenticator.address };
    case "Immutable":
      return { $kind: "Immutable", Immutable: true };
    case "Parent":
      return { $kind: "ObjectOwner", ObjectOwner: owner.parent?.address };
    case "Shared":
      return { $kind: "Shared", Shared: owner.initialSharedVersion };
  }
}
function parseTransaction3(transaction) {
  const objectTypes = {};
  transaction.effects?.unchangedSharedObjects.nodes.forEach((node) => {
    if (node.__typename === "SharedObjectRead") {
      const type2 = node.object?.asMoveObject?.contents?.type.repr;
      const address = node.object?.asMoveObject?.address;
      if (type2 && address) {
        objectTypes[address] = type2;
      }
    }
  });
  transaction.effects?.objectChanges.nodes.forEach((node) => {
    const address = node.address;
    const type2 = node.inputState?.asMoveObject?.contents?.type.repr ?? node.outputState?.asMoveObject?.contents?.type.repr;
    if (address && type2) {
      objectTypes[address] = type2;
    }
  });
  return {
    digest: transaction.digest,
    effects: parseTransactionEffectsBcs2(new Uint8Array(transaction.effects?.bcs)),
    epoch: transaction.effects?.epoch?.epochId ?? null,
    objectTypes: Promise.resolve(objectTypes),
    transaction: parseTransactionBcs2(transaction.bcs),
    signatures: transaction.signatures
  };
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/graphql/client.js
var __typeError15 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck15 = (obj, member, msg) => member.has(obj) || __typeError15("Cannot " + msg);
var __privateGet14 = (obj, member, getter) => (__accessCheck15(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd15 = (obj, member, value2) => member.has(obj) ? __typeError15("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet14 = (obj, member, value2, setter) => (__accessCheck15(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _url3;
var _queries2;
var _headers2;
var _fetch2;
var SuiGraphQLRequestError2 = class extends Error {
};
var SuiGraphQLClient2 = class extends Experimental_BaseClient2 {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {},
    network = "unknown"
  }) {
    super({
      network
    });
    __privateAdd15(this, _url3);
    __privateAdd15(this, _queries2);
    __privateAdd15(this, _headers2);
    __privateAdd15(this, _fetch2);
    this.core = new GraphQLTransport(this);
    __privateSet14(this, _url3, url);
    __privateSet14(this, _queries2, queries);
    __privateSet14(this, _headers2, headers);
    __privateSet14(this, _fetch2, (...args) => fetchFn(...args));
  }
  async query(options) {
    const res = await __privateGet14(this, _fetch2).call(this, __privateGet14(this, _url3), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet14(this, _headers2)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" || options.query instanceof String ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      }),
      signal: options.signal
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError2(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet14(this, _queries2)[query]
    });
  }
};
_url3 = /* @__PURE__ */ new WeakMap();
_queries2 = /* @__PURE__ */ new WeakMap();
_headers2 = /* @__PURE__ */ new WeakMap();
_fetch2 = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/zklogin/utils.js
function findFirstNonZeroIndex(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2++) {
    if (bytes[i2] !== 0) {
      return i2;
    }
  }
  return -1;
}
function toPaddedBigEndianBytes(num, width) {
  const hex2 = num.toString(16);
  return hexToBytes(hex2.padStart(width * 2, "0").slice(-width * 2));
}
function toBigEndianBytes(num, width) {
  const bytes = toPaddedBigEndianBytes(num, width);
  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);
  if (firstNonZeroIndex === -1) {
    return new Uint8Array([0]);
  }
  return bytes.slice(firstNonZeroIndex);
}
function normalizeZkLoginIssuer(iss) {
  if (iss === "accounts.google.com") {
    return "https://accounts.google.com";
  }
  return iss;
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i2 = 0; i2 < base64UrlString.length; i2++) {
    const base64UrlChar = base64UrlString.charAt(i2);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s, i2) {
  if (s.length < 2) {
    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s);
  const firstCharOffset = i2 % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i2}))`);
  }
  const lastCharOffset = (i2 + s.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i2}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i22 = 0; i22 < bits.length; i22 += 8) {
    const bitChunk = bits.slice(i22, i22 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key2 = Object.keys(json)[0];
  return [key2, json[key2]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name2, value2] = verifyExtendedClaim(extendedClaim);
  if (name2 !== claimName) {
    throw new Error(`Invalid field name: found ${name2} expected ${claimName}`);
  }
  return value2;
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs2.struct("ZkLoginSignature", {
  inputs: bcs2.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs2.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs2.vector(bcs2.string()),
      b: bcs2.vector(bcs2.vector(bcs2.string())),
      c: bcs2.vector(bcs2.string())
    }),
    issBase64Details: bcs2.struct("ZkLoginSignatureInputsClaim", {
      value: bcs2.string(),
      indexMod4: bcs2.u8()
    }),
    headerBase64: bcs2.string(),
    addressSeed: bcs2.string()
  }),
  maxEpoch: bcs2.u64(),
  userSignature: bcs2.vector(bcs2.u8())
});

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/zklogin/signature.js
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromBase642(signature) : signature);
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/zklogin/publickey.js
var __typeError16 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck16 = (obj, member, msg) => member.has(obj) || __typeError16("Cannot " + msg);
var __privateGet15 = (obj, member, getter) => (__accessCheck16(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd16 = (obj, member, value2) => member.has(obj) ? __typeError16("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet15 = (obj, member, value2, setter) => (__accessCheck16(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod9 = (obj, member, method) => (__accessCheck16(obj, member, "access private method"), method);
var _data2;
var _client;
var _legacyAddress;
var _ZkLoginPublicIdentifier_instances;
var toLegacyAddress_fn;
var _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier2 extends PublicKey4 {
  /**
   * Create a new ZkLoginPublicIdentifier object
   * @param value zkLogin public identifier as buffer or base-64 encoded string
   */
  constructor(value2, { client } = {}) {
    super();
    __privateAdd16(this, _ZkLoginPublicIdentifier_instances);
    __privateAdd16(this, _data2);
    __privateAdd16(this, _client);
    __privateAdd16(this, _legacyAddress);
    __privateSet15(this, _client, client);
    if (typeof value2 === "string") {
      __privateSet15(this, _data2, fromBase642(value2));
    } else if (value2 instanceof Uint8Array) {
      __privateSet15(this, _data2, value2);
    } else {
      __privateSet15(this, _data2, Uint8Array.from(value2));
    }
    __privateSet15(this, _legacyAddress, __privateGet15(this, _data2).length !== __privateGet15(this, _data2)[0] + 1 + 32);
    if (__privateGet15(this, _legacyAddress)) {
      __privateSet15(this, _data2, normalizeZkLoginPublicKeyBytes(__privateGet15(this, _data2)));
    }
  }
  static fromBytes(bytes, {
    client,
    address,
    legacyAddress
  } = {}) {
    let publicKey;
    if (legacyAddress === true) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, true), {
        client
      });
    } else if (legacyAddress === false) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, false), {
        client
      });
    } else if (address) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, false), {
        client
      });
      if (publicKey.toSuiAddress() !== address) {
        publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, true), {
          client
        });
      }
    } else {
      publicKey = new _ZkLoginPublicIdentifier2(bytes, {
        client
      });
    }
    if (address && publicKey.toSuiAddress() !== address) {
      throw new Error("Public key bytes do not match the provided address");
    }
    return publicKey;
  }
  static fromProof(address, proof) {
    const { issBase64Details, addressSeed } = proof;
    const iss = extractClaimValue(issBase64Details, "iss");
    const legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: true
    });
    if (legacyPublicKey.toSuiAddress() === address) {
      return legacyPublicKey;
    }
    const publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: false
    });
    if (publicKey.toSuiAddress() !== address) {
      throw new Error("Proof does not match address");
    }
    return publicKey;
  }
  /**
   * Checks if two zkLogin public identifiers are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  toSuiAddress() {
    if (__privateGet15(this, _legacyAddress)) {
      return __privateMethod9(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
    }
    return super.toSuiAddress();
  }
  /**
   * Return the byte array representation of the zkLogin public identifier
   */
  toRawBytes() {
    return __privateGet15(this, _data2);
  }
  /**
   * Return the Sui address associated with this ZkLogin public identifier
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG2["ZkLogin"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(_message, _signature) {
    throw Error("does not support");
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase642(message),
      signature: parsedSignature.serializedSignature,
      intentScope: "PersonalMessage",
      client: __privateGet15(this, _client)
    });
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase642(transaction),
      signature: parsedSignature.serializedSignature,
      intentScope: "TransactionData",
      client: __privateGet15(this, _client)
    });
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return address === super.toSuiAddress() || address === __privateMethod9(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
  }
};
_data2 = /* @__PURE__ */ new WeakMap();
_client = /* @__PURE__ */ new WeakMap();
_legacyAddress = /* @__PURE__ */ new WeakMap();
_ZkLoginPublicIdentifier_instances = /* @__PURE__ */ new WeakSet();
toLegacyAddress_fn = function() {
  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet15(this, _data2), true);
  const addressBytes = new Uint8Array(legacyBytes.length + 1);
  addressBytes[0] = this.flag();
  addressBytes.set(legacyBytes, 1);
  return normalizeSuiAddress2(
    bytesToHex(blake2b2(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
  );
};
var ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;
function toZkLoginPublicIdentifier(addressSeed, iss, options) {
  const addressSeedBytesBigEndian = options?.legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));
  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);
  tmp.set([issBytes.length], 0);
  tmp.set(issBytes, 1);
  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);
  return new ZkLoginPublicIdentifier(tmp, options);
}
function normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {
  const issByteLength = bytes[0] + 1;
  const addressSeed = BigInt(`0x${toHex2(bytes.slice(issByteLength))}`);
  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const data = new Uint8Array(issByteLength + seedBytes.length);
  data.set(bytes.slice(0, issByteLength), 0);
  data.set(seedBytes, issByteLength);
  return data;
}
async function graphqlVerifyZkLoginSignature({
  address,
  bytes,
  signature,
  intentScope,
  client = new SuiGraphQLClient2({
    url: "https://sui-mainnet.mystenlabs.com/graphql"
  })
}) {
  const resp = await client.core.verifyZkLoginSignature({
    bytes,
    signature,
    intentScope,
    author: address
  });
  return resp.success === true && resp.errors.length === 0;
}
function parseSerializedZkLoginSignature(signature) {
  const bytes = typeof signature === "string" ? fromBase642(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG2.ZkLogin) {
    throw new Error("Invalid signature scheme");
  }
  const signatureBytes = bytes.slice(1);
  const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
  const { issBase64Details, addressSeed } = inputs;
  const iss = extractClaimValue(issBase64Details, "iss");
  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);
  return {
    serializedSignature: toBase642(bytes),
    signatureScheme: "ZkLogin",
    zkLogin: {
      inputs,
      maxEpoch,
      userSignature,
      iss,
      addressSeed: BigInt(addressSeed)
    },
    signature: bytes,
    publicKey: publicIdentifer.toRawBytes()
  };
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature2({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG2[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase642(serializedSignature);
}
function parseSerializedSignature2(serializedSignature) {
  const bytes = fromBase642(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME2[bytes[0]];
  switch (signatureScheme) {
    case "Passkey":
      return parseSerializedPasskeySignature(serializedSignature);
    case "MultiSig":
      const multisig = suiBcs2.MultiSig.parse(bytes.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes,
        signature: void 0
      };
    case "ZkLogin":
      return parseSerializedZkLoginSignature(serializedSignature);
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      return parseSerializedKeypairSignature2(serializedSignature);
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE2 = 32;
var SUI_PRIVATE_KEY_PREFIX2 = "suiprivkey";
var Signer2 = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent2(intent, bytes);
    const digest = blake2b2(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature2({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase642(bytes)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes) {
    return this.signWithIntent(bytes, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    const { signature } = await this.signWithIntent(
      bcs2.vector(bcs2.u8()).serialize(bytes).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase642(bytes),
      signature
    };
  }
  async signAndExecuteTransaction({
    transaction,
    client
  }) {
    const bytes = await transaction.build({ client });
    const { signature } = await this.signTransaction(bytes);
    const response = await client.core.executeTransaction({
      transaction: bytes,
      signatures: [signature]
    });
    return response.transaction;
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};
var Keypair2 = class extends Signer2 {
};
function decodeSuiPrivateKey2(value2) {
  const { prefix, words } = bech32.decode(value2);
  if (prefix !== SUI_PRIVATE_KEY_PREFIX2) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME2[extendedSecretKey[0]];
  return {
    scheme: signatureScheme,
    schema: signatureScheme,
    secretKey
  };
}
function encodeSuiPrivateKey2(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE2) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG2[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(SUI_PRIVATE_KEY_PREFIX2, bech32.toWords(privKeyBytes));
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath2(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed2(mnemonics) {
  return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex2(mnemonics) {
  return toHex2(mnemonicToSeed2(mnemonics));
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var ED25519_CURVE2 = "ed25519 seed";
var HARDENED_OFFSET2 = 2147483648;
var pathRegex2 = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive2 = (val) => val.replace("'", "");
var getMasterKeyFromSeed2 = (seed) => {
  const h = hmac.create(sha5122, ED25519_CURVE2);
  const I = h.update(fromHex2(seed)).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv2 = ({ key: key2, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key2.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key2, 1);
  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key2.length + 1);
  const I = hmac.create(sha5122, chainCode).update(data).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath2 = (path) => {
  if (!pathRegex2.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive2).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath2 = (path, seed, offset = HARDENED_OFFSET2) => {
  if (!isValidPath2(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key: key2, chainCode } = getMasterKeyFromSeed2(seed);
  const segments = path.split("/").slice(1).map(replaceDerive2).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv2(parentKeys, segment + offset), {
    key: key2,
    chainCode
  });
};

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE2 = 32;
var Ed25519PublicKey2 = class extends PublicKey4 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase642(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE2) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE2} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG2["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature2(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual2(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return ed255192.verify(bytes, message, this.toRawBytes());
  }
};
Ed25519PublicKey2.SIZE = PUBLIC_KEY_SIZE2;

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH2 = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair2 = class extends Keypair2 {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = {
        publicKey: keypair.publicKey,
        secretKey: keypair.secretKey.slice(0, 32)
      };
    } else {
      const privateKey = ed255192.utils.randomPrivateKey();
      this.keypair = {
        publicKey: ed255192.getPublicKey(privateKey),
        secretKey: privateKey
      };
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    const secretKey = ed255192.utils.randomPrivateKey();
    return new Ed25519Keypair2({
      publicKey: ed255192.getPublicKey(secretKey),
      secretKey
    });
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key as a byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey2(secretKey);
      if (decoded.schema !== "ED25519") {
        throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE2) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE2} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = {
      publicKey: ed255192.getPublicKey(secretKey),
      secretKey
    };
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = ed255192.sign(signData, secretKey);
      if (!ed255192.verify(signature, signData, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new Ed25519Keypair2(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey2(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Ed25519 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey2(
      this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE2),
      this.getKeyScheme()
    );
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  async sign(data) {
    return ed255192.sign(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH2;
    }
    if (!isValidHardenedPath2(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key: key2 } = derivePath2(path, mnemonicToSeedHex2(mnemonics));
    return Ed25519Keypair2.fromSecretKey(key2);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(seedHex, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH2;
    }
    if (!isValidHardenedPath2(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key: key2 } = derivePath2(path, seedHex);
    return Ed25519Keypair2.fromSecretKey(key2);
  }
};

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _2n12 = /* @__PURE__ */ BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n9 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow22(b3, _3n9, P) * b3 % P;
  const b9 = pow22(b6, _3n9, P) * b3 % P;
  const b11 = pow22(b9, _2n12, P) * b2 % P;
  const b22 = pow22(b11, _11n, P) * b11 % P;
  const b44 = pow22(b22, _22n, P) * b22 % P;
  const b88 = pow22(b44, _44n, P) * b44 % P;
  const b176 = pow22(b88, _88n, P) * b88 % P;
  const b220 = pow22(b176, _44n, P) * b44 % P;
  const b223 = pow22(b220, _3n9, P) * b3 % P;
  const t1 = pow22(b223, _23n, P) * b22 % P;
  const t22 = pow22(t1, _6n, P) * b2 % P;
  const root = pow22(t22, _2n12, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field2(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/keypairs/secp256k1/publickey.js
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class extends PublicKey4 {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase642(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG2["Secp256k1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature2(signature);
      if (parsed.signatureScheme !== "Secp256k1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual2(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256k1.verify(
      secp256k1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey4 {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase642(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG2["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature2(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual2(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/multisig/signer.js
var __typeError17 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck17 = (obj, member, msg) => member.has(obj) || __typeError17("Cannot " + msg);
var __privateGet16 = (obj, member, getter) => (__accessCheck17(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd17 = (obj, member, value2) => member.has(obj) ? __typeError17("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet16 = (obj, member, value2, setter) => (__accessCheck17(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _pubkey;
var _signers;
var MultiSigSigner = class extends Signer2 {
  constructor(pubkey, signers = []) {
    super();
    __privateAdd17(this, _pubkey);
    __privateAdd17(this, _signers);
    __privateSet16(this, _pubkey, pubkey);
    __privateSet16(this, _signers, signers);
    const uniqueKeys = /* @__PURE__ */ new Set();
    let combinedWeight = 0;
    const weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({
      weight,
      address: publicKey.toSuiAddress()
    }));
    for (const signer of signers) {
      const address = signer.toSuiAddress();
      if (uniqueKeys.has(address)) {
        throw new Error(`Can't create MultiSigSigner with duplicate signers`);
      }
      uniqueKeys.add(address);
      const weight = weights.find((w) => w.address === address)?.weight;
      if (!weight) {
        throw new Error(`Signer ${address} is not part of the MultiSig public key`);
      }
      combinedWeight += weight;
    }
    if (combinedWeight < pubkey.getThreshold()) {
      throw new Error(`Combined weight of signers is less than threshold`);
    }
  }
  getKeyScheme() {
    return "MultiSig";
  }
  getPublicKey() {
    return __privateGet16(this, _pubkey);
  }
  sign(_data3) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead"
    );
  }
  signData(_data3) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead"
    );
  }
  async signTransaction(bytes) {
    const signature = __privateGet16(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet16(this, _signers).map(async (signer) => (await signer.signTransaction(bytes)).signature)
      )
    );
    return {
      signature,
      bytes: toBase642(bytes)
    };
  }
  async signPersonalMessage(bytes) {
    const signature = __privateGet16(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet16(this, _signers).map(async (signer) => (await signer.signPersonalMessage(bytes)).signature)
      )
    );
    return {
      signature,
      bytes: toBase642(bytes)
    };
  }
};
_pubkey = /* @__PURE__ */ new WeakMap();
_signers = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/multisig/publickey.js
var MAX_SIGNER_IN_MULTISIG = 10;
var MIN_SIGNER_IN_MULTISIG = 1;
var MultiSigPublicKey3 = class extends PublicKey4 {
  /**
   * Create a new MultiSigPublicKey object
   */
  constructor(value2, options = {}) {
    super();
    if (typeof value2 === "string") {
      this.rawBytes = fromBase642(value2);
      this.multisigPublicKey = suiBcs2.MultiSigPublicKey.parse(this.rawBytes);
    } else if (value2 instanceof Uint8Array) {
      this.rawBytes = value2;
      this.multisigPublicKey = suiBcs2.MultiSigPublicKey.parse(this.rawBytes);
    } else {
      this.multisigPublicKey = value2;
      this.rawBytes = suiBcs2.MultiSigPublicKey.serialize(value2).toBytes();
    }
    if (this.multisigPublicKey.threshold < 1) {
      throw new Error("Invalid threshold");
    }
    const seenPublicKeys = /* @__PURE__ */ new Set();
    this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {
      const [scheme, bytes] = Object.entries(pubKey).filter(([name2]) => name2 !== "$kind")[0];
      const publicKeyStr = Uint8Array.from(bytes).toString();
      if (seenPublicKeys.has(publicKeyStr)) {
        throw new Error(`Multisig does not support duplicate public keys`);
      }
      seenPublicKeys.add(publicKeyStr);
      if (weight < 1) {
        throw new Error(`Invalid weight`);
      }
      return {
        publicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),
        weight
      };
    });
    const totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);
    if (this.multisigPublicKey.threshold > totalWeight) {
      throw new Error(`Unreachable threshold`);
    }
    if (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    if (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {
      throw new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);
    }
  }
  /**
   * 	A static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.
   */
  static fromPublicKeys({
    threshold,
    publicKeys
  }) {
    return new MultiSigPublicKey3({
      pk_map: publicKeys.map(({ publicKey, weight }) => {
        const scheme = SIGNATURE_FLAG_TO_SCHEME2[publicKey.flag()];
        return {
          pubKey: { [scheme]: Array.from(publicKey.toRawBytes()) },
          weight
        };
      }),
      threshold
    });
  }
  /**
   * Checks if two MultiSig public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the MultiSig public key
   */
  toRawBytes() {
    return this.rawBytes;
  }
  getPublicKeys() {
    return this.publicKeys;
  }
  getThreshold() {
    return this.multisigPublicKey.threshold;
  }
  getSigner(...signers) {
    return new MultiSigSigner(this, signers);
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  toSuiAddress() {
    const maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;
    const tmp = new Uint8Array(maxLength);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG2["MultiSig"]]);
    tmp.set(suiBcs2.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);
    let i2 = 3;
    for (const { publicKey, weight } of this.publicKeys) {
      const bytes = publicKey.toSuiBytes();
      tmp.set(bytes, i2);
      i2 += bytes.length;
      tmp.set([weight], i2++);
    }
    return normalizeSuiAddress2(bytesToHex(blake2b2(tmp.slice(0, i2), { dkLen: 32 })));
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG2["MultiSig"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, multisigSignature) {
    const parsed = parseSerializedSignature2(multisigSignature);
    if (parsed.signatureScheme !== "MultiSig") {
      throw new Error("Invalid signature scheme");
    }
    const { multisig } = parsed;
    let signatureWeight = 0;
    if (!bytesEqual2(
      suiBcs2.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),
      suiBcs2.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes()
    )) {
      return false;
    }
    for (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {
      if (!await publicKey.verify(message, signature)) {
        return false;
      }
      signatureWeight += weight;
    }
    return signatureWeight >= this.multisigPublicKey.threshold;
  }
  /**
   * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once
   * and that all the public keys involved are known and valid, and then serializes multisig into the standard format
   */
  combinePartialSignatures(signatures) {
    if (signatures.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    let bitmap = 0;
    const compressedSignatures = new Array(signatures.length);
    for (let i2 = 0; i2 < signatures.length; i2++) {
      const parsed = parseSerializedSignature2(signatures[i2]);
      if (parsed.signatureScheme === "MultiSig") {
        throw new Error("MultiSig is not supported inside MultiSig");
      }
      let publicKey;
      if (parsed.signatureScheme === "ZkLogin") {
        publicKey = toZkLoginPublicIdentifier(
          parsed.zkLogin?.addressSeed,
          parsed.zkLogin?.iss
        ).toRawBytes();
      } else {
        publicKey = parsed.publicKey;
      }
      compressedSignatures[i2] = {
        [parsed.signatureScheme]: Array.from(parsed.signature.map((x) => Number(x)))
      };
      let publicKeyIndex;
      for (let j = 0; j < this.publicKeys.length; j++) {
        if (bytesEqual2(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {
          if (bitmap & 1 << j) {
            throw new Error("Received multiple signatures from the same public key");
          }
          publicKeyIndex = j;
          break;
        }
      }
      if (publicKeyIndex === void 0) {
        throw new Error("Received signature from unknown public key");
      }
      bitmap |= 1 << publicKeyIndex;
    }
    const multisig = {
      sigs: compressedSignatures,
      bitmap,
      multisig_pk: this.multisigPublicKey
    };
    const bytes = suiBcs2.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();
    const tmp = new Uint8Array(bytes.length + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG2["MultiSig"]]);
    tmp.set(bytes, 1);
    return toBase642(tmp);
  }
};
function parsePartialSignatures(multisig, options = {}) {
  const res = new Array(multisig.sigs.length);
  for (let i2 = 0; i2 < multisig.sigs.length; i2++) {
    const [signatureScheme, signature] = Object.entries(multisig.sigs[i2]).filter(
      ([name2]) => name2 !== "$kind"
    )[0];
    const pkIndex = asIndices(multisig.bitmap).at(i2);
    const pair = multisig.multisig_pk.pk_map[pkIndex];
    const pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);
    if (signatureScheme === "MultiSig") {
      throw new Error("MultiSig is not supported inside MultiSig");
    }
    const publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);
    res[i2] = {
      signatureScheme,
      signature: Uint8Array.from(signature),
      publicKey,
      weight: pair.weight
    };
  }
  return res;
}
function asIndices(bitmap) {
  if (bitmap < 0 || bitmap > 1024) {
    throw new Error("Invalid bitmap");
  }
  const res = [];
  for (let i2 = 0; i2 < 10; i2++) {
    if ((bitmap & 1 << i2) !== 0) {
      res.push(i2);
    }
  }
  return Uint8Array.from(res);
}

// node_modules/@mysten/seal/node_modules/@mysten/sui/dist/esm/verify/verify.js
async function verifyPersonalMessageSignature(message, signature, options = {}) {
  const parsedSignature = parseSignature(signature, options);
  if (!await parsedSignature.publicKey.verifyPersonalMessage(
    message,
    parsedSignature.serializedSignature
  )) {
    throw new Error(`Signature is not valid for the provided message`);
  }
  if (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {
    throw new Error(`Signature is not valid for the provided address`);
  }
  return parsedSignature.publicKey;
}
function parseSignature(signature, options = {}) {
  const parsedSignature = parseSerializedSignature2(signature);
  if (parsedSignature.signatureScheme === "MultiSig") {
    return {
      ...parsedSignature,
      publicKey: new MultiSigPublicKey3(parsedSignature.multisig.multisig_pk)
    };
  }
  const publicKey = publicKeyFromRawBytes(
    parsedSignature.signatureScheme,
    parsedSignature.publicKey,
    options
  );
  return {
    ...parsedSignature,
    publicKey
  };
}
function publicKeyFromRawBytes(signatureScheme, bytes, options = {}) {
  let publicKey;
  switch (signatureScheme) {
    case "ED25519":
      publicKey = new Ed25519PublicKey2(bytes);
      break;
    case "Secp256k1":
      publicKey = new Secp256k1PublicKey(bytes);
      break;
    case "Secp256r1":
      publicKey = new Secp256r1PublicKey(bytes);
      break;
    case "MultiSig":
      publicKey = new MultiSigPublicKey3(bytes);
      break;
    case "ZkLogin":
      publicKey = ZkLoginPublicIdentifier.fromBytes(bytes, options);
      break;
    case "Passkey":
      publicKey = new PasskeyPublicKey(bytes);
      break;
    default:
      throw new Error(`Unsupported signature scheme ${signatureScheme}`);
  }
  if (options.address && publicKey.toSuiAddress() !== options.address) {
    throw new Error(`Public key bytes do not match the provided address`);
  }
  return publicKey;
}

// node_modules/@mysten/seal/dist/esm/session-key.js
var __typeError18 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck18 = (obj, member, msg) => member.has(obj) || __typeError18("Cannot " + msg);
var __privateGet17 = (obj, member, getter) => (__accessCheck18(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd18 = (obj, member, value2) => member.has(obj) ? __typeError18("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet17 = (obj, member, value2, setter) => (__accessCheck18(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _address;
var _packageId;
var _creationTimeMs;
var _ttlMin;
var _sessionKey;
var _personalMessageSignature;
var _signer;
var _client2;
var RequestFormat = suiBcs2.struct("RequestFormat", {
  ptb: suiBcs2.vector(suiBcs2.U8),
  encKey: suiBcs2.vector(suiBcs2.U8),
  encVerificationKey: suiBcs2.vector(suiBcs2.U8)
});
var _SessionKey = class _SessionKey2 {
  constructor({
    address,
    packageId,
    ttlMin,
    signer,
    client
  }) {
    __privateAdd18(this, _address);
    __privateAdd18(this, _packageId);
    __privateAdd18(this, _creationTimeMs);
    __privateAdd18(this, _ttlMin);
    __privateAdd18(this, _sessionKey);
    __privateAdd18(this, _personalMessageSignature);
    __privateAdd18(this, _signer);
    __privateAdd18(this, _client2);
    if (!isValidSuiObjectId2(packageId) || !isValidSuiAddress2(address)) {
      throw new UserError(`Invalid package ID ${packageId} or address ${address}`);
    }
    if (ttlMin > 30 || ttlMin < 1) {
      throw new UserError(`Invalid TTL ${ttlMin}, must be between 1 and 30`);
    }
    if (signer && signer.getPublicKey().toSuiAddress() !== address) {
      throw new UserError("Signer address does not match session key address");
    }
    __privateSet17(this, _address, address);
    __privateSet17(this, _packageId, packageId);
    __privateSet17(this, _creationTimeMs, Date.now());
    __privateSet17(this, _ttlMin, ttlMin);
    __privateSet17(this, _sessionKey, Ed25519Keypair2.generate());
    __privateSet17(this, _signer, signer);
    __privateSet17(this, _client2, client);
  }
  isExpired() {
    return __privateGet17(this, _creationTimeMs) + __privateGet17(this, _ttlMin) * 60 * 1e3 - 1e4 < Date.now();
  }
  getAddress() {
    return __privateGet17(this, _address);
  }
  getPackageId() {
    return __privateGet17(this, _packageId);
  }
  getPersonalMessage() {
    const creationTimeUtc = new Date(__privateGet17(this, _creationTimeMs)).toISOString().slice(0, 19).replace("T", " ") + " UTC";
    const message = `Accessing keys of package ${__privateGet17(this, _packageId)} for ${__privateGet17(this, _ttlMin)} mins from ${creationTimeUtc}, session key ${toBase642(__privateGet17(this, _sessionKey).getPublicKey().toRawBytes())}`;
    return new TextEncoder().encode(message);
  }
  async setPersonalMessageSignature(personalMessageSignature) {
    try {
      await verifyPersonalMessageSignature(this.getPersonalMessage(), personalMessageSignature, {
        address: __privateGet17(this, _address),
        client: __privateGet17(this, _client2)
      });
      __privateSet17(this, _personalMessageSignature, personalMessageSignature);
    } catch (e3) {
      throw new InvalidPersonalMessageSignatureError("Not valid");
    }
  }
  async getCertificate() {
    if (!__privateGet17(this, _personalMessageSignature)) {
      if (__privateGet17(this, _signer)) {
        const { signature } = await __privateGet17(this, _signer).signPersonalMessage(this.getPersonalMessage());
        __privateSet17(this, _personalMessageSignature, signature);
      } else {
        throw new InvalidPersonalMessageSignatureError("Personal message signature is not set");
      }
    }
    return {
      user: __privateGet17(this, _address),
      session_vk: toBase642(__privateGet17(this, _sessionKey).getPublicKey().toRawBytes()),
      creation_time: __privateGet17(this, _creationTimeMs),
      ttl_min: __privateGet17(this, _ttlMin),
      signature: __privateGet17(this, _personalMessageSignature)
    };
  }
  async createRequestParams(txBytes) {
    if (this.isExpired()) {
      throw new ExpiredSessionKeyError();
    }
    const egSk = generateSecretKey();
    const msgToSign = RequestFormat.serialize({
      ptb: txBytes.slice(1),
      encKey: toPublicKey(egSk),
      encVerificationKey: toVerificationKey(egSk)
    }).toBytes();
    return {
      decryptionKey: egSk,
      requestSignature: toBase642(await __privateGet17(this, _sessionKey).sign(msgToSign))
    };
  }
  /**
   * Export the Session Key object from the instance. Store the object in IndexedDB to persist.
   */
  export() {
    const obj = {
      address: __privateGet17(this, _address),
      packageId: __privateGet17(this, _packageId),
      creationTimeMs: __privateGet17(this, _creationTimeMs),
      ttlMin: __privateGet17(this, _ttlMin),
      personalMessageSignature: __privateGet17(this, _personalMessageSignature),
      sessionKey: __privateGet17(this, _sessionKey).getSecretKey()
      // bech32 encoded string
    };
    Object.defineProperty(obj, "toJSON", {
      enumerable: false,
      value: () => {
        throw new Error("This object is not serializable");
      }
    });
    return obj;
  }
  /**
   * Restore a SessionKey instance for the given object.
   * @returns A new SessionKey instance with restored state
   */
  static async import(data, { signer, client }) {
    const instance = new _SessionKey2({
      address: data.address,
      packageId: data.packageId,
      ttlMin: data.ttlMin,
      signer,
      client
    });
    __privateSet17(instance, _creationTimeMs, data.creationTimeMs);
    __privateSet17(instance, _sessionKey, Ed25519Keypair2.fromSecretKey(data.sessionKey));
    if (data.personalMessageSignature) {
      await instance.setPersonalMessageSignature(data.personalMessageSignature);
    }
    if (instance.isExpired()) {
      throw new ExpiredSessionKeyError();
    }
    return instance;
  }
};
_address = /* @__PURE__ */ new WeakMap();
_packageId = /* @__PURE__ */ new WeakMap();
_creationTimeMs = /* @__PURE__ */ new WeakMap();
_ttlMin = /* @__PURE__ */ new WeakMap();
_sessionKey = /* @__PURE__ */ new WeakMap();
_personalMessageSignature = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_client2 = /* @__PURE__ */ new WeakMap();
var SessionKey = _SessionKey;

// src/utils/sealUtil.ts
function SealUtil({ vaultId, moduleName, packageId, wallet }) {
  const SUI_VIEW_TX_URL = `https://suiscan.xyz/testnet/tx`;
  const SUI_VIEW_OBJECT_URL = `https://suiscan.xyz/testnet/object`;
  const services = [
    {
      id: "service1",
      name: "walrus.space",
      publisherUrl: "https://walrus.space/publisher",
      aggregatorUrl: "https://walrus.space/aggregator"
    },
    {
      id: "service2",
      name: "staketab.org",
      publisherUrl: "https://staketab.org/publisher",
      aggregatorUrl: "https://staketab.org/aggregator"
    },
    {
      id: "service3",
      name: "redundex.com",
      publisherUrl: "https://redundex.com/publisher",
      aggregatorUrl: "https://redundex.com/aggregator"
    },
    {
      id: "service4",
      name: "nodes.guru",
      publisherUrl: "https://nodes.guru/publisher",
      aggregatorUrl: "https://nodes.guru/aggregator"
    },
    {
      id: "service5",
      name: "banansen.dev",
      publisherUrl: "https://banansen.dev/publisher",
      aggregatorUrl: "https://banansen.dev/aggregator"
    },
    {
      id: "service6",
      name: "everstake.one",
      publisherUrl: "https://everstake.one/publisher",
      aggregatorUrl: "https://everstake.one/aggregator"
    }
  ];
  let selectedService = services[0].id;
  function getAggregatorUrl(path) {
    const service = services.find((s) => s.id === selectedService);
    const cleanPath = path.replace(/^\/+/, "").replace(/^v1\//, "");
    return `${service?.aggregatorUrl.replace(/\/+$/, "")}/v1/${cleanPath}`;
  }
  function getPublisherUrl(path) {
    const service = services.find((s) => s.id === selectedService);
    const cleanPath = path.replace(/^\/+/, "").replace(/^v1\//, "");
    return `${service?.publisherUrl.replace(/\/+$/, "")}/v1/${cleanPath}`;
  }
  const handleSubmit = async (file, epoch) => {
    if (!file) {
      throw new Error("\u672A\u9009\u62E9\u6587\u4EF6");
    }
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      reader.onload = async (event) => {
        try {
          if (!event.target?.result || !(event.target.result instanceof ArrayBuffer)) {
            throw new Error("\u6587\u4EF6\u6570\u636E\u65E0\u6548");
          }
          const suiClient = new SuiJsonRpcClient({ url: getFullnodeUrl("testnet") });
          const client = new SealClient({
            suiClient,
            // 
            serverObjectIds: getAllowlistedKeyServers("testnet").map((id2) => [
              id2,
              1
            ]),
            verifyKeyServers: false
          });
          const nonce = crypto.getRandomValues(new Uint8Array(5));
          const policyObjectBytes = fromHex(vaultId);
          const id = toHex(new Uint8Array([...policyObjectBytes, ...nonce]));
          const { encryptedObject: encryptedBytes } = await client.encrypt({
            threshold: 2,
            packageId,
            id,
            data: new Uint8Array(event.target.result)
          });
          const storageInfo = await storeBlob(encryptedBytes, epoch);
          if (storageInfo) {
            resolve(displayUpload(storageInfo.info, file.type));
          } else {
            reject(new Error("\u5B58\u50A8\u6570\u636E\u5230Walrus\u5931\u8D25"));
          }
        } catch (error2) {
          reject(error2);
        }
      };
      reader.readAsArrayBuffer(file);
    });
  };
  const storeBlob = async (encryptedData, epoch) => {
    try {
      console.log("\u5C1D\u8BD5\u5728Walrus\u670D\u52A1\u5668\u5B58\u50A8\u6570\u636E");
      const url = getPublisherUrl(`/v1/blobs?epochs=${epoch}`);
      const response = await fetch(url, {
        method: "PUT",
        body: new Blob([encryptedData])
        //  Uint8Array  Blob 
      });
      if (response.status === 200) {
        const info = await response.json();
        return { info };
      } else {
        console.error(`\u5B58\u50A8\u5931\u8D25\uFF0C\u72B6\u6001\u7801: ${response.status}`);
        throw new Error("\u5728Walrus\u4E0A\u53D1\u5E03\u6570\u636E\u65F6\u51FA\u9519\uFF0C\u8BF7\u9009\u62E9\u5176\u4ED6Walrus\u670D\u52A1\u3002");
      }
    } catch (e3) {
      console.error("\u5728Walrus\u4E0A\u53D1\u5E03\u6570\u636E\u65F6\u51FA\u9519\uFF1A", e3);
      let urls = [
        "https://publisher.walrus-testnet.walrus.space",
        "https://wal-publisher-testnet.staketab.org",
        "https://walrus-testnet-publisher.bartestnet.com",
        "https://walrus-testnet-publisher.nodes.guru",
        "https://sui-walrus-testnet.bwarelabs.com/publisher",
        "https://walrus-testnet-publisher.stakin-nodes.com",
        "https://testnet-publisher-walrus.kiliglab.io",
        "https://walrus-testnet-publisher.nodeinfra.com",
        "https://walrus-testnet.blockscope.net:11444",
        "https://walrus-publish-testnet.chainode.tech:9003",
        "https://walrus-testnet-publisher.starduststaking.com:11445",
        "http://walrus-publisher-testnet.overclock.run:9001",
        "http://walrus-testnet-publisher.everstake.one:9001",
        "http://walrus.testnet.pops.one:9001",
        "http://ivory-dakar-e5812.walrus.bdnodes.net:9001",
        "http://publisher.testnet.sui.rpcpool.com:9001",
        "http://walrus.krates.ai:9001",
        "http://walrus-publisher-testnet.latitude-sui.com:9001",
        "http://walrus-tn.juicystake.io:9090",
        "http://walrus-testnet.stakingdefenseleague.com:9001",
        "http://walrus.sui.thepassivetrust.com:9001"
      ];
      for (let url of urls) {
        try {
          console.log("\u5C1D\u8BD5\u5728\u5907\u7528\u670D\u52A1\u5668\u5B58\u50A8\u6570\u636E:", url);
          const response = await fetch(url + "/v1/blobs?epochs=" + epoch, {
            method: "PUT",
            body: new Blob([encryptedData])
            //  Uint8Array  Blob 
          });
          if (response.status === 200) {
            const info = await response.json();
            return { info };
          }
        } catch (e4) {
          console.error("\u5907\u7528\u670D\u52A1\u5668\u5B58\u50A8\u5931\u8D25\uFF0C\u5C1D\u8BD5\u4E0B\u4E00\u4E2AURL", e4);
        }
      }
    }
    return null;
  };
  const displayUpload = (storage_info, media_type) => {
    let info;
    if ("alreadyCertified" in storage_info) {
      info = {
        status: "Already certified",
        blobId: storage_info.alreadyCertified.blobId,
        endEpoch: storage_info.alreadyCertified.endEpoch,
        suiRefType: "Previous Sui Certified Event",
        suiRef: storage_info.alreadyCertified.event.txDigest,
        suiBaseUrl: SUI_VIEW_TX_URL,
        blobUrl: getAggregatorUrl(`/v1/blobs/${storage_info.alreadyCertified.blobId}`),
        suiUrl: `${SUI_VIEW_OBJECT_URL}/${storage_info.alreadyCertified.event.txDigest}`,
        isImage: media_type.startsWith("image")
      };
    } else if ("newlyCreated" in storage_info) {
      info = {
        status: "Newly created",
        blobId: storage_info.newlyCreated.blobObject.blobId,
        endEpoch: storage_info.newlyCreated.blobObject.storage.endEpoch,
        suiRefType: "Associated Sui Object",
        suiRef: storage_info.newlyCreated.blobObject.id,
        suiBaseUrl: SUI_VIEW_OBJECT_URL,
        blobUrl: getAggregatorUrl(`/v1/blobs/${storage_info.newlyCreated.blobObject.blobId}`),
        suiUrl: `${SUI_VIEW_OBJECT_URL}/${storage_info.newlyCreated.blobObject.id}`,
        isImage: media_type.startsWith("image")
      };
    } else {
      throw Error("\u672A\u5904\u7406\u7684\u6210\u529F\u54CD\u5E94!");
    }
    console.log("\u4E0A\u4F20\u7ED3\u679C:", info);
    return info;
  };
  async function handlePublish(title, end_epoch, parent_dir, blob_id) {
    const tx = new Transaction();
    tx.setSender(wallet.getAddress());
    let fileResult = tx.moveCall({
      target: PACKAGE_ID + "::perlite_sync::new_file",
      arguments: [tx.pure.string(title), tx.pure.string(blob_id), tx.pure.u64(end_epoch), tx.object(parent_dir), tx.object("0x6")]
    });
    tx.moveCall({
      target: `${PACKAGE_ID}::perlite_sync::transfer_file`,
      arguments: [tx.object(fileResult), tx.pure.address(wallet.getAddress())]
    });
    tx.setGasBudget(1e7);
    const suiClient = new SuiJsonRpcClient({ url: getFullnodeUrl("testnet") });
    try {
      (async () => {
        let txBytes = await tx.build({ client: suiClient });
        let signature = await wallet.signTransaction(txBytes);
        let txResult = await suiClient.executeTransactionBlock({
          transactionBlock: txBytes,
          signature
        });
        console.log("\u53D1\u5E03\u6587\u4EF6\u4EA4\u6613\u7ED3\u679C:", txResult);
      })();
    } catch (e3) {
      console.log("\u4EA4\u6613\u6784\u5EFA\u9519\u8BEF:", e3);
    }
  }
  async function downloadFile(file, filePath, adapter) {
    const TTL_MIN = 10;
    const sessionKey = new SessionKey({
      address: wallet.getAddress(),
      packageId,
      ttlMin: TTL_MIN
    });
    try {
      const suiClient = new SuiJsonRpcClient({ url: getFullnodeUrl("testnet") });
      const client = new SealClient({
        suiClient,
        // 
        serverObjectIds: getAllowlistedKeyServers("testnet").map((id) => [
          id,
          1
        ]),
        verifyKeyServers: false
      });
      let message = sessionKey.getPersonalMessage();
      let signature = await wallet.signPersonalMessage(message);
      const moveCallConstructor = await constructMoveCall(packageId, file.id);
      await sessionKey.setPersonalMessageSignature(signature);
      const blobs = await downloadAndDecrypt(
        adapter,
        [file.blob_id],
        sessionKey,
        suiClient,
        client,
        moveCallConstructor
      );
      for (let i2 = 0; i2 < blobs.length; i2++) {
        const blob = blobs[i2];
        await saveToLocal(adapter, blob, filePath);
      }
    } catch (error2) {
      console.error("\u9519\u8BEF:", error2);
    }
  }
  async function downloadAndDecrypt(adapter, blobIds, sessionKey, suiClient, sealClient, moveCallConstructor) {
    const aggregators = [
      "https://aggregator.walrus-testnet.walrus.space",
      "https://wal-aggregator-testnet.staketab.org",
      "https://walrus-testnet-aggregator.bartestnet.com",
      "https://walrus-testnet.blockscope.net",
      "https://walrus-testnet-aggregator.nodes.guru",
      "https://walrus-cache-testnet.overclock.run",
      "https://sui-walrus-testnet.bwarelabs.com/aggregator",
      "https://walrus-testnet-aggregator.stakin-nodes.com",
      "https://testnet-aggregator-walrus.kiliglab.io",
      "https://walrus-cache-testnet.latitude-sui.com",
      "https://walrus-testnet-aggregator.nodeinfra.com",
      "https://walrus-tn.juicystake.io:9443",
      "https://walrus-agg-testnet.chainode.tech:9002",
      "https://walrus-testnet-aggregator.starduststaking.com:11444",
      "http://walrus-testnet-aggregator.everstake.one:9000",
      "http://walrus.testnet.pops.one:9000",
      "http://scarlet-brussels-376c2.walrus.bdnodes.net:9000",
      "http://aggregator.testnet.sui.rpcpool.com:9000",
      "http://walrus.krates.ai:9000",
      "http://walrus-testnet.stakingdefenseleague.com:9000",
      "http://walrus.sui.thepassivetrust.com:9000"
    ];
    const blobs = [];
    const downloadResults = await Promise.all(
      blobIds.map(async (blobId) => {
        for (let aggregator of aggregators) {
          try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 1e4);
            const aggregatorUrl = `${aggregator}/v1/blobs/${blobId}`;
            const response = await fetch(aggregatorUrl, { signal: controller.signal });
            clearTimeout(timeout);
            if (!response.ok) {
              continue;
            }
            return await response.arrayBuffer();
          } catch (err) {
            console.error(`\u65E0\u6CD5\u4ECEWalrus\u68C0\u7D22Blob ${blobId}`, err);
            continue;
          }
        }
        return null;
      })
    );
    const validDownloads = downloadResults.filter((result) => result !== null);
    console.log("\u6709\u6548\u4E0B\u8F7D\u6570\u91CF:", validDownloads.length);
    console.log("\u6709\u6548\u4E0B\u8F7D:", validDownloads);
    if (validDownloads.length === 0) {
      const errorMsg = "\u65E0\u6CD5\u4ECE\u6B64Walrus\u805A\u5408\u5668\u68C0\u7D22\u6587\u4EF6\uFF0C\u8BF7\u91CD\u8BD5\uFF08\u5C06\u4F7F\u7528\u968F\u673A\u9009\u62E9\u7684\u805A\u5408\u5668\uFF09\u3002\u4E0A\u4F20\u8D85\u8FC71\u4E2Aepoch\u7684\u6587\u4EF6\u5DF2\u4ECEWalrus\u4E2D\u5220\u9664\u3002";
      console.error(errorMsg);
      return blobs;
    }
    for (let i2 = 0; i2 < validDownloads.length; i2 += 10) {
      const batch = validDownloads.slice(i2, i2 + 10);
      const ids = batch.map((enc) => EncryptedObject.parse(new Uint8Array(enc)).id);
      const tx = new Transaction();
      ids.forEach((id) => moveCallConstructor(tx, id));
      const txBytes = await tx.build({ client: suiClient, onlyTransactionKind: true });
      try {
        await sealClient.fetchKeys({ ids, txBytes, sessionKey, threshold: 2 });
      } catch (err) {
        console.log(err);
        const errorMsg = err instanceof NoAccessError ? "\u65E0\u6743\u8BBF\u95EE\u89E3\u5BC6\u5BC6\u94A5" : "\u65E0\u6CD5\u89E3\u5BC6\u6587\u4EF6\uFF0C\u8BF7\u91CD\u8BD5";
        console.error(errorMsg, err);
        return blobs;
      }
    }
    for (const encryptedData of validDownloads) {
      const fullId = EncryptedObject.parse(new Uint8Array(encryptedData)).id;
      const tx = new Transaction();
      moveCallConstructor(tx, fullId);
      const txBytes = await tx.build({ client: suiClient, onlyTransactionKind: true });
      try {
        const decryptedFile = await sealClient.decrypt({
          data: new Uint8Array(encryptedData),
          sessionKey,
          txBytes
        });
        const blob = new Blob([decryptedFile], { type: "text/markdown" });
        console.log("\u6587\u4EF6\u5185\u5BB9:", blob);
        blobs.push(blob);
      } catch (err) {
        console.log(err);
        const errorMsg = err instanceof NoAccessError ? "\u65E0\u6743\u8BBF\u95EE\u89E3\u5BC6\u5BC6\u94A5" : "\u65E0\u6CD5\u89E3\u5BC6\u6587\u4EF6\uFF0C\u8BF7\u91CD\u8BD5";
        console.error(errorMsg, err);
        return blobs;
      }
    }
    return blobs;
  }
  ;
  function constructMoveCall(packageId2, fileId) {
    return (tx, id) => {
      tx.moveCall({
        target: PACKAGE_ID + `::perlite_sync::seal_approve`,
        arguments: [tx.pure.vector("u8", fromHex(id)), tx.object(fileId)]
      });
    };
  }
  async function saveToLocal(adapter, blob, filePath) {
    try {
      const arrayBuffer = await blob.arrayBuffer();
      adapter.writeBinary(filePath, arrayBuffer);
      console.log(`\u6587\u4EF6\u5DF2\u4FDD\u5B58\u5230: ${filePath}`);
    } catch (error2) {
      console.error("\u4FDD\u5B58\u6587\u4EF6\u5931\u8D25:", error2);
      throw error2;
    }
  }
  ;
  async function downloadFileContent(file) {
    const TTL_MIN = 10;
    const sessionKey = new SessionKey({
      address: wallet.getAddress(),
      packageId,
      ttlMin: TTL_MIN
    });
    try {
      const suiClient = new SuiJsonRpcClient({ url: getFullnodeUrl("testnet") });
      const client = new SealClient({
        suiClient,
        serverObjectIds: getAllowlistedKeyServers("testnet").map((id) => [
          id,
          1
        ]),
        verifyKeyServers: false
      });
      let message = sessionKey.getPersonalMessage();
      let signature = await wallet.signPersonalMessage(message);
      const moveCallConstructor = await constructMoveCall(packageId, file.id);
      await sessionKey.setPersonalMessageSignature(signature);
      const blobs = await downloadAndDecrypt(
        null,
        // adapter
        [file.blob_id],
        sessionKey,
        suiClient,
        client,
        moveCallConstructor
      );
      if (blobs.length === 0) {
        throw new Error("\u4E0B\u8F7D\u6587\u4EF6\u5185\u5BB9\u5931\u8D25");
      }
      const blob = blobs[0];
      const text = await blob.text();
      return text;
    } catch (error2) {
      console.error("\u4E0B\u8F7D\u6587\u4EF6\u5185\u5BB9\u9519\u8BEF:", error2);
      throw error2;
    }
  }
  return {
    handleSubmit,
    displayUpload,
    downloadFile,
    downloadFileContent,
    handlePublish: (title, end_epoch, parent_dir, blob_id) => handlePublish(title, end_epoch, parent_dir, blob_id)
  };
}

// src/components/modal.ts
var import_obsidian = require("obsidian");

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value2) => {
      value2 = this.postProcess(value2, options);
      if (callback) {
        setTimeout(function() {
          callback(value2);
        }, 0);
        return void 0;
      } else {
        return value2;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array2) {
    const ret = [];
    for (let i2 = 0; i2 < array2.length; i2++) {
      if (array2[i2]) {
        ret.push(array2[i2]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value2, options) {
    return value2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value2, options) {
    return Array.from(value2);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value2 = newTokens.slice(newPos, newPos + component.count);
          value2 = value2.map(function(value3, i2) {
            const oldValue = oldTokens[oldPos + i2];
            return oldValue.length > value3.length ? oldValue : value3;
          });
          component.value = this.join(value2);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/diff/line.js
var LineDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  equals(left, right, options) {
    if (options.ignoreWhitespace) {
      if (!options.newlineIsToken || !left.includes("\n")) {
        left = left.trim();
      }
      if (!options.newlineIsToken || !right.includes("\n")) {
        right = right.trim();
      }
    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
      if (left.endsWith("\n")) {
        left = left.slice(0, -1);
      }
      if (right.endsWith("\n")) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options);
  }
};
var lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value2, options) {
  if (options.stripTrailingCr) {
    value2 = value2.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i2 = 0; i2 < linesAndNewlines.length; i2++) {
    const line = linesAndNewlines[i2];
    if (i2 % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}

// node_modules/diff/libesm/patch/create.js
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  let optionsObj;
  if (!options) {
    optionsObj = {};
  } else if (typeof options === "function") {
    optionsObj = { callback: options };
  } else {
    optionsObj = options;
  }
  if (typeof optionsObj.context === "undefined") {
    optionsObj.context = 4;
  }
  const context = optionsObj.context;
  if (optionsObj.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!optionsObj.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  } else {
    const { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff2) => {
      const patch = diffLinesResultToPatch(diff2);
      callback(patch);
    } }));
  }
  function diffLinesResultToPatch(diff2) {
    if (!diff2) {
      return;
    }
    diff2.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    const hunks = [];
    let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i2 = 0; i2 < diff2.length; i2++) {
      const current = diff2[i2], lines = current.lines || splitLines(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        if (!oldRangeStart) {
          const prev = diff2[i2 - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        for (const line of lines) {
          curRange.push((current.added ? "+" : "-") + line);
        }
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= context * 2 && i2 < diff2.length - 2) {
            for (const line of contextLines(lines)) {
              curRange.push(line);
            }
          } else {
            const contextSize = Math.min(lines.length, context);
            for (const line of contextLines(lines.slice(0, contextSize))) {
              curRange.push(line);
            }
            const hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }
    for (const hunk of hunks) {
      for (let i2 = 0; i2 < hunk.lines.length; i2++) {
        if (hunk.lines[i2].endsWith("\n")) {
          hunk.lines[i2] = hunk.lines[i2].slice(0, -1);
        } else {
          hunk.lines.splice(i2 + 1, 0, "\\ No newline at end of file");
          i2++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function formatPatch(patch) {
  if (Array.isArray(patch)) {
    return patch.map(formatPatch).join("\n");
  }
  const ret = [];
  if (patch.oldFileName == patch.newFileName) {
    ret.push("Index: " + patch.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader === "undefined" ? "" : "	" + patch.oldHeader));
  ret.push("+++ " + patch.newFileName + (typeof patch.newHeader === "undefined" ? "" : "	" + patch.newHeader));
  for (let i2 = 0; i2 < patch.hunks.length; i2++) {
    const hunk = patch.hunks[i2];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    for (const line of hunk.lines) {
      ret.push(line);
    }
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (typeof options === "function") {
    options = { callback: options };
  }
  if (!(options === null || options === void 0 ? void 0 : options.callback)) {
    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj);
  } else {
    const { callback } = options;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options), { callback: (patchObj) => {
      if (!patchObj) {
        callback(void 0);
      } else {
        callback(formatPatch(patchObj));
      }
    } }));
  }
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}
function splitLines(text) {
  const hasTrailingNl = text.endsWith("\n");
  const result = text.split("\n").map((line) => line + "\n");
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}

// node_modules/diff2html/lib-esm/types.js
var LineType;
(function(LineType2) {
  LineType2["INSERT"] = "insert";
  LineType2["DELETE"] = "delete";
  LineType2["CONTEXT"] = "context";
})(LineType || (LineType = {}));
var OutputFormatType = {
  LINE_BY_LINE: "line-by-line",
  SIDE_BY_SIDE: "side-by-side"
};
var LineMatchingType = {
  LINES: "lines",
  WORDS: "words",
  NONE: "none"
};
var DiffStyleType = {
  WORD: "word",
  CHAR: "char"
};
var ColorSchemeType;
(function(ColorSchemeType2) {
  ColorSchemeType2["AUTO"] = "auto";
  ColorSchemeType2["DARK"] = "dark";
  ColorSchemeType2["LIGHT"] = "light";
})(ColorSchemeType || (ColorSchemeType = {}));

// node_modules/diff2html/lib-esm/utils.js
var specials = [
  "-",
  "[",
  "]",
  "/",
  "{",
  "}",
  "(",
  ")",
  "*",
  "+",
  "?",
  ".",
  "\\",
  "^",
  "$",
  "|"
];
var regex = RegExp("[" + specials.join("\\") + "]", "g");
function escapeForRegExp(str) {
  return str.replace(regex, "\\$&");
}
function unifyPath(path) {
  return path ? path.replace(/\\/g, "/") : path;
}
function hashCode(text) {
  let i2, chr, len;
  let hash = 0;
  for (i2 = 0, len = text.length; i2 < len; i2++) {
    chr = text.charCodeAt(i2);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
}
function max(arr) {
  const length = arr.length;
  let max2 = -Infinity;
  for (let i2 = 0; i2 < length; i2++) {
    max2 = Math.max(max2, arr[i2]);
  }
  return max2;
}

// node_modules/diff2html/lib-esm/diff-parser.js
function getExtension(filename, language) {
  const filenameParts = filename.split(".");
  return filenameParts.length > 1 ? filenameParts[filenameParts.length - 1] : language;
}
function startsWithAny(str, prefixes) {
  return prefixes.reduce((startsWith, prefix) => startsWith || str.startsWith(prefix), false);
}
var baseDiffFilenamePrefixes = ["a/", "b/", "i/", "w/", "c/", "o/"];
function getFilename(line, linePrefix, extraPrefix) {
  const prefixes = extraPrefix !== void 0 ? [...baseDiffFilenamePrefixes, extraPrefix] : baseDiffFilenamePrefixes;
  const FilenameRegExp = linePrefix ? new RegExp(`^${escapeForRegExp(linePrefix)} "?(.+?)"?$`) : new RegExp('^"?(.+?)"?$');
  const [, filename = ""] = FilenameRegExp.exec(line) || [];
  const matchingPrefix = prefixes.find((p) => filename.indexOf(p) === 0);
  const fnameWithoutPrefix = matchingPrefix ? filename.slice(matchingPrefix.length) : filename;
  return fnameWithoutPrefix.replace(/\s+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)? [+-]\d{4}.*$/, "");
}
function getSrcFilename(line, srcPrefix) {
  return getFilename(line, "---", srcPrefix);
}
function getDstFilename(line, dstPrefix) {
  return getFilename(line, "+++", dstPrefix);
}
function parse4(diffInput, config = {}) {
  const files = [];
  let currentFile = null;
  let currentBlock = null;
  let oldLine = null;
  let oldLine2 = null;
  let newLine = null;
  let possibleOldName = null;
  let possibleNewName = null;
  const oldFileNameHeader = "--- ";
  const newFileNameHeader = "+++ ";
  const hunkHeaderPrefix = "@@";
  const oldMode = /^old mode (\d{6})/;
  const newMode = /^new mode (\d{6})/;
  const deletedFileMode = /^deleted file mode (\d{6})/;
  const newFileMode = /^new file mode (\d{6})/;
  const copyFrom = /^copy from "?(.+)"?/;
  const copyTo = /^copy to "?(.+)"?/;
  const renameFrom = /^rename from "?(.+)"?/;
  const renameTo = /^rename to "?(.+)"?/;
  const similarityIndex = /^similarity index (\d+)%/;
  const dissimilarityIndex = /^dissimilarity index (\d+)%/;
  const index = /^index ([\da-z]+)\.\.([\da-z]+)\s*(\d{6})?/;
  const binaryFiles = /^Binary files (.*) and (.*) differ/;
  const binaryDiff = /^GIT binary patch/;
  const combinedIndex = /^index ([\da-z]+),([\da-z]+)\.\.([\da-z]+)/;
  const combinedMode = /^mode (\d{6}),(\d{6})\.\.(\d{6})/;
  const combinedNewFile = /^new file mode (\d{6})/;
  const combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
  const diffLines2 = diffInput.replace(/\\ No newline at end of file/g, "").replace(/\r\n?/g, "\n").split("\n");
  function saveBlock() {
    if (currentBlock !== null && currentFile !== null) {
      currentFile.blocks.push(currentBlock);
      currentBlock = null;
    }
  }
  function saveFile() {
    if (currentFile !== null) {
      if (!currentFile.oldName && possibleOldName !== null) {
        currentFile.oldName = possibleOldName;
      }
      if (!currentFile.newName && possibleNewName !== null) {
        currentFile.newName = possibleNewName;
      }
      if (currentFile.newName) {
        files.push(currentFile);
        currentFile = null;
      }
    }
    possibleOldName = null;
    possibleNewName = null;
  }
  function startFile() {
    saveBlock();
    saveFile();
    currentFile = {
      blocks: [],
      deletedLines: 0,
      addedLines: 0
    };
  }
  function startBlock(line) {
    saveBlock();
    let values;
    if (currentFile !== null) {
      if (values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@.*/.exec(line)) {
        currentFile.isCombined = false;
        oldLine = parseInt(values[1], 10);
        newLine = parseInt(values[2], 10);
      } else if (values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@.*/.exec(line)) {
        currentFile.isCombined = true;
        oldLine = parseInt(values[1], 10);
        oldLine2 = parseInt(values[2], 10);
        newLine = parseInt(values[3], 10);
      } else {
        if (line.startsWith(hunkHeaderPrefix)) {
          console.error("Failed to parse lines, starting in 0!");
        }
        oldLine = 0;
        newLine = 0;
        currentFile.isCombined = false;
      }
    }
    currentBlock = {
      lines: [],
      oldStartLine: oldLine,
      oldStartLine2: oldLine2,
      newStartLine: newLine,
      header: line
    };
  }
  function createLine(line) {
    if (currentFile === null || currentBlock === null || oldLine === null || newLine === null)
      return;
    const currentLine = {
      content: line
    };
    const addedPrefixes = currentFile.isCombined ? ["+ ", " +", "++"] : ["+"];
    const deletedPrefixes = currentFile.isCombined ? ["- ", " -", "--"] : ["-"];
    if (startsWithAny(line, addedPrefixes)) {
      currentFile.addedLines++;
      currentLine.type = LineType.INSERT;
      currentLine.oldNumber = void 0;
      currentLine.newNumber = newLine++;
    } else if (startsWithAny(line, deletedPrefixes)) {
      currentFile.deletedLines++;
      currentLine.type = LineType.DELETE;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = void 0;
    } else {
      currentLine.type = LineType.CONTEXT;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = newLine++;
    }
    currentBlock.lines.push(currentLine);
  }
  function existHunkHeader(line, lineIdx) {
    let idx = lineIdx;
    while (idx < diffLines2.length - 3) {
      if (line.startsWith("diff")) {
        return false;
      }
      if (diffLines2[idx].startsWith(oldFileNameHeader) && diffLines2[idx + 1].startsWith(newFileNameHeader) && diffLines2[idx + 2].startsWith(hunkHeaderPrefix)) {
        return true;
      }
      idx++;
    }
    return false;
  }
  diffLines2.forEach((line, lineIndex) => {
    if (!line || line.startsWith("*")) {
      return;
    }
    let values;
    const prevLine = diffLines2[lineIndex - 1];
    const nxtLine = diffLines2[lineIndex + 1];
    const afterNxtLine = diffLines2[lineIndex + 2];
    if (line.startsWith("diff --git") || line.startsWith("diff --combined")) {
      startFile();
      const gitDiffStart = /^diff --git "?([a-ciow]\/.+)"? "?([a-ciow]\/.+)"?/;
      if (values = gitDiffStart.exec(line)) {
        possibleOldName = getFilename(values[1], void 0, config.dstPrefix);
        possibleNewName = getFilename(values[2], void 0, config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isGitDiff = true;
      return;
    }
    if (line.startsWith("Binary files") && !(currentFile === null || currentFile === void 0 ? void 0 : currentFile.isGitDiff)) {
      startFile();
      const unixDiffBinaryStart = /^Binary files "?([a-ciow]\/.+)"? and "?([a-ciow]\/.+)"? differ/;
      if (values = unixDiffBinaryStart.exec(line)) {
        possibleOldName = getFilename(values[1], void 0, config.dstPrefix);
        possibleNewName = getFilename(values[2], void 0, config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isBinary = true;
      return;
    }
    if (!currentFile || !currentFile.isGitDiff && currentFile && line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) && afterNxtLine.startsWith(hunkHeaderPrefix)) {
      startFile();
    }
    if (currentFile === null || currentFile === void 0 ? void 0 : currentFile.isTooBig) {
      return;
    }
    if (currentFile && (typeof config.diffMaxChanges === "number" && currentFile.addedLines + currentFile.deletedLines > config.diffMaxChanges || typeof config.diffMaxLineLength === "number" && line.length > config.diffMaxLineLength)) {
      currentFile.isTooBig = true;
      currentFile.addedLines = 0;
      currentFile.deletedLines = 0;
      currentFile.blocks = [];
      currentBlock = null;
      const message = typeof config.diffTooBigMessage === "function" ? config.diffTooBigMessage(files.length) : "Diff too big to be displayed";
      startBlock(message);
      return;
    }
    if (line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) || line.startsWith(newFileNameHeader) && prevLine.startsWith(oldFileNameHeader)) {
      if (currentFile && !currentFile.oldName && line.startsWith("--- ") && (values = getSrcFilename(line, config.srcPrefix))) {
        currentFile.oldName = values;
        currentFile.language = getExtension(currentFile.oldName, currentFile.language);
        return;
      }
      if (currentFile && !currentFile.newName && line.startsWith("+++ ") && (values = getDstFilename(line, config.dstPrefix))) {
        currentFile.newName = values;
        currentFile.language = getExtension(currentFile.newName, currentFile.language);
        return;
      }
    }
    if (currentFile && (line.startsWith(hunkHeaderPrefix) || currentFile.isGitDiff && currentFile.oldName && currentFile.newName && !currentBlock)) {
      startBlock(line);
      return;
    }
    if (currentBlock && (line.startsWith("+") || line.startsWith("-") || line.startsWith(" "))) {
      createLine(line);
      return;
    }
    const doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
    if (currentFile === null) {
      throw new Error("Where is my file !!!");
    }
    if (values = oldMode.exec(line)) {
      currentFile.oldMode = values[1];
    } else if (values = newMode.exec(line)) {
      currentFile.newMode = values[1];
    } else if (values = deletedFileMode.exec(line)) {
      currentFile.deletedFileMode = values[1];
      currentFile.isDeleted = true;
    } else if (values = newFileMode.exec(line)) {
      currentFile.newFileMode = values[1];
      currentFile.isNew = true;
    } else if (values = copyFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[1];
      }
      currentFile.isCopy = true;
    } else if (values = copyTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[1];
      }
      currentFile.isCopy = true;
    } else if (values = renameFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[1];
      }
      currentFile.isRename = true;
    } else if (values = renameTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[1];
      }
      currentFile.isRename = true;
    } else if (values = binaryFiles.exec(line)) {
      currentFile.isBinary = true;
      currentFile.oldName = getFilename(values[1], void 0, config.srcPrefix);
      currentFile.newName = getFilename(values[2], void 0, config.dstPrefix);
      startBlock("Binary file");
    } else if (binaryDiff.test(line)) {
      currentFile.isBinary = true;
      startBlock(line);
    } else if (values = similarityIndex.exec(line)) {
      currentFile.unchangedPercentage = parseInt(values[1], 10);
    } else if (values = dissimilarityIndex.exec(line)) {
      currentFile.changedPercentage = parseInt(values[1], 10);
    } else if (values = index.exec(line)) {
      currentFile.checksumBefore = values[1];
      currentFile.checksumAfter = values[2];
      if (values[3])
        currentFile.mode = values[3];
    } else if (values = combinedIndex.exec(line)) {
      currentFile.checksumBefore = [values[2], values[3]];
      currentFile.checksumAfter = values[1];
    } else if (values = combinedMode.exec(line)) {
      currentFile.oldMode = [values[2], values[3]];
      currentFile.newMode = values[1];
    } else if (values = combinedNewFile.exec(line)) {
      currentFile.newFileMode = values[1];
      currentFile.isNew = true;
    } else if (values = combinedDeletedFile.exec(line)) {
      currentFile.deletedFileMode = values[1];
      currentFile.isDeleted = true;
    }
  });
  saveBlock();
  saveFile();
  return files;
}

// node_modules/diff2html/node_modules/diff/lib/index.mjs
function Diff2() {
}
Diff2.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var self = this;
    function done(value2) {
      value2 = self.postProcess(value2, options);
      if (callback) {
        setTimeout(function() {
          callback(value2);
        }, 0);
        return true;
      } else {
        return value2;
      }
    }
    oldString = this.castInput(oldString, options);
    newString = this.castInput(newString, options);
    oldString = this.removeEmpty(this.tokenize(oldString, options));
    newString = this.removeEmpty(this.tokenize(newString, options));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = self.addToPath(removePath, false, true, 1, options);
        }
        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc, options) {
    var last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false
        };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array2) {
    var ret = [];
    for (var i2 = 0; i2 < array2.length; i2++) {
      if (array2[i2]) {
        ret.push(array2[i2]);
      }
    }
    return ret;
  },
  castInput: function castInput(value2) {
    return value2;
  },
  tokenize: function tokenize2(value2) {
    return Array.from(value2);
  },
  join: function join3(chars) {
    return chars.join("");
  },
  postProcess: function postProcess(changeObjects) {
    return changeObjects;
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value2 = newString.slice(newPos, newPos + component.count);
        value2 = value2.map(function(value3, i2) {
          var oldValue = oldString[oldPos + i2];
          return oldValue.length > value3.length ? oldValue : value3;
        });
        component.value = diff2.join(value2);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
    }
  }
  return components;
}
var characterDiff = new Diff2();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
function longestCommonPrefix(str1, str2) {
  var i2;
  for (i2 = 0; i2 < str1.length && i2 < str2.length; i2++) {
    if (str1[i2] != str2[i2]) {
      return str1.slice(0, i2);
    }
  }
  return str1.slice(0, i2);
}
function longestCommonSuffix(str1, str2) {
  var i2;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i2 = 0; i2 < str1.length && i2 < str2.length; i2++) {
    if (str1[str1.length - (i2 + 1)] != str2[str2.length - (i2 + 1)]) {
      return str1.slice(-i2);
    }
  }
  return str1.slice(-i2);
}
function replacePrefix(string2, oldPrefix, newPrefix) {
  if (string2.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error("string ".concat(JSON.stringify(string2), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  }
  return newPrefix + string2.slice(oldPrefix.length);
}
function replaceSuffix(string2, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string2 + newSuffix;
  }
  if (string2.slice(-oldSuffix.length) != oldSuffix) {
    throw Error("string ".concat(JSON.stringify(string2), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  }
  return string2.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string2, oldPrefix) {
  return replacePrefix(string2, oldPrefix, "");
}
function removeSuffix(string2, oldSuffix) {
  return replaceSuffix(string2, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a3, b) {
  var startA = 0;
  if (a3.length > b.length) {
    startA = a3.length - b.length;
  }
  var endB = b.length;
  if (a3.length < b.length) {
    endB = a3.length;
  }
  var map2 = Array(endB);
  var k = 0;
  map2[0] = 0;
  for (var j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map2[j] = map2[k];
    } else {
      map2[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map2[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (var i2 = startA; i2 < a3.length; i2++) {
    while (k > 0 && a3[i2] != b[k]) {
      k = map2[k];
    }
    if (a3[i2] == b[k]) {
      k++;
    }
  }
  return k;
}
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
var wordDiff = new Diff2();
wordDiff.equals = function(left, right, options) {
  if (options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function(value2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parts;
  if (options.intlSegmenter) {
    if (options.intlSegmenter.resolvedOptions().granularity != "word") {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options.intlSegmenter.segment(value2), function(segment) {
      return segment.segment;
    });
  } else {
    parts = value2.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function(part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function(tokens) {
  return tokens.map(function(token, i2) {
    if (i2 == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, "");
    }
  }).join("");
};
wordDiff.postProcess = function(changes, options) {
  if (!changes || options.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  var insertion = null;
  var deletion = null;
  changes.forEach(function(change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, "");
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, "");
    }
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0], delWsStart = deletion.value.match(/^\s*/)[0], delWsEnd = deletion.value.match(/\s*$/)[0];
    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
}
var wordWithSpaceDiff = new Diff2();
wordWithSpaceDiff.tokenize = function(value2) {
  var regex2 = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value2.match(regex2) || [];
};
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordWithSpaceDiff.diff(oldStr, newStr, options);
}
var lineDiff2 = new Diff2();
lineDiff2.tokenize = function(value2, options) {
  if (options.stripTrailingCr) {
    value2 = value2.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i2 = 0; i2 < linesAndNewlines.length; i2++) {
    var line = linesAndNewlines[i2];
    if (i2 % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
};
lineDiff2.equals = function(left, right, options) {
  if (options.ignoreWhitespace) {
    if (!options.newlineIsToken || !left.includes("\n")) {
      left = left.trim();
    }
    if (!options.newlineIsToken || !right.includes("\n")) {
      right = right.trim();
    }
  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
    if (left.endsWith("\n")) {
      left = left.slice(0, -1);
    }
    if (right.endsWith("\n")) {
      right = right.slice(0, -1);
    }
  }
  return Diff2.prototype.equals.call(this, left, right, options);
};
var sentenceDiff = new Diff2();
sentenceDiff.tokenize = function(value2) {
  return value2.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff2();
cssDiff.tokenize = function(value2) {
  return value2.split(/([{}:;,]|\s+)/);
};
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
var jsonDiff = new Diff2();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff2.tokenize;
jsonDiff.castInput = function(value2, options) {
  var undefinedReplacement = options.undefinedReplacement, _options$stringifyRep = options.stringifyReplacer, stringifyReplacer = _options$stringifyRep === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _options$stringifyRep;
  return typeof value2 === "string" ? value2 : JSON.stringify(canonicalize(value2, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right, options) {
  return Diff2.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
};
function canonicalize(obj, stack, replacementStack, replacer, key2) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key2, obj);
  }
  var i2;
  for (i2 = 0; i2 < stack.length; i2 += 1) {
    if (stack[i2] === obj) {
      return replacementStack[i2];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i2 = 0; i2 < obj.length; i2 += 1) {
      canonicalizedObj[i2] = canonicalize(obj[i2], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i2 = 0; i2 < sortedKeys.length; i2 += 1) {
      _key = sortedKeys[i2];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff2();
arrayDiff.tokenize = function(value2) {
  return value2.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value2) {
  return value2;
};

// node_modules/diff2html/lib-esm/rematch.js
function levenshtein(a3, b) {
  if (a3.length === 0) {
    return b.length;
  }
  if (b.length === 0) {
    return a3.length;
  }
  const matrix = [];
  let i2;
  for (i2 = 0; i2 <= b.length; i2++) {
    matrix[i2] = [i2];
  }
  let j;
  for (j = 0; j <= a3.length; j++) {
    matrix[0][j] = j;
  }
  for (i2 = 1; i2 <= b.length; i2++) {
    for (j = 1; j <= a3.length; j++) {
      if (b.charAt(i2 - 1) === a3.charAt(j - 1)) {
        matrix[i2][j] = matrix[i2 - 1][j - 1];
      } else {
        matrix[i2][j] = Math.min(matrix[i2 - 1][j - 1] + 1, Math.min(matrix[i2][j - 1] + 1, matrix[i2 - 1][j] + 1));
      }
    }
  }
  return matrix[b.length][a3.length];
}
function newDistanceFn(str) {
  return (x, y) => {
    const xValue = str(x).trim();
    const yValue = str(y).trim();
    const lev = levenshtein(xValue, yValue);
    return lev / (xValue.length + yValue.length);
  };
}
function newMatcherFn(distance2) {
  function findBestMatch(a3, b, cache = /* @__PURE__ */ new Map()) {
    let bestMatchDist = Infinity;
    let bestMatch;
    for (let i2 = 0; i2 < a3.length; ++i2) {
      for (let j = 0; j < b.length; ++j) {
        const cacheKey = JSON.stringify([a3[i2], b[j]]);
        let md;
        if (!(cache.has(cacheKey) && (md = cache.get(cacheKey)))) {
          md = distance2(a3[i2], b[j]);
          cache.set(cacheKey, md);
        }
        if (md < bestMatchDist) {
          bestMatchDist = md;
          bestMatch = { indexA: i2, indexB: j, score: bestMatchDist };
        }
      }
    }
    return bestMatch;
  }
  function group(a3, b, level = 0, cache = /* @__PURE__ */ new Map()) {
    const bm = findBestMatch(a3, b, cache);
    if (!bm || a3.length + b.length < 3) {
      return [[a3, b]];
    }
    const a1 = a3.slice(0, bm.indexA);
    const b1 = b.slice(0, bm.indexB);
    const aMatch = [a3[bm.indexA]];
    const bMatch = [b[bm.indexB]];
    const tailA = bm.indexA + 1;
    const tailB = bm.indexB + 1;
    const a22 = a3.slice(tailA);
    const b2 = b.slice(tailB);
    const group1 = group(a1, b1, level + 1, cache);
    const groupMatch = group(aMatch, bMatch, level + 1, cache);
    const group2 = group(a22, b2, level + 1, cache);
    let result = groupMatch;
    if (bm.indexA > 0 || bm.indexB > 0) {
      result = group1.concat(result);
    }
    if (a3.length > tailA || b.length > tailB) {
      result = result.concat(group2);
    }
    return result;
  }
  return group;
}

// node_modules/diff2html/lib-esm/render-utils.js
var CSSLineClass = {
  INSERTS: "d2h-ins",
  DELETES: "d2h-del",
  CONTEXT: "d2h-cntx",
  INFO: "d2h-info",
  INSERT_CHANGES: "d2h-ins d2h-change",
  DELETE_CHANGES: "d2h-del d2h-change"
};
var defaultRenderConfig = {
  matching: LineMatchingType.NONE,
  matchWordsThreshold: 0.25,
  maxLineLengthHighlight: 1e4,
  diffStyle: DiffStyleType.WORD,
  colorScheme: ColorSchemeType.LIGHT
};
var separator = "/";
var distance = newDistanceFn((change) => change.value);
var matcher = newMatcherFn(distance);
function isDevNullName(name2) {
  return name2.indexOf("dev/null") !== -1;
}
function removeInsElements(line) {
  return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, "");
}
function removeDelElements(line) {
  return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, "");
}
function toCSSClass(lineType) {
  switch (lineType) {
    case LineType.CONTEXT:
      return CSSLineClass.CONTEXT;
    case LineType.INSERT:
      return CSSLineClass.INSERTS;
    case LineType.DELETE:
      return CSSLineClass.DELETES;
  }
}
function colorSchemeToCss(colorScheme) {
  switch (colorScheme) {
    case ColorSchemeType.DARK:
      return "d2h-dark-color-scheme";
    case ColorSchemeType.AUTO:
      return "d2h-auto-color-scheme";
    case ColorSchemeType.LIGHT:
    default:
      return "d2h-light-color-scheme";
  }
}
function prefixLength(isCombined) {
  return isCombined ? 2 : 1;
}
function escapeForHtml(str) {
  return str.slice(0).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function deconstructLine(line, isCombined, escape = true) {
  const indexToSplit = prefixLength(isCombined);
  return {
    prefix: line.substring(0, indexToSplit),
    content: escape ? escapeForHtml(line.substring(indexToSplit)) : line.substring(indexToSplit)
  };
}
function filenameDiff(file) {
  const oldFilename = unifyPath(file.oldName);
  const newFilename = unifyPath(file.newName);
  if (oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
    const prefixPaths = [];
    const suffixPaths = [];
    const oldFilenameParts = oldFilename.split(separator);
    const newFilenameParts = newFilename.split(separator);
    const oldFilenamePartsSize = oldFilenameParts.length;
    const newFilenamePartsSize = newFilenameParts.length;
    let i2 = 0;
    let j = oldFilenamePartsSize - 1;
    let k = newFilenamePartsSize - 1;
    while (i2 < j && i2 < k) {
      if (oldFilenameParts[i2] === newFilenameParts[i2]) {
        prefixPaths.push(newFilenameParts[i2]);
        i2 += 1;
      } else {
        break;
      }
    }
    while (j > i2 && k > i2) {
      if (oldFilenameParts[j] === newFilenameParts[k]) {
        suffixPaths.unshift(newFilenameParts[k]);
        j -= 1;
        k -= 1;
      } else {
        break;
      }
    }
    const finalPrefix = prefixPaths.join(separator);
    const finalSuffix = suffixPaths.join(separator);
    const oldRemainingPath = oldFilenameParts.slice(i2, j + 1).join(separator);
    const newRemainingPath = newFilenameParts.slice(i2, k + 1).join(separator);
    if (finalPrefix.length && finalSuffix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}" + separator + finalSuffix;
    } else if (finalPrefix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}";
    } else if (finalSuffix.length) {
      return "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}" + separator + finalSuffix;
    }
    return oldFilename + " \u2192 " + newFilename;
  } else if (!isDevNullName(newFilename)) {
    return newFilename;
  } else {
    return oldFilename;
  }
}
function getHtmlId(file) {
  return `d2h-${hashCode(filenameDiff(file)).toString().slice(-6)}`;
}
function getFileIcon(file) {
  let templateName = "file-changed";
  if (file.isRename) {
    templateName = "file-renamed";
  } else if (file.isCopy) {
    templateName = "file-renamed";
  } else if (file.isNew) {
    templateName = "file-added";
  } else if (file.isDeleted) {
    templateName = "file-deleted";
  } else if (file.newName !== file.oldName) {
    templateName = "file-renamed";
  }
  return templateName;
}
function diffHighlight(diffLine1, diffLine2, isCombined, config = {}) {
  const { matching, maxLineLengthHighlight, matchWordsThreshold, diffStyle } = Object.assign(Object.assign({}, defaultRenderConfig), config);
  const line1 = deconstructLine(diffLine1, isCombined, false);
  const line2 = deconstructLine(diffLine2, isCombined, false);
  if (line1.content.length > maxLineLengthHighlight || line2.content.length > maxLineLengthHighlight) {
    return {
      oldLine: {
        prefix: line1.prefix,
        content: escapeForHtml(line1.content)
      },
      newLine: {
        prefix: line2.prefix,
        content: escapeForHtml(line2.content)
      }
    };
  }
  const diff2 = diffStyle === "char" ? diffChars(line1.content, line2.content) : diffWordsWithSpace(line1.content, line2.content);
  const changedWords = [];
  if (diffStyle === "word" && matching === "words") {
    const removed = diff2.filter((element) => element.removed);
    const added = diff2.filter((element) => element.added);
    const chunks = matcher(added, removed);
    chunks.forEach((chunk2) => {
      if (chunk2[0].length === 1 && chunk2[1].length === 1) {
        const dist = distance(chunk2[0][0], chunk2[1][0]);
        if (dist < matchWordsThreshold) {
          changedWords.push(chunk2[0][0]);
          changedWords.push(chunk2[1][0]);
        }
      }
    });
  }
  const highlightedLine = diff2.reduce((highlightedLine2, part) => {
    const elemType = part.added ? "ins" : part.removed ? "del" : null;
    const addClass = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : "";
    const escapedValue = escapeForHtml(part.value);
    return elemType !== null ? `${highlightedLine2}<${elemType}${addClass}>${escapedValue}</${elemType}>` : `${highlightedLine2}${escapedValue}`;
  }, "");
  return {
    oldLine: {
      prefix: line1.prefix,
      content: removeInsElements(highlightedLine)
    },
    newLine: {
      prefix: line2.prefix,
      content: removeDelElements(highlightedLine)
    }
  };
}

// node_modules/diff2html/lib-esm/file-list-renderer.js
var baseTemplatesPath = "file-summary";
var iconsBaseTemplatesPath = "icon";
var defaultFileListRendererConfig = {
  colorScheme: defaultRenderConfig.colorScheme
};
var FileListRenderer = class {
  constructor(hoganUtils, config = {}) {
    this.hoganUtils = hoganUtils;
    this.config = Object.assign(Object.assign({}, defaultFileListRendererConfig), config);
  }
  render(diffFiles) {
    const files = diffFiles.map((file) => this.hoganUtils.render(baseTemplatesPath, "line", {
      fileHtmlId: getHtmlId(file),
      oldName: file.oldName,
      newName: file.newName,
      fileName: filenameDiff(file),
      deletedLines: "-" + file.deletedLines,
      addedLines: "+" + file.addedLines
    }, {
      fileIcon: this.hoganUtils.template(iconsBaseTemplatesPath, getFileIcon(file))
    })).join("\n");
    return this.hoganUtils.render(baseTemplatesPath, "wrapper", {
      colorScheme: colorSchemeToCss(this.config.colorScheme),
      filesNumber: diffFiles.length,
      files
    });
  }
};

// node_modules/diff2html/lib-esm/line-by-line-renderer.js
var defaultLineByLineRendererConfig = Object.assign(Object.assign({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath = "generic";
var baseTemplatesPath2 = "line-by-line";
var iconsBaseTemplatesPath2 = "icon";
var tagsBaseTemplatesPath = "tag";
var LineByLineRenderer = class {
  constructor(hoganUtils, config = {}) {
    this.hoganUtils = hoganUtils;
    this.config = Object.assign(Object.assign({}, defaultLineByLineRendererConfig), config);
  }
  render(diffFiles) {
    const diffsHtml = diffFiles.map((file) => {
      let diffs;
      if (file.blocks.length) {
        diffs = this.generateFileHtml(file);
      } else {
        diffs = this.generateEmptyDiff();
      }
      return this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath, "wrapper", {
      colorScheme: colorSchemeToCss(this.config.colorScheme),
      content: diffsHtml
    });
  }
  makeFileDiffHtml(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
      return "";
    const fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath2, "file-diff");
    const filePathTemplate = this.hoganUtils.template(genericTemplatesPath, "file-path");
    const fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath2, "file");
    const fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  }
  generateEmptyDiff() {
    return this.hoganUtils.render(genericTemplatesPath, "empty-diff", {
      contentClass: "d2h-code-line",
      CSSLineClass
    });
  }
  generateFileHtml(file) {
    const matcher2 = newMatcherFn(newDistanceFn((e3) => deconstructLine(e3.content, file.isCombined).content));
    return file.blocks.map((block2) => {
      let lines = this.hoganUtils.render(genericTemplatesPath, "block-header", {
        CSSLineClass,
        blockHeader: file.isTooBig ? block2.header : escapeForHtml(block2.header),
        lineClass: "d2h-code-linenumber",
        contentClass: "d2h-code-line"
      });
      this.applyLineGroupping(block2).forEach(([contextLines, oldLines, newLines]) => {
        if (oldLines.length && newLines.length && !contextLines.length) {
          this.applyRematchMatching(oldLines, newLines, matcher2).map(([oldLines2, newLines2]) => {
            const { left, right } = this.processChangedLines(file, file.isCombined, oldLines2, newLines2);
            lines += left;
            lines += right;
          });
        } else if (contextLines.length) {
          contextLines.forEach((line) => {
            const { prefix, content } = deconstructLine(line.content, file.isCombined);
            lines += this.generateSingleLineHtml(file, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              oldNumber: line.oldNumber,
              newNumber: line.newNumber
            });
          });
        } else if (oldLines.length || newLines.length) {
          const { left, right } = this.processChangedLines(file, file.isCombined, oldLines, newLines);
          lines += left;
          lines += right;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return lines;
    }).join("\n");
  }
  applyLineGroupping(block2) {
    const blockLinesGroups = [];
    let oldLines = [];
    let newLines = [];
    for (let i2 = 0; i2 < block2.lines.length; i2++) {
      const diffLine = block2.lines[i2];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > 0) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === 0) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > 0) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  }
  applyRematchMatching(oldLines, newLines, matcher2) {
    const comparisons = oldLines.length * newLines.length;
    const maxLineSizeInBlock = max(oldLines.concat(newLines).map((elem) => elem.content.length));
    const doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher2(oldLines, newLines) : [[oldLines, newLines]];
  }
  processChangedLines(file, isCombined, oldLines, newLines) {
    const fileHtml = {
      right: "",
      left: ""
    };
    const maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (let i2 = 0; i2 < maxLinesNumber; i2++) {
      const oldLine = oldLines[i2];
      const newLine = newLines[i2];
      const diff2 = oldLine !== void 0 && newLine !== void 0 ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void 0;
      const preparedOldLine = oldLine !== void 0 && oldLine.oldNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.oldLine.prefix,
        content: diff2.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { oldNumber: oldLine.oldNumber, newNumber: oldLine.newNumber }) : void 0;
      const preparedNewLine = newLine !== void 0 && newLine.newNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.newLine.prefix,
        content: diff2.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { oldNumber: newLine.oldNumber, newNumber: newLine.newNumber }) : void 0;
      const { left, right } = this.generateLineHtml(file, preparedOldLine, preparedNewLine);
      fileHtml.left += left;
      fileHtml.right += right;
    }
    return fileHtml;
  }
  generateLineHtml(file, oldLine, newLine) {
    return {
      left: this.generateSingleLineHtml(file, oldLine),
      right: this.generateSingleLineHtml(file, newLine)
    };
  }
  generateSingleLineHtml(file, line) {
    if (line === void 0)
      return "";
    const lineNumberHtml = this.hoganUtils.render(baseTemplatesPath2, "numbers", {
      oldNumber: line.oldNumber || "",
      newNumber: line.newNumber || ""
    });
    return this.hoganUtils.render(genericTemplatesPath, "line", {
      type: line.type,
      lineClass: "d2h-code-linenumber",
      contentClass: "d2h-code-line",
      prefix: line.prefix === " " ? "&nbsp;" : line.prefix,
      content: line.content,
      lineNumber: lineNumberHtml,
      line,
      file
    });
  }
};

// node_modules/diff2html/lib-esm/side-by-side-renderer.js
var defaultSideBySideRendererConfig = Object.assign(Object.assign({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath2 = "generic";
var baseTemplatesPath3 = "side-by-side";
var iconsBaseTemplatesPath3 = "icon";
var tagsBaseTemplatesPath2 = "tag";
var SideBySideRenderer = class {
  constructor(hoganUtils, config = {}) {
    this.hoganUtils = hoganUtils;
    this.config = Object.assign(Object.assign({}, defaultSideBySideRendererConfig), config);
  }
  render(diffFiles) {
    const diffsHtml = diffFiles.map((file) => {
      let diffs;
      if (file.blocks.length) {
        diffs = this.generateFileHtml(file);
      } else {
        diffs = this.generateEmptyDiff();
      }
      return this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath2, "wrapper", {
      colorScheme: colorSchemeToCss(this.config.colorScheme),
      content: diffsHtml
    });
  }
  makeFileDiffHtml(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
      return "";
    const fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath3, "file-diff");
    const filePathTemplate = this.hoganUtils.template(genericTemplatesPath2, "file-path");
    const fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath3, "file");
    const fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath2, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  }
  generateEmptyDiff() {
    return {
      right: "",
      left: this.hoganUtils.render(genericTemplatesPath2, "empty-diff", {
        contentClass: "d2h-code-side-line",
        CSSLineClass
      })
    };
  }
  generateFileHtml(file) {
    const matcher2 = newMatcherFn(newDistanceFn((e3) => deconstructLine(e3.content, file.isCombined).content));
    return file.blocks.map((block2) => {
      const fileHtml = {
        left: this.makeHeaderHtml(block2.header, file),
        right: this.makeHeaderHtml("")
      };
      this.applyLineGroupping(block2).forEach(([contextLines, oldLines, newLines]) => {
        if (oldLines.length && newLines.length && !contextLines.length) {
          this.applyRematchMatching(oldLines, newLines, matcher2).map(([oldLines2, newLines2]) => {
            const { left, right } = this.processChangedLines(file.isCombined, oldLines2, newLines2);
            fileHtml.left += left;
            fileHtml.right += right;
          });
        } else if (contextLines.length) {
          contextLines.forEach((line) => {
            const { prefix, content } = deconstructLine(line.content, file.isCombined);
            const { left, right } = this.generateLineHtml({
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.oldNumber
            }, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.newNumber
            });
            fileHtml.left += left;
            fileHtml.right += right;
          });
        } else if (oldLines.length || newLines.length) {
          const { left, right } = this.processChangedLines(file.isCombined, oldLines, newLines);
          fileHtml.left += left;
          fileHtml.right += right;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return fileHtml;
    }).reduce((accomulated, html2) => {
      return { left: accomulated.left + html2.left, right: accomulated.right + html2.right };
    }, { left: "", right: "" });
  }
  applyLineGroupping(block2) {
    const blockLinesGroups = [];
    let oldLines = [];
    let newLines = [];
    for (let i2 = 0; i2 < block2.lines.length; i2++) {
      const diffLine = block2.lines[i2];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > 0) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === 0) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > 0) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  }
  applyRematchMatching(oldLines, newLines, matcher2) {
    const comparisons = oldLines.length * newLines.length;
    const maxLineSizeInBlock = max(oldLines.concat(newLines).map((elem) => elem.content.length));
    const doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher2(oldLines, newLines) : [[oldLines, newLines]];
  }
  makeHeaderHtml(blockHeader, file) {
    return this.hoganUtils.render(genericTemplatesPath2, "block-header", {
      CSSLineClass,
      blockHeader: (file === null || file === void 0 ? void 0 : file.isTooBig) ? blockHeader : escapeForHtml(blockHeader),
      lineClass: "d2h-code-side-linenumber",
      contentClass: "d2h-code-side-line"
    });
  }
  processChangedLines(isCombined, oldLines, newLines) {
    const fileHtml = {
      right: "",
      left: ""
    };
    const maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (let i2 = 0; i2 < maxLinesNumber; i2++) {
      const oldLine = oldLines[i2];
      const newLine = newLines[i2];
      const diff2 = oldLine !== void 0 && newLine !== void 0 ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void 0;
      const preparedOldLine = oldLine !== void 0 && oldLine.oldNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.oldLine.prefix,
        content: diff2.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { number: oldLine.oldNumber }) : void 0;
      const preparedNewLine = newLine !== void 0 && newLine.newNumber !== void 0 ? Object.assign(Object.assign({}, diff2 !== void 0 ? {
        prefix: diff2.newLine.prefix,
        content: diff2.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : Object.assign(Object.assign({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { number: newLine.newNumber }) : void 0;
      const { left, right } = this.generateLineHtml(preparedOldLine, preparedNewLine);
      fileHtml.left += left;
      fileHtml.right += right;
    }
    return fileHtml;
  }
  generateLineHtml(oldLine, newLine) {
    return {
      left: this.generateSingleHtml(oldLine),
      right: this.generateSingleHtml(newLine)
    };
  }
  generateSingleHtml(line) {
    const lineClass = "d2h-code-side-linenumber";
    const contentClass = "d2h-code-side-line";
    return this.hoganUtils.render(genericTemplatesPath2, "line", {
      type: (line === null || line === void 0 ? void 0 : line.type) || `${CSSLineClass.CONTEXT} d2h-emptyplaceholder`,
      lineClass: line !== void 0 ? lineClass : `${lineClass} d2h-code-side-emptyplaceholder`,
      contentClass: line !== void 0 ? contentClass : `${contentClass} d2h-code-side-emptyplaceholder`,
      prefix: (line === null || line === void 0 ? void 0 : line.prefix) === " " ? "&nbsp;" : line === null || line === void 0 ? void 0 : line.prefix,
      content: line === null || line === void 0 ? void 0 : line.content,
      lineNumber: line === null || line === void 0 ? void 0 : line.number
    });
  }
};

// node_modules/diff2html/lib-esm/hoganjs-utils.js
var Hogan3 = __toESM(require_hogan());

// node_modules/diff2html/lib-esm/diff2html-templates.js
var Hogan2 = __toESM(require_hogan());
var defaultTemplates = {};
defaultTemplates["file-summary-line"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<li class="d2h-file-list-line">');
  t3.b("\n" + i2);
  t3.b('    <span class="d2h-file-name-wrapper">');
  t3.b("\n" + i2);
  t3.b(t3.rp("<fileIcon0", c, p, "      "));
  t3.b('      <a href="#');
  t3.b(t3.v(t3.f("fileHtmlId", c, p, 0)));
  t3.b('" class="d2h-file-name">');
  t3.b(t3.v(t3.f("fileName", c, p, 0)));
  t3.b("</a>");
  t3.b("\n" + i2);
  t3.b('      <span class="d2h-file-stats">');
  t3.b("\n" + i2);
  t3.b('          <span class="d2h-lines-added">');
  t3.b(t3.v(t3.f("addedLines", c, p, 0)));
  t3.b("</span>");
  t3.b("\n" + i2);
  t3.b('          <span class="d2h-lines-deleted">');
  t3.b(t3.v(t3.f("deletedLines", c, p, 0)));
  t3.b("</span>");
  t3.b("\n" + i2);
  t3.b("      </span>");
  t3.b("\n" + i2);
  t3.b("    </span>");
  t3.b("\n" + i2);
  t3.b("</li>");
  return t3.fl();
}, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["file-summary-wrapper"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<div class="d2h-file-list-wrapper ');
  t3.b(t3.v(t3.f("colorScheme", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b('    <div class="d2h-file-list-header">');
  t3.b("\n" + i2);
  t3.b('        <span class="d2h-file-list-title">Files changed (');
  t3.b(t3.v(t3.f("filesNumber", c, p, 0)));
  t3.b(")</span>");
  t3.b("\n" + i2);
  t3.b('        <a class="d2h-file-switch d2h-hide">hide</a>');
  t3.b("\n" + i2);
  t3.b('        <a class="d2h-file-switch d2h-show">show</a>');
  t3.b("\n" + i2);
  t3.b("    </div>");
  t3.b("\n" + i2);
  t3.b('    <ol class="d2h-file-list">');
  t3.b("\n" + i2);
  t3.b("    ");
  t3.b(t3.t(t3.f("files", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("    </ol>");
  t3.b("\n" + i2);
  t3.b("</div>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-block-header"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b("<tr>");
  t3.b("\n" + i2);
  t3.b('    <td class="');
  t3.b(t3.v(t3.f("lineClass", c, p, 0)));
  t3.b(" ");
  t3.b(t3.v(t3.d("CSSLineClass.INFO", c, p, 0)));
  t3.b('"></td>');
  t3.b("\n" + i2);
  t3.b('    <td class="');
  t3.b(t3.v(t3.d("CSSLineClass.INFO", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b('        <div class="');
  t3.b(t3.v(t3.f("contentClass", c, p, 0)));
  t3.b('">');
  if (t3.s(t3.f("blockHeader", c, p, 1), c, p, 0, 156, 173, "{{ }}")) {
    t3.rs(c, p, function(c2, p2, t4) {
      t4.b(t4.t(t4.f("blockHeader", c2, p2, 0)));
    });
    c.pop();
  }
  if (!t3.s(t3.f("blockHeader", c, p, 1), c, p, 1, 0, 0, "")) {
    t3.b("&nbsp;");
  }
  ;
  t3.b("</div>");
  t3.b("\n" + i2);
  t3.b("    </td>");
  t3.b("\n" + i2);
  t3.b("</tr>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-empty-diff"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b("<tr>");
  t3.b("\n" + i2);
  t3.b('    <td class="');
  t3.b(t3.v(t3.d("CSSLineClass.INFO", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b('        <div class="');
  t3.b(t3.v(t3.f("contentClass", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b("            File without changes");
  t3.b("\n" + i2);
  t3.b("        </div>");
  t3.b("\n" + i2);
  t3.b("    </td>");
  t3.b("\n" + i2);
  t3.b("</tr>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-file-path"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<span class="d2h-file-name-wrapper">');
  t3.b("\n" + i2);
  t3.b(t3.rp("<fileIcon0", c, p, "    "));
  t3.b('    <span class="d2h-file-name">');
  t3.b(t3.v(t3.f("fileDiffName", c, p, 0)));
  t3.b("</span>");
  t3.b("\n" + i2);
  t3.b(t3.rp("<fileTag1", c, p, "    "));
  t3.b("</span>");
  t3.b("\n" + i2);
  t3.b('<label class="d2h-file-collapse">');
  t3.b("\n" + i2);
  t3.b('    <input class="d2h-file-collapse-input" type="checkbox" name="viewed" value="viewed">');
  t3.b("\n" + i2);
  t3.b("    Viewed");
  t3.b("\n" + i2);
  t3.b("</label>");
  return t3.fl();
}, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} }, "<fileTag1": { name: "fileTag", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["generic-line"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b("<tr>");
  t3.b("\n" + i2);
  t3.b('    <td class="');
  t3.b(t3.v(t3.f("lineClass", c, p, 0)));
  t3.b(" ");
  t3.b(t3.v(t3.f("type", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b("      ");
  t3.b(t3.t(t3.f("lineNumber", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("    </td>");
  t3.b("\n" + i2);
  t3.b('    <td class="');
  t3.b(t3.v(t3.f("type", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b('        <div class="');
  t3.b(t3.v(t3.f("contentClass", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  if (t3.s(t3.f("prefix", c, p, 1), c, p, 0, 162, 238, "{{ }}")) {
    t3.rs(c, p, function(c2, p2, t4) {
      t4.b('            <span class="d2h-code-line-prefix">');
      t4.b(t4.t(t4.f("prefix", c2, p2, 0)));
      t4.b("</span>");
      t4.b("\n" + i2);
    });
    c.pop();
  }
  if (!t3.s(t3.f("prefix", c, p, 1), c, p, 1, 0, 0, "")) {
    t3.b('            <span class="d2h-code-line-prefix">&nbsp;</span>');
    t3.b("\n" + i2);
  }
  ;
  if (t3.s(t3.f("content", c, p, 1), c, p, 0, 371, 445, "{{ }}")) {
    t3.rs(c, p, function(c2, p2, t4) {
      t4.b('            <span class="d2h-code-line-ctn">');
      t4.b(t4.t(t4.f("content", c2, p2, 0)));
      t4.b("</span>");
      t4.b("\n" + i2);
    });
    c.pop();
  }
  if (!t3.s(t3.f("content", c, p, 1), c, p, 1, 0, 0, "")) {
    t3.b('            <span class="d2h-code-line-ctn"><br></span>');
    t3.b("\n" + i2);
  }
  ;
  t3.b("        </div>");
  t3.b("\n" + i2);
  t3.b("    </td>");
  t3.b("\n" + i2);
  t3.b("</tr>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-wrapper"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<div class="d2h-wrapper ');
  t3.b(t3.v(t3.f("colorScheme", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b("    ");
  t3.b(t3.t(t3.f("content", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("</div>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-added"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<svg aria-hidden="true" class="d2h-icon d2h-added" height="16" title="added" version="1.1" viewBox="0 0 14 16"');
  t3.b("\n" + i2);
  t3.b('     width="14">');
  t3.b("\n" + i2);
  t3.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z"></path>');
  t3.b("\n" + i2);
  t3.b("</svg>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-changed"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<svg aria-hidden="true" class="d2h-icon d2h-changed" height="16" title="modified" version="1.1"');
  t3.b("\n" + i2);
  t3.b('     viewBox="0 0 14 16" width="14">');
  t3.b("\n" + i2);
  t3.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z"></path>');
  t3.b("\n" + i2);
  t3.b("</svg>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-deleted"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<svg aria-hidden="true" class="d2h-icon d2h-deleted" height="16" title="removed" version="1.1"');
  t3.b("\n" + i2);
  t3.b('     viewBox="0 0 14 16" width="14">');
  t3.b("\n" + i2);
  t3.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM11 9H3V7h8v2z"></path>');
  t3.b("\n" + i2);
  t3.b("</svg>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-renamed"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<svg aria-hidden="true" class="d2h-icon d2h-moved" height="16" title="renamed" version="1.1"');
  t3.b("\n" + i2);
  t3.b('     viewBox="0 0 14 16" width="14">');
  t3.b("\n" + i2);
  t3.b('    <path d="M6 9H3V7h3V4l5 4-5 4V9z m8-7v12c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h12c0.55 0 1 0.45 1 1z m-1 0H1v12h12V2z"></path>');
  t3.b("\n" + i2);
  t3.b("</svg>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<svg aria-hidden="true" class="d2h-icon" height="16" version="1.1" viewBox="0 0 12 16" width="12">');
  t3.b("\n" + i2);
  t3.b('    <path d="M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z"></path>');
  t3.b("\n" + i2);
  t3.b("</svg>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-file-diff"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<div id="');
  t3.b(t3.v(t3.f("fileHtmlId", c, p, 0)));
  t3.b('" class="d2h-file-wrapper" data-lang="');
  t3.b(t3.v(t3.d("file.language", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b('    <div class="d2h-file-header">');
  t3.b("\n" + i2);
  t3.b("    ");
  t3.b(t3.t(t3.f("filePath", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("    </div>");
  t3.b("\n" + i2);
  t3.b('    <div class="d2h-file-diff">');
  t3.b("\n" + i2);
  t3.b('        <div class="d2h-code-wrapper">');
  t3.b("\n" + i2);
  t3.b('            <table class="d2h-diff-table">');
  t3.b("\n" + i2);
  t3.b('                <tbody class="d2h-diff-tbody">');
  t3.b("\n" + i2);
  t3.b("                ");
  t3.b(t3.t(t3.f("diffs", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("                </tbody>");
  t3.b("\n" + i2);
  t3.b("            </table>");
  t3.b("\n" + i2);
  t3.b("        </div>");
  t3.b("\n" + i2);
  t3.b("    </div>");
  t3.b("\n" + i2);
  t3.b("</div>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-numbers"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<div class="line-num1">');
  t3.b(t3.v(t3.f("oldNumber", c, p, 0)));
  t3.b("</div>");
  t3.b("\n" + i2);
  t3.b('<div class="line-num2">');
  t3.b(t3.v(t3.f("newNumber", c, p, 0)));
  t3.b("</div>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["side-by-side-file-diff"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<div id="');
  t3.b(t3.v(t3.f("fileHtmlId", c, p, 0)));
  t3.b('" class="d2h-file-wrapper" data-lang="');
  t3.b(t3.v(t3.d("file.language", c, p, 0)));
  t3.b('">');
  t3.b("\n" + i2);
  t3.b('    <div class="d2h-file-header">');
  t3.b("\n" + i2);
  t3.b("      ");
  t3.b(t3.t(t3.f("filePath", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("    </div>");
  t3.b("\n" + i2);
  t3.b('    <div class="d2h-files-diff">');
  t3.b("\n" + i2);
  t3.b('        <div class="d2h-file-side-diff">');
  t3.b("\n" + i2);
  t3.b('            <div class="d2h-code-wrapper">');
  t3.b("\n" + i2);
  t3.b('                <table class="d2h-diff-table">');
  t3.b("\n" + i2);
  t3.b('                    <tbody class="d2h-diff-tbody">');
  t3.b("\n" + i2);
  t3.b("                    ");
  t3.b(t3.t(t3.d("diffs.left", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("                    </tbody>");
  t3.b("\n" + i2);
  t3.b("                </table>");
  t3.b("\n" + i2);
  t3.b("            </div>");
  t3.b("\n" + i2);
  t3.b("        </div>");
  t3.b("\n" + i2);
  t3.b('        <div class="d2h-file-side-diff">');
  t3.b("\n" + i2);
  t3.b('            <div class="d2h-code-wrapper">');
  t3.b("\n" + i2);
  t3.b('                <table class="d2h-diff-table">');
  t3.b("\n" + i2);
  t3.b('                    <tbody class="d2h-diff-tbody">');
  t3.b("\n" + i2);
  t3.b("                    ");
  t3.b(t3.t(t3.d("diffs.right", c, p, 0)));
  t3.b("\n" + i2);
  t3.b("                    </tbody>");
  t3.b("\n" + i2);
  t3.b("                </table>");
  t3.b("\n" + i2);
  t3.b("            </div>");
  t3.b("\n" + i2);
  t3.b("        </div>");
  t3.b("\n" + i2);
  t3.b("    </div>");
  t3.b("\n" + i2);
  t3.b("</div>");
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-added"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<span class="d2h-tag d2h-added d2h-added-tag">ADDED</span>');
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-changed"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<span class="d2h-tag d2h-changed d2h-changed-tag">CHANGED</span>');
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-deleted"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<span class="d2h-tag d2h-deleted d2h-deleted-tag">DELETED</span>');
  return t3.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-renamed"] = new Hogan2.Template({ code: function(c, p, i2) {
  var t3 = this;
  t3.b(i2 = i2 || "");
  t3.b('<span class="d2h-tag d2h-moved d2h-moved-tag">RENAMED</span>');
  return t3.fl();
}, partials: {}, subs: {} });

// node_modules/diff2html/lib-esm/hoganjs-utils.js
var HoganJsUtils = class {
  constructor({ compiledTemplates = {}, rawTemplates = {} }) {
    const compiledRawTemplates = Object.entries(rawTemplates).reduce((previousTemplates, [name2, templateString]) => {
      const compiledTemplate = Hogan3.compile(templateString, { asString: false });
      return Object.assign(Object.assign({}, previousTemplates), { [name2]: compiledTemplate });
    }, {});
    this.preCompiledTemplates = Object.assign(Object.assign(Object.assign({}, defaultTemplates), compiledTemplates), compiledRawTemplates);
  }
  static compile(templateString) {
    return Hogan3.compile(templateString, { asString: false });
  }
  render(namespace, view, params, partials, indent2) {
    const templateKey = this.templateKey(namespace, view);
    try {
      const template = this.preCompiledTemplates[templateKey];
      return template.render(params, partials, indent2);
    } catch (_e) {
      throw new Error(`Could not find template to render '${templateKey}'`);
    }
  }
  template(namespace, view) {
    return this.preCompiledTemplates[this.templateKey(namespace, view)];
  }
  templateKey(namespace, view) {
    return `${namespace}-${view}`;
  }
};

// node_modules/diff2html/lib-esm/diff2html.js
var defaultDiff2HtmlConfig = Object.assign(Object.assign(Object.assign({}, defaultLineByLineRendererConfig), defaultSideBySideRendererConfig), { outputFormat: OutputFormatType.LINE_BY_LINE, drawFileList: true });
function html(diffInput, configuration = {}) {
  const config = Object.assign(Object.assign({}, defaultDiff2HtmlConfig), configuration);
  const diffJson = typeof diffInput === "string" ? parse4(diffInput, config) : diffInput;
  const hoganUtils = new HoganJsUtils(config);
  const { colorScheme } = config;
  const fileListRendererConfig = { colorScheme };
  const fileList = config.drawFileList ? new FileListRenderer(hoganUtils, fileListRendererConfig).render(diffJson) : "";
  const diffOutput = config.outputFormat === "side-by-side" ? new SideBySideRenderer(hoganUtils, config).render(diffJson) : new LineByLineRenderer(hoganUtils, config).render(diffJson);
  return fileList + diffOutput;
}

// src/components/modal.ts
var VaultSyncModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.title = title;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title, cls: "vault-bridge-modal-title" });
    contentEl.createEl("div", {
      text: this.message,
      cls: "vault-bridge-modal-content"
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("\u786E\u8BA4").setCta().onClick(() => this.close());
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm, onCancel) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title, cls: "vault-bridge-modal-title" });
    contentEl.createEl("div", {
      text: this.message,
      cls: "vault-bridge-modal-content"
    });
    const buttonContainer = contentEl.createDiv("vault-bridge-button-container");
    const confirmButton = buttonContainer.createEl("button", {
      text: "\u786E\u8BA4",
      cls: "vault-bridge-button vault-bridge-confirm-button"
    });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
    if (this.onCancel) {
      const cancelButton = buttonContainer.createEl("button", {
        text: "\u53D6\u6D88",
        cls: "vault-bridge-button vault-bridge-cancel-button"
      });
      cancelButton.addEventListener("click", () => {
        if (this.onCancel)
          this.onCancel();
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ProgressModal = class extends import_obsidian.Modal {
  constructor(app, title, initialMessage = "") {
    super(app);
    this.title = title;
    this.message = initialMessage;
    this.progress = 0;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", {
      text: this.title,
      cls: "vault-bridge-modal-title"
    });
    const progressContainer = contentEl.createDiv("vault-bridge-progress-container");
    const progressBar = progressContainer.createDiv("vault-bridge-progress-bar");
    progressBar.style.width = `${this.progress}%`;
    const progressText = progressContainer.createDiv("vault-bridge-progress-text");
    progressText.textContent = `${this.progress}%`;
    const messageEl = contentEl.createDiv("vault-bridge-modal-content");
    messageEl.textContent = this.message;
    this.progressBar = progressBar;
    this.progressText = progressText;
    this.messageEl = messageEl;
  }
  updateProgress(progress) {
    this.progress = Math.min(100, Math.max(0, progress));
    if (this.progressBar && this.progressText) {
      this.progressBar.style.width = `${this.progress}%`;
      this.progressText.textContent = `${this.progress}%`;
    }
  }
  updateMessage(message) {
    this.message = message;
    if (this.messageEl) {
      this.messageEl.textContent = message;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DiffModal = class extends import_obsidian.Modal {
  constructor(app, fileName, oldContent, newContent, onConfirm, onCancel) {
    super(app);
    this.isEditMode = false;
    this.fileName = fileName;
    this.oldContent = oldContent;
    this.newContent = newContent;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("vault-bridge-diff-modal");
    contentEl.createEl("h2", {
      text: `\u6587\u4EF6\u5DEE\u5F02: ${this.fileName}`,
      cls: "vault-bridge-modal-title"
    });
    const diffPatch = createPatch(
      this.fileName,
      this.oldContent,
      this.newContent,
      "\u672C\u5730\u7248\u672C",
      "\u94FE\u4E0A\u7248\u672C"
    );
    const diffHtml = html(diffPatch, {
      drawFileList: false,
      matching: "lines",
      outputFormat: "side-by-side"
    });
    this.diffContainer = contentEl.createDiv("vault-bridge-diff-container");
    this.diffContainer.innerHTML = diffHtml;
    this.editContainer = contentEl.createDiv("vault-bridge-edit-container");
    this.editContainer.style.display = "none";
    const editInfo = this.editContainer.createDiv("vault-bridge-edit-info");
    editInfo.createEl("p", {
      text: '\u60A8\u53EF\u4EE5\u624B\u52A8\u7F16\u8F91\u5185\u5BB9\u6765\u89E3\u51B3\u51B2\u7A81\u3002\u7F16\u8F91\u5B8C\u6210\u540E\u70B9\u51FB"\u4FDD\u5B58\u7F16\u8F91"\u6309\u94AE\u3002',
      cls: "vault-bridge-edit-info-text"
    });
    this.editTextarea = this.editContainer.createEl("textarea", {
      cls: "vault-bridge-edit-textarea"
    });
    this.editTextarea.value = this.oldContent;
    this.editTextarea.rows = 20;
    const quickActionContainer = this.editContainer.createDiv("vault-bridge-quick-actions");
    const useLocalBtn = quickActionContainer.createEl("button", {
      text: "\u4F7F\u7528\u672C\u5730\u7248\u672C",
      cls: "vault-bridge-quick-action-button"
    });
    useLocalBtn.addEventListener("click", () => {
      this.editTextarea.value = this.oldContent;
    });
    const useRemoteBtn = quickActionContainer.createEl("button", {
      text: "\u4F7F\u7528\u94FE\u4E0A\u7248\u672C",
      cls: "vault-bridge-quick-action-button"
    });
    useRemoteBtn.addEventListener("click", () => {
      this.editTextarea.value = this.newContent;
    });
    const infoEl = contentEl.createDiv("vault-bridge-diff-info");
    infoEl.createEl("p", {
      text: "\u5DE6\u4FA7\u4E3A\u672C\u5730\u7248\u672C\uFF0C\u53F3\u4FA7\u4E3A\u94FE\u4E0A\u7248\u672C\u3002",
      cls: "vault-bridge-diff-info-text"
    });
    const buttonContainer = contentEl.createDiv("vault-bridge-button-container");
    const updateButton = buttonContainer.createEl("button", {
      text: "\u4F7F\u7528\u94FE\u4E0A\u7248\u672C",
      cls: "vault-bridge-button vault-bridge-confirm-button"
    });
    updateButton.addEventListener("click", () => {
      this.onConfirm(this.newContent);
      this.close();
    });
    const keepLocalButton = buttonContainer.createEl("button", {
      text: "\u4FDD\u6301\u672C\u5730\u7248\u672C",
      cls: "vault-bridge-button"
    });
    keepLocalButton.addEventListener("click", () => {
      this.onCancel();
      this.close();
    });
    const editButton = buttonContainer.createEl("button", {
      text: "\u624B\u52A8\u7F16\u8F91",
      cls: "vault-bridge-button vault-bridge-edit-button"
    });
    editButton.addEventListener("click", () => {
      this.toggleEditMode();
    });
    const saveEditButton = buttonContainer.createEl("button", {
      text: "\u4FDD\u5B58\u7F16\u8F91",
      cls: "vault-bridge-button vault-bridge-save-edit-button"
    });
    saveEditButton.style.display = "none";
    saveEditButton.addEventListener("click", () => {
      const editedContent = this.editTextarea.value;
      this.onConfirm(editedContent);
      this.close();
    });
    const cancelEditButton = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88\u7F16\u8F91",
      cls: "vault-bridge-button vault-bridge-cancel-button"
    });
    cancelEditButton.style.display = "none";
    cancelEditButton.addEventListener("click", () => {
      this.toggleEditMode();
    });
    editButton.saveEditButton = saveEditButton;
    editButton.cancelEditButton = cancelEditButton;
    editButton.updateButton = updateButton;
    editButton.keepLocalButton = keepLocalButton;
  }
  toggleEditMode() {
    this.isEditMode = !this.isEditMode;
    const editButton = this.contentEl.querySelector(".vault-bridge-edit-button");
    const saveEditButton = editButton.saveEditButton;
    const cancelEditButton = editButton.cancelEditButton;
    const updateButton = editButton.updateButton;
    const keepLocalButton = editButton.keepLocalButton;
    if (this.isEditMode) {
      this.diffContainer.style.display = "none";
      this.editContainer.style.display = "block";
      editButton.style.display = "none";
      updateButton.style.display = "none";
      keepLocalButton.style.display = "none";
      saveEditButton.style.display = "inline-block";
      cancelEditButton.style.display = "inline-block";
    } else {
      this.diffContainer.style.display = "block";
      this.editContainer.style.display = "none";
      editButton.style.display = "inline-block";
      updateButton.style.display = "inline-block";
      keepLocalButton.style.display = "inline-block";
      saveEditButton.style.display = "none";
      cancelEditButton.style.display = "none";
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/vault-sync.ts
async function initVault(vaultName, wallet) {
  const address = wallet.getAddress();
  let vault = await getVaultByAddress(address, vaultName);
  console.log("\u521D\u59CB\u5316vault:", vault);
  if (!vault) {
    const tx = new Transaction();
    tx.setSender(address);
    tx.setGasBudget(1e7);
    const rootDir = tx.moveCall({
      package: PACKAGE_ID,
      module: "perlite_sync",
      function: "new_root_directory",
      arguments: [tx.pure.string(vaultName), tx.object("0x6")]
    });
    tx.moveCall({
      package: PACKAGE_ID,
      module: "perlite_sync",
      function: "transfer_dir",
      arguments: [tx.object(rootDir), tx.pure.address(address)]
    });
    const suiClient = new SuiJsonRpcClient({ url: getFullnodeUrl(NET_WORK) });
    try {
      let txBytes = await tx.build({ client: suiClient });
      let signature = await wallet.signTransaction(txBytes);
      let txResult = await suiClient.executeTransactionBlock({
        transactionBlock: txBytes,
        signature
      });
      console.log("\u4EA4\u6613\u7ED3\u679C:", txResult);
    } catch (e3) {
      console.log("\u4EA4\u6613\u6784\u5EFA\u9519\u8BEF:", e3);
    }
    vault = await getVaultByAddress(address, vaultName);
    if (!vault) {
      return await getVaultByAddress(address, vaultName);
    }
  }
  return vault;
}
async function pushToChain(vault, vaultLocalPath, allMarkdownFiles, wallet, epoch, notifyProgress, app) {
  console.log("\u63A8\u9001vault", vault.name, vaultLocalPath);
  let address = wallet.getAddress();
  if (vault) {
    let vaultId = vault.id;
    let map2 = flattenVaultFilesOptimized(vault);
    console.log("vaultMap", map2);
    let newDirMap = /* @__PURE__ */ new Map();
    let waitTransferDirs = [];
    let waitTransferFiles = [];
    let tx = new Transaction();
    tx.setSender(address);
    let props = {
      vaultId,
      moduleName: "perlite_sync",
      wallet,
      packageId: PACKAGE_ID
    };
    const { handleSubmit } = SealUtil(props);
    for (let j = 0; j < allMarkdownFiles.length; j++) {
      let file = allMarkdownFiles[j];
      if (map2.has(file.path)) {
        console.log("\u6587\u4EF6\u5DF2\u5B58\u5728:", file.path);
      } else {
        let currFilePathSplit = file.path.split("/");
        let tempPath = "";
        console.log("\u6587\u4EF6\u8DEF\u5F84\u5206\u5272:", currFilePathSplit);
        let parentObjMap = /* @__PURE__ */ new Map();
        parentObjMap.set(currFilePathSplit[0], vaultId);
        for (let i2 = 0; i2 < currFilePathSplit.length - 1; i2++) {
          let currDir = currFilePathSplit[i2];
          if (tempPath == "") {
            tempPath = currDir;
          } else {
            tempPath = tempPath + "/" + currDir;
          }
          if (newDirMap.has(tempPath)) {
            parentObjMap.set(tempPath + "/" + currFilePathSplit[i2 + 1], newDirMap.get(tempPath));
            continue;
          }
          let parent = parentObjMap.get(tempPath);
          notifyProgress(`\u5904\u7406\u76EE\u5F55: ${tempPath}`);
          let par = tx.moveCall({
            package: PACKAGE_ID,
            module: "perlite_sync",
            function: "new_directory",
            arguments: [tx.pure.string(currDir), tx.object(parent), tx.object("0x6")]
          });
          newDirMap.set(tempPath, par);
          parentObjMap.set(tempPath + "/" + currFilePathSplit[i2 + 1], par);
          waitTransferDirs.push(par);
        }
        const fs = require("fs");
        const path = require("path");
        const sourcePath = path.join(vaultLocalPath, file.path);
        let parent_dir = parentObjMap.get(file.path);
        const data = fs.readFileSync(sourcePath);
        const fileName = path.basename(sourcePath);
        console.log("\u6587\u4EF6\u540D:", fileName);
        notifyProgress(`\u5904\u7406\u6587\u4EF6: ${fileName}`);
        const result = await handleSubmit(new File([data], fileName, {
          type: "text/plain",
          lastModified: Date.now()
        }), epoch);
        if (result) {
          notifyProgress(`\u6587\u4EF6: ${fileName} \u5DF2\u4FDD\u5B58\u81F3Walrus`);
          let fileResult = tx.moveCall({
            target: PACKAGE_ID + "::perlite_sync::new_file",
            arguments: [tx.pure.string(fileName), tx.pure.string(result.blobId), tx.pure.u64(result.endEpoch), tx.object(parent_dir), tx.object("0x6")]
          });
          waitTransferFiles.push(fileResult);
        }
      }
    }
    waitTransferDirs.forEach((dir) => {
      tx.moveCall({
        package: PACKAGE_ID,
        module: "perlite_sync",
        function: "transfer_dir",
        arguments: [tx.object(dir), tx.pure.address(address)]
      });
    });
    waitTransferFiles.forEach((file) => {
      tx.moveCall({
        package: PACKAGE_ID,
        module: "perlite_sync",
        function: "transfer_file",
        arguments: [tx.object(file), tx.pure.address(address)]
      });
    });
    notifyProgress("\u6B63\u5728\u540C\u6B65\u6570\u636E\u81F3\u94FE\u4E0A\uFF0C\u8BF7\u7A0D\u540E...");
    const suiClient = new SuiJsonRpcClient({ url: getFullnodeUrl(NET_WORK) });
    try {
      let txBytes = await tx.build({ client: suiClient });
      let signature = await wallet.signTransaction(txBytes);
      let txResult = await suiClient.executeTransactionBlock({
        transactionBlock: txBytes,
        signature
      });
      const confirmModal = new VaultSyncModal(
        app,
        "\u540C\u6B65\u6570\u636E\u6210\u529F",
        `\u6570\u636E\u5DF2\u6210\u529F\u540C\u6B65\u81F3\u94FE\u4E0A
\u4EA4\u6613ID: ${txResult.digest}`
      );
      confirmModal.open();
    } catch (e3) {
      notifyProgress("\u53D1\u5E03\u6570\u636E\u4E0A\u94FE\u5F02\u5E38\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u83B7\u53D6\u8BE6\u60C5");
      console.log("\u4EA4\u6613\u6784\u5EFA\u9519\u8BEF:", e3);
      throw e3;
    }
    console.log("\u63A8\u9001\u5B8C\u6210");
  }
}
async function pullFromChain(vault, vaultLocalPath, allMarkdownFiles, wallet, adapter, app) {
  const vaultId = vault.id;
  const props = {
    vaultId,
    moduleName: "perlite_sync",
    wallet,
    packageId: PACKAGE_ID
  };
  const { downloadFile, downloadFileContent } = SealUtil(props);
  const stack = [];
  stack.push({ dir: vault, visited: false });
  const path_join = [];
  while (stack.length > 0) {
    const entry = stack.pop();
    const currVault = entry?.dir;
    if (currVault) {
      if (!entry?.visited) {
        if (currVault !== vault) {
          path_join.push(currVault.name);
        }
        const cur_dir_path = [...path_join].join("/");
        const dir_exists = await adapter.exists(cur_dir_path, true);
        if (!dir_exists) {
          await adapter.mkdir(cur_dir_path);
        }
        for (const file of currVault.files) {
          const cur_path = [...path_join, file.title].join("/");
          const exists = await adapter.exists(cur_path, true);
          if (!exists) {
            console.log("\u4E0B\u8F7D\u65B0\u6587\u4EF6", file.title);
            await downloadFile(file, cur_path, adapter);
          } else {
            console.log("\u68C0\u67E5\u6587\u4EF6\u5DEE\u5F02", file.title);
            const localContent = await adapter.read(cur_path);
            const remoteContent = await downloadFileContent(file);
            if (localContent !== remoteContent) {
              console.log("\u6587\u4EF6\u5185\u5BB9\u4E0D\u540C\uFF0C\u663E\u793A\u5DEE\u5F02", file.title);
              if (app) {
                await new Promise((resolve) => {
                  const diffModal = new DiffModal(
                    app,
                    file.title,
                    localContent,
                    remoteContent,
                    async (content) => {
                      const finalContent = content || remoteContent;
                      console.log("\u7528\u6237\u9009\u62E9\u66F4\u65B0\u6587\u4EF6", file.title);
                      await adapter.write(cur_path, finalContent);
                      resolve();
                    },
                    () => {
                      console.log("\u7528\u6237\u9009\u62E9\u8DF3\u8FC7\u6587\u4EF6", file.title);
                      resolve();
                    }
                  );
                  diffModal.open();
                });
              } else {
                await adapter.write(cur_path, remoteContent);
              }
            } else {
              console.log("\u6587\u4EF6\u5185\u5BB9\u76F8\u540C\uFF0C\u8DF3\u8FC7", file.title);
            }
          }
        }
        stack.push({ dir: currVault, visited: true });
        for (let i2 = currVault.directories.length - 1; i2 >= 0; i2--) {
          stack.push({ dir: currVault.directories[i2], visited: false });
        }
      } else {
        if (currVault !== vault) {
          path_join.pop();
        }
      }
    }
  }
}
function flattenVaultFilesOptimized(vault) {
  const fileMap = /* @__PURE__ */ new Map();
  const pathSegments = [];
  function processDir(dir) {
    pathSegments.push(dir.name);
    dir.files.forEach((file) => {
      pathSegments.push(file.title + ".md");
      const fullPath = pathSegments.join("/");
      fileMap.set(fullPath, file);
      pathSegments.pop();
    });
    dir.directories.forEach((subDir) => {
      processDir(subDir);
    });
    pathSegments.pop();
  }
  vault.files.forEach((file) => {
    pathSegments.push(file.title + ".md");
    fileMap.set(pathSegments.join("/"), file);
    pathSegments.pop();
  });
  vault.directories.forEach((dir) => processDir(dir));
  return fileMap;
}

// src/main.ts
var DEFAULT_SETTINGS = {
  passphrase: "",
  address: "",
  epoch: 10,
  lastSyncTimestamp: 0,
  autoSync: false,
  autoSyncInterval: 60
};
var VaultBridgePlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.autoSyncIntervalId = null;
  }
  async onload() {
    await this.loadSettings();
    this.addStyle();
    try {
      if (this.settings.passphrase === "") {
        new import_obsidian2.Notice("\u8BF7\u5148\u914D\u7F6EVault Bridge\u63D2\u4EF6");
      } else {
        this.mnemonicWallet = new MnemonicWallet(this.settings.passphrase);
        console.log(`\u94B1\u5305\u5730\u5740: ${this.mnemonicWallet.getAddress()}`);
        if (this.settings.address === "") {
          this.settings.address = this.mnemonicWallet.getAddress();
          await this.saveSettings();
        }
      }
      this.epoch = this.settings.epoch;
    } catch (error2) {
      console.error("\u521D\u59CB\u5316\u52A9\u8BB0\u8BCD\u94B1\u5305\u5931\u8D25", error2);
    }
    const ribbonIconEl = this.addRibbonIcon("cloud-sync", "Vault Bridge", (evt) => {
      if (this.settings.passphrase === "") {
        new import_obsidian2.Notice("\u8BF7\u5148\u914D\u7F6EVault Bridge\u63D2\u4EF6");
        return;
      }
      const menu = new import_obsidian2.Menu();
      menu.addItem((item) => {
        return item.setTitle("\u521D\u59CB\u5316").setIcon("webhook").onClick(async () => {
          const vaultName = this.app.vault.getName();
          const confirmModal = new ConfirmationModal(
            this.app,
            "\u521D\u59CB\u5316Vault",
            `\u786E\u5B9A\u8981\u521D\u59CB\u5316\u540D\u4E3A "${vaultName}" \u7684Vault\u5417\uFF1F`,
            async () => {
              try {
                const progressModal = new ProgressModal(this.app, "\u521D\u59CB\u5316\u8FDB\u884C\u4E2D");
                progressModal.open();
                progressModal.updateMessage("\u6B63\u5728\u8FDE\u63A5\u533A\u5757\u94FE...");
                this.vault = await initVault(vaultName, this.getMnemonicWallet());
                if (this.vault) {
                  progressModal.updateProgress(100);
                  progressModal.updateMessage("\u521D\u59CB\u5316\u6210\u529F!");
                  setTimeout(() => {
                    progressModal.close();
                    new import_obsidian2.Notice(`\u521D\u59CB\u5316\u6210\u529F\uFF0CVaultID: ${this.vault?.id}`);
                  }, 1500);
                } else {
                  progressModal.close();
                  new import_obsidian2.Notice("\u521D\u59CB\u5316\u5931\u8D25");
                }
              } catch (error2) {
                console.error("\u521D\u59CB\u5316\u8FC7\u7A0B\u51FA\u9519", error2);
                new import_obsidian2.Notice("\u521D\u59CB\u5316\u8FC7\u7A0B\u51FA\u9519\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0");
              }
            }
          );
          confirmModal.open();
        });
      });
      menu.addItem((item) => {
        return item.setTitle("\u4E0A\u4F20\u7B14\u8BB0").setIcon("upload-cloud").onClick(async () => {
          try {
            new import_obsidian2.Notice("\u51C6\u5907\u4E0A\u4F20\u7B14\u8BB0\u5230\u533A\u5757\u94FE");
            const vaultPath = this.app.vault.adapter.getBasePath();
            const vaultName = this.app.vault.getName();
            const files = this.app.vault.getMarkdownFiles();
            const confirmModal = new ConfirmationModal(
              this.app,
              "\u4E0A\u4F20\u7B14\u8BB0",
              `\u786E\u5B9A\u8981\u4E0A\u4F20 ${files.length} \u4E2A\u7B14\u8BB0\u6587\u4EF6\u5230\u533A\u5757\u94FE\u5417\uFF1F`,
              async () => {
                const progressModal = new ProgressModal(this.app, "\u4E0A\u4F20\u8FDB\u884C\u4E2D");
                progressModal.open();
                let vault = await initVault(vaultName, this.getMnemonicWallet());
                if (vault) {
                  await pushToChain(
                    vault,
                    vaultPath,
                    files,
                    this.getMnemonicWallet(),
                    this.getEpoch(),
                    (message) => {
                      progressModal.updateMessage(message);
                    },
                    this.app
                  );
                  this.settings.lastSyncTimestamp = Date.now();
                  await this.saveSettings();
                  this.updateStatusBar();
                  progressModal.close();
                }
              }
            );
            confirmModal.open();
          } catch (e3) {
            console.error("\u4E0A\u4F20\u8FC7\u7A0B\u51FA\u9519", e3);
            new import_obsidian2.Notice("\u4E0A\u4F20\u8FC7\u7A0B\u51FA\u9519\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0");
          }
        });
      });
      menu.addItem((item) => {
        return item.setTitle("\u4E0B\u8F7D\u7B14\u8BB0").setIcon("download-cloud").onClick(async () => {
          try {
            new import_obsidian2.Notice("\u51C6\u5907\u4ECE\u533A\u5757\u94FE\u4E0B\u8F7D\u7B14\u8BB0");
            const vaultPath = this.app.vault.adapter.getBasePath();
            const vaultName = this.app.vault.getName();
            const files = this.app.vault.getMarkdownFiles();
            const confirmModal = new ConfirmationModal(
              this.app,
              "\u4E0B\u8F7D\u7B14\u8BB0",
              "\u786E\u5B9A\u8981\u4ECE\u533A\u5757\u94FE\u4E0B\u8F7D\u7B14\u8BB0\u5417\uFF1F\u8FD9\u53EF\u80FD\u4F1A\u8986\u76D6\u672C\u5730\u6587\u4EF6\u3002",
              async () => {
                const progressModal = new ProgressModal(this.app, "\u4E0B\u8F7D\u8FDB\u884C\u4E2D");
                progressModal.open();
                let vault = await initVault(vaultName, this.getMnemonicWallet());
                if (!vault) {
                  progressModal.close();
                  new import_obsidian2.Notice("\u4E0B\u8F7D\u5931\u8D25\uFF0C\u8BF7\u5148\u521D\u59CB\u5316");
                  return;
                }
                progressModal.updateMessage("\u6B63\u5728\u4E0B\u8F7D\u6587\u4EF6...");
                let dataAdapter = this.app.vault.adapter;
                await pullFromChain(vault, vaultPath, files, this.mnemonicWallet, dataAdapter, this.app);
                this.settings.lastSyncTimestamp = Date.now();
                await this.saveSettings();
                this.updateStatusBar();
                progressModal.updateMessage("\u4E0B\u8F7D\u5B8C\u6210!");
                setTimeout(() => {
                  progressModal.close();
                  new import_obsidian2.Notice("\u4ECE\u533A\u5757\u94FE\u4E0B\u8F7D\u7B14\u8BB0\u5B8C\u6210");
                }, 1500);
              }
            );
            confirmModal.open();
          } catch (e3) {
            console.error("\u4E0B\u8F7D\u8FC7\u7A0B\u51FA\u9519", e3);
            new import_obsidian2.Notice("\u4E0B\u8F7D\u8FC7\u7A0B\u51FA\u9519\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0");
          }
        });
      });
      menu.addItem((item) => {
        return item.setTitle("\u540C\u6B65\u72B6\u6001").setIcon("info").onClick(() => {
          let lastSync = "\u4ECE\u672A";
          if (this.settings.lastSyncTimestamp > 0) {
            const date = new Date(this.settings.lastSyncTimestamp);
            lastSync = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
          }
          const modal = new VaultSyncModal(
            this.app,
            "\u540C\u6B65\u72B6\u6001\u4FE1\u606F",
            `\u6700\u540E\u540C\u6B65\u65F6\u95F4: ${lastSync}
\u94B1\u5305\u5730\u5740: ${this.settings.address}
\u5B58\u50A8\u65F6\u957F: ${this.settings.epoch} epochs
\u81EA\u52A8\u540C\u6B65: ${this.settings.autoSync ? "\u5F00\u542F" : "\u5173\u95ED"}
\u540C\u6B65\u95F4\u9694: ${this.settings.autoSyncInterval} \u5206\u949F`
          );
          modal.open();
        });
      });
      menu.showAtMouseEvent(evt);
    });
    ribbonIconEl.addClass("vault-bridge-ribbon-icon");
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar();
    this.addSettingTab(new VaultBridgeSettingTab(this.app, this));
    if (this.settings.autoSync) {
      this.startAutoSync();
    }
  }
  // 
  addStyle() {
    const styleEl = document.createElement("style");
    styleEl.id = "vault-bridge-styles";
    styleEl.textContent = `
            .vault-bridge-ribbon-icon {
                color: var(--vault-bridge-primary-color);
                opacity: 0.8;
                transition: all 0.3s ease;
            }
            
            .vault-bridge-ribbon-icon:hover {
                opacity: 1;
                transform: scale(1.1);
            }
            
            .vault-bridge-ribbon-icon.is-active {
                color: var(--vault-bridge-success-color);
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.1);
                }
                100% {
                    transform: scale(1);
                }
            }
        `;
    document.head.appendChild(styleEl);
  }
  // 
  updateStatusBar() {
    let statusText = "\u672A\u540C\u6B65";
    if (this.settings.lastSyncTimestamp > 0) {
      const lastSync = new Date(this.settings.lastSyncTimestamp);
      const now = new Date();
      const diffHours = Math.round((now.getTime() - lastSync.getTime()) / (1e3 * 60 * 60));
      if (diffHours < 24) {
        statusText = `\u6700\u8FD1\u540C\u6B65: ${diffHours}\u5C0F\u65F6\u524D`;
      } else {
        const diffDays = Math.round(diffHours / 24);
        statusText = `\u6700\u8FD1\u540C\u6B65: ${diffDays}\u5929\u524D`;
      }
    }
    this.statusBarItem.setText(`\u{1F4DD} Vault Bridge: ${statusText}`);
  }
  // 
  startAutoSync() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      try {
        const now = Date.now();
        const lastSync = this.settings.lastSyncTimestamp || 0;
        const intervalMs = this.settings.autoSyncInterval * 60 * 1e3;
        if (now - lastSync >= intervalMs) {
          const vaultPath = this.app.vault.adapter.getBasePath();
          const vaultName = this.app.vault.getName();
          const files = this.app.vault.getMarkdownFiles();
          let vault = await initVault(vaultName, this.getMnemonicWallet());
          if (vault) {
            await pushToChain(
              vault,
              vaultPath,
              files,
              this.getMnemonicWallet(),
              this.getEpoch(),
              (message) => {
                console.log(`\u81EA\u52A8\u540C\u6B65: ${message}`);
              },
              this.app
            );
            this.settings.lastSyncTimestamp = Date.now();
            await this.saveSettings();
            this.updateStatusBar();
            new import_obsidian2.Notice("\u81EA\u52A8\u540C\u6B65\u5B8C\u6210");
          }
        }
      } catch (error2) {
        console.error("\u81EA\u52A8\u540C\u6B65\u5931\u8D25", error2);
        new import_obsidian2.Notice("\u81EA\u52A8\u540C\u6B65\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0");
      }
    }, 6e4);
  }
  // 
  stopAutoSync() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  setEpoch(epoch) {
    this.epoch = epoch;
  }
  showNotice(message) {
    new import_obsidian2.Notice(message);
  }
  getEpoch() {
    return this.epoch;
  }
  getMnemonicWallet() {
    return this.mnemonicWallet;
  }
  onunload() {
    if (this.mnemonicWallet) {
      this.mnemonicWallet.destroy();
    }
    this.stopAutoSync();
    const styleEl = document.getElementById("vault-bridge-styles");
    if (styleEl) {
      styleEl.remove();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var VaultBridgeSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("vault-bridge-settings");
    containerEl.createEl("h2", { text: "Vault Bridge \u8BBE\u7F6E" });
    new import_obsidian2.Setting(containerEl).setName("\u52A9\u8BB0\u8BCD").setDesc("\u8F93\u5165\u60A8\u7684\u52A9\u8BB0\u8BCD\u4EE5\u751F\u6210\u94B1\u5305").addText((text) => text.setPlaceholder("\u8F93\u5165\u60A8\u7684\u52A9\u8BB0\u8BCD").setValue(this.plugin.settings.passphrase).onChange(async (value2) => {
      try {
        if (value2 !== "" && this.plugin.settings.passphrase !== value2) {
          this.plugin.mnemonicWallet = new MnemonicWallet(value2);
          this.plugin.settings.address = this.plugin.mnemonicWallet.getAddress();
          if (this.addressDisplay) {
            this.addressDisplay.textContent = `\u5F53\u524D\u94B1\u5305\u5730\u5740: ${this.plugin.settings.address}`;
          }
        }
      } catch (error2) {
        console.error("\u521D\u59CB\u5316\u52A9\u8BB0\u8BCD\u94B1\u5305\u5931\u8D25", error2);
      }
      this.plugin.settings.passphrase = value2;
      await this.plugin.saveSettings();
    }));
    const addressContainer = containerEl.createDiv("vault-bridge-status vault-bridge-status-info");
    this.addressDisplay = addressContainer.createSpan();
    this.addressDisplay.textContent = this.plugin.settings.address ? `\u5F53\u524D\u94B1\u5305\u5730\u5740: ${this.plugin.settings.address}` : "\u672A\u8BBE\u7F6E\u94B1\u5305";
    new import_obsidian2.Setting(containerEl).setName("Epoch \u6570\u91CF").setDesc("\u6587\u4EF6\u5728Walrus\u4E0A\u5B58\u50A8\u7684epoch\u6570\u91CF\uFF0C\u9ED8\u8BA4\u4E3A10").addText((text) => text.setPlaceholder("\u8F93\u5165Epoch\u6570\u91CF").setValue(this.plugin.settings.epoch.toString()).onChange(async (value2) => {
      try {
        const tempEpoch = parseInt(value2);
        if (tempEpoch > 0) {
          this.plugin.settings.epoch = tempEpoch;
          await this.plugin.saveSettings();
          this.plugin.setEpoch(tempEpoch);
        }
      } catch (error2) {
        console.error("Epoch\u503C\u65E0\u6548", error2);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("\u542F\u7528\u81EA\u52A8\u540C\u6B65").setDesc("\u5B9A\u671F\u81EA\u52A8\u5C06\u7B14\u8BB0\u540C\u6B65\u5230\u533A\u5757\u94FE").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value2) => {
      this.plugin.settings.autoSync = value2;
      await this.plugin.saveSettings();
      if (value2) {
        this.plugin.startAutoSync();
      } else {
        this.plugin.stopAutoSync();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("\u540C\u6B65\u95F4\u9694").setDesc("\u81EA\u52A8\u540C\u6B65\u7684\u65F6\u95F4\u95F4\u9694\uFF08\u5206\u949F\uFF09").addText((text) => text.setPlaceholder("\u8F93\u5165\u5206\u949F\u6570").setValue(this.plugin.settings.autoSyncInterval.toString()).onChange(async (value2) => {
      try {
        const interval = parseInt(value2);
        if (interval > 0) {
          this.plugin.settings.autoSyncInterval = interval;
          await this.plugin.saveSettings();
          if (this.plugin.settings.autoSync) {
            this.plugin.stopAutoSync();
            this.plugin.startAutoSync();
          }
        }
      } catch (error2) {
        console.error("\u540C\u6B65\u95F4\u9694\u65E0\u6548", error2);
      }
    }));
    if (this.plugin.settings.lastSyncTimestamp > 0) {
      const lastSyncDate = new Date(this.plugin.settings.lastSyncTimestamp);
      const lastSyncInfo = containerEl.createDiv("vault-bridge-status vault-bridge-status-success");
      lastSyncInfo.createSpan().textContent = `\u6700\u540E\u540C\u6B65\u65F6\u95F4: ${lastSyncDate.toLocaleString()}`;
    }
    new import_obsidian2.Setting(containerEl).setName("\u91CD\u7F6E\u540C\u6B65\u72B6\u6001").setDesc("\u6E05\u9664\u6700\u540E\u540C\u6B65\u65F6\u95F4\u8BB0\u5F55").addButton((button) => button.setButtonText("\u91CD\u7F6E").onClick(async () => {
      this.plugin.settings.lastSyncTimestamp = 0;
      await this.plugin.saveSettings();
      this.plugin.updateStatusBar();
      new import_obsidian2.Notice("\u540C\u6B65\u72B6\u6001\u5DF2\u91CD\u7F6E");
      this.display();
    }));
  }
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/bls.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/tower.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/nist.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
